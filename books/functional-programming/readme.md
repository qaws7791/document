# 함수형 프로그래밍



## 함수형 프로그래밍이란

**부수 효과(side effect)**없이 **순수 함수**만 사용하는 프로그래밍

부수 효과(side effect): 함수가 반환하는 값 이외의 일

순수 함수: 같은 입력에 대해 항상 같은 출력을 반환하는 부수 효과 없는 함수

하지만 부수 효과는 프로그래밍에서 필요하기 때문에 함수형 프로그래밍이 부수 효과를 배제하는 것은 아니다

## 액션과 계산, 데이터

- 액션: 호출하는 시점이나 횟수에 의존하거나 외부 시스템과 상호작용하는 함수. 
  - 상태 변경 보장
  - 순서 보장
  - 실행 횟수 보장
- 계산: 입력값을 계산하여 반환(출력)하는 함수
  - 정확한 계산
  - 효율적인 계산 수식
  - 테스트
- 데이터: 이벤트에 대한 결과
  - 효율적 접근
  - 안전한 데이터 보관
  - 데이터 분석



## 계산보다 액션

- 테스트하기 쉽다 - 계산은 같은 입력에 대해 항상 같은 값을 반환하므로 테스트하기 쉽습니다
- 정적 분석이 쉽다 
- 조합하기 쉽다



## 액션을 부르면 액션이다

어떤 함수가 내부에서 액션을 사용한다면 이 함수도 액션이 됩니다. 이 함수가 언제 실행하는지가 이 함수 내부의 액션 호출 시점에 영향을 주기 때문입니다.



## 자바스크립트에서 액션

- DOM 관련 메서드
  - `document.METHOD`
- alert, confirm 호출
  - `alert`, `confirm`
- 콘솔 출력
  - `console.log`
- 날짜, 시간과 관련된 작업
  - new Date()
- 참조 사용
  - 변수, 속성, 배열, 객체
- 상태 변경
  - 값 할당
  - 속성 변경, 삭제



## 액션은 어렵다

액션은 소프트웨어를 사용하는 가장 큰 이유이지만 그만큼 잘못 사용하면 위험합니다

1. 액션을 필요할 때만 최대한 적게 사용해야 합니다. 
2. 액션은 가장 작게 만들어야 합니다. 불필요한 부분은 제거하거나 빼내야 합니다
   1. 암묵적 입력과 출력을 제거하여 계산으로 만들기
3. 액션이 외부 세계와 상호작용하는 것을 제한 할 수 있다
4. 엑션이 호출 시점에 의존하는 것을 제한할 수 있다

## 재사용하기

- 전역 변수에 의존하지 않기 & 전역변수를 변경하지 않고 값을 반환하기
- 특정 조건에서 실행된다고 가정하지 않기

## 액션에서 계산으로 변경하기

- 계산 부분은 별도의 함수로 분리하기
- 암묵적 입력은 인자(명시적 입력)로, 암묵적 출력은 반환 값(명시적 출력)으로 변경하기
  - 암묵적 입력: 인자가 아닌 입력
  - 암묵적 출력: 반환 값이 아닌 출력



## 작게 분리된 코드의 장점

- 재사용하기 쉽다
- 유지보수가 쉽다
- 테스트가 쉽다



## 데이터 불변성 유지

### Copy on Write

1. 복사본 생성
2. 복사본 변경
3. 복사본 반환

### 불변 데이터

- 변경 가능한 데이터를 읽는 것 -> 액션
- 불변 데이터를 읽는 것 -> 계산



### 구조적 공유

전체 데이터를 복사하지 않고 내부 데이터가 같은 데이터를 참조하는 방법

복사본 간에 영향을 미치지 않게 하려면 깊은 복사를 사용하여 전체를 복사할 수 있다. 깊은 복사는 모든 데이터 구조를 복사하기 때문에 성능에 부정적 영향을 줄 수 있다

다른 방법으로는 `Object.freeze()`과 같은 메서드를 사용하여 데이터를 변경되지 않도록 할 수 있다. 변경되지 않는 데이터는 얕은 복사로 변경해도 안전하다

구조적 공유는 데이터를 복사할 때 데이터가 변경되지 않는 부분에 대해서는 복사를 하는 대신 재사용하는 방법이다

- 얕은 복사: 복사본의 속성이 복사본이 만들어진 원본 객체와 같은 참조를 공유하는 복사 - 적은 비용
- 깊은 복사: 원본과 복사본이 완전히 독립적인 복사 - 많은 비용

```javascript
//name="john"인 사람의 age를 20으로 수정
const people = [
  { name: 'john', age: 25 },
  { name: 'jane', age: 30 },
  { name: 'bob', age: 35 }
];

const setAgeByName = (people, name, age) => {
	return people.map(p => {
        return p.name === name ? {...p, age} : p
    })
}

const changedPeople = setAgeByName(people,'john',20)
```



## 방어적 복사

 방어적 복사는 불변성 코드에서 데이터가 변경될 수도 있는 코드와 데이터를 주고받기 위한 방법으로, 데이터를 내보내거나 가져올 때 **깊은 복사본**을 만들어 사용합니다

깊은 복사: `JSON.stringify()` - 객체 -> JSON 문자열, `JSON.parse()` - 문자열 -> js 객체

```mermaid
flowchart LR
    subgraph 안전한 구역
    	Code1
    	Code4
    end
    subgraph 안전하지 않은 구역
    	Code2
    	Code3
    end
    Code1 -. 방어적 복사 .->Code2
    Code2 -. 데이터 변경 .->Code3
    Code3 -. 방어적 복사 .->Code4
```

```javascript
const function_safe(data) => {
	const copy = deep_copy(data)
	changeMutableData(copy)
	return deep_copy(copy)
}
```

https://lodash.com/docs/4.17.15#cloneDeep



# 계층형 설계

- 패턴1: 직접 구현
- 패턴 2: 추상화 벽
- 패턴 3: 작은 인터페이스
- 패턴 4: 편리한 계층



## 패턴 1: 직접 구현

- 한 함수에서는 자신보다 낮은 추상화 계층 중 같은 계층에 있는 함수들을 호출한다
- 함수 내의 추상화 수준이 제각각이라면 구체화 수준을 같도록 추출·정리한다 
- 더 작은 함수로 분리할수록 재사용 및 테스트하기 하기 쉬워진다

```javascript
const makeItem = (name,price) => {
    return {
        name,
        price
    }
}

const addItem = (cart, item) => {
    return cart.push(item)
}

const isInCart = (cart, name) => {
    return cart.some(c => c.name === name)
}
```

```javascript
// 넥타이를 하나 사면 넥타이 클립을 하나 무료로 주는 코드
const freeTieClipWhenBuyTie = (cart) => {
    const hasTie = isInCart(cart, "tie")
    const hasTieClip = isInCart(cart, "tie clip")
    if(hasTie && !hasTieClip) {
        const tieClip = makeItem("tie clip", 0)
        return addItem(cart, tieClip)
    }
    return cart
}
```

### 목적별 계층

1. 장바구니 비지니스 규칙
2. 일반 비지니스 규칙
3. 장바구니 기본 동작
4. 제품 기본 동작
5. copy-on-write 동작
6. 자바스크립트 기능



## 패턴 2: 추상화 벽

세부 구현을 감춘 함수로 구성하여 누구나 함수 이름만 보고 직관적으로 사용할 수 있도록 한다

추상화 벽 위에 있는 함수는 분리되어 있기 때문에 추상화 벽 내의 함수가 어떤 데이터 구조인지 알지 않아도 됩니다

- 미래에 구현이 바뀔 것으로 예상될 때 쉽게 바꿀 수 있다
- 구체적인 구현을 내부로 숨겨 코드를 쉽게 사용할 수 있다
- 팀 간에 서로 신경쓰지 않고 작업하며(커뮤니케이션 비용 감소), 팀 간 책임을 명확히 나눌 수 있다
- 추상화 벽에 코드가 많아지면, 구현이 바뀔 때 변경해야 할 코드가 많아집니다

## 패턴 3: 작은 인터페이스

인터페이스를 최소화하여 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막기

시계 할인 마케팅을 구현하기 위한 두 가지 방법

- 추상화 벽에 만들기
- 추상화 벽 위에 만들기

장바구니에 제품을 담을 때 로그 남기기

- add_item() 안에서 호출하기 -> add_item 함수가 계산에서 액션으로 바뀜
- add_item_to_cart() 핸들러 함수 안에서 호출하기 -> 핸들러 함수는 원래 액션이기 때문에 바뀌는 것이 없음

## 패턴 4: 편리한 계층

코드가 편하다면 설계를 그래도 두고 조금 벗어나도 그냥 사용하는 것이 나을 수 있다

나중에 너무 지저분해진다고 생각될 때 다시 패턴을 적용하면 된다

편리한 계층은 설계와 기능 사이에서 어느 지점에 머물지를 생각



## 호출 그래프

세 가지 비기능적 요구사항



### 유지보수성

쉽게 변경할 수 있는가 

- 위로 연결된 함수가 적은 함수일수록(호출 그래프의 상단에 위치할 수록) 고치기 쉽다



### 테스트성

테스트가 중요한가

- 위로 많이 연결된 함수일수록(하단에 위치한 코드) 테스트가 중요하다



### 재사용성

재사용하기 좋은가

- 하단에 위치한 함수가 적을 수록 재사용하기 더 쉽습니다