---
title: Sorting
description: 정렬 알고리즘은 데이터를 특정 순서로 재배치하는 알고리즘입니다.
---


## 정렬이란

알고리즘에서 정렬이란  키와 데이터가 포함된 레코드 목록을 입력으로 하여 키가 감소하지 않는 순서가 되도록 목록을 재배치하고 출력 목록은 모든 원래 레코드를 유지하면서 입력 목록의 순열이 되도록 하는 알고리즘입니다. 정렬은 다양한 알고리즘 문제에서 기본적으로 사용되며, 데이터를 효율적으로 관리하거나 처리하기 위한 중요한 과정입니다.


### 정렬의 조건

1. 키가 감소하지 않는 순서가 되도록 목록을 재배치
2. 출력 목록은 모든 원래 레코드를 유지하면서 입력 목록의 순열


### 정렬 알고리즘의 성능 평가

1. **시간 복잡도**
   - 최선, 평균, 최악의 경우의 실행 시간을 고려.
2. **공간 복잡도**
   - 추가적인 메모리를 사용하는지 여부.
3. **안정성**
   - **안정 정렬**: 값이 같은 요소의 상대적인 순서가 유지됨.
   - **비안정 정렬**: 값이 같은 요소의 순서가 바뀔 수 있음.


## 정렬 알고리즘의 분류


### 데이터 저장 위치에 따른 분류

두 방식의 주요 차이점은 정렬 과정에서 '데이터를 어디에 저장하느냐'에 있습니다.


#### 내부 정렬 (Internal Sort)

- **정의:** 모든 데이터를 주기억장치(RAM)에 로드한 후 메모리 내에서 정렬하는 방식입니다.
- 특징
  - 주기억장치에서 모든 작업이 이루어지므로 속도가 빠릅니다.
  - 메모리 용량의 제약으로 인해 대용량 데이터를 정렬할 수 없습니다.
  - 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬 등이 내부 정렬에 해당합니다.
- **장점:** 속도가 빠르기 때문에 작은 데이터 세트를 정렬하는 데 효율적입니다.
- **단점:** 메모리 용량보다 큰 데이터를 정렬할 수 없습니다.


#### 외부 정렬 (External Sort)

- **정의:** 데이터가 너무 커서 주기억장치에 모두 로드할 수 없을 때, 외부 보조 기억장치(하드 디스크 등)를 활용하여 정렬하는 방식입니다.
- 특징
  - 데이터를 여러 블록으로 나누어 외부 기억장치와 주기억장치 사이를 이동시키면서 정렬합니다.
  - 내부 정렬에 비해 속도가 느립니다.
  - 대용량 데이터 정렬에 적합합니다.
  - 대표적인 외부 정렬 알고리즘으로는 병합 정렬의 변형인 외부 병합 정렬(External Merge Sort)이 있습니다.
- **장점:** 메모리 용량보다 훨씬 큰 데이터를 정렬할 수 있습니다.
- **단점:** 디스크 I/O가 발생하기 때문에 내부 정렬에 비해 속도가 느립니다.


### 안정성에 따른 분류

두 방식의 주요 차이점은 동일한 키를 가진 입력 데이터에 대해 정렬 후에도 상대적인 순서가 유지되는지의 여부입니다. 이를 **안정성(Stability)**이라고 합니다


#### 안정 정렬 (Stable Sort)

안정 정렬은 동일한 값을 가진 원소들의 상대적인 순서가 정렬 후에도 유지되는 정렬 알고리즘입니다. 즉, 입력 데이터에서 같은 값을 가진 원소들의 순서가 정렬 후에도 바뀌지 않습니다.

- **예시:**
  - 입력 데이터: `[(3, 'A'), (1, 'B'), (3, 'C'), (2, 'D')]`
  - 첫 번째 요소(숫자)를 기준으로 안정 정렬한 결과: `[(1, 'B'), (2, 'D'), (3, 'A'), (3, 'C')]`
  - 'A'와 'C'는 모두 값 3을 가지는데, 입력 데이터에서 'A'가 'C'보다 먼저 나왔으므로 정렬 후에도 'A'가 'C'보다 앞에 위치합니다.
- **중요성:** 데이터에 추가적인 정보가 연결되어 있을 때 중요합니다. 예를 들어, 학생 목록을 반별로 정렬한 후, 같은 반 내에서 이름순으로 정렬한다고 가정해 보겠습니다. 첫 번째 정렬(반별)이 안정 정렬이라면, 두 번째 정렬(이름순)을 수행한 후에도 같은 반 학생들끼리는 기존의 순서가 유지됩니다.


#### 불안정 정렬 (Unstable Sort)

불안정 정렬은 동일한 값을 가진 원소들의 상대적인 순서가 정렬 후 바뀔 수 있는 정렬 알고리즘입니다. 입력 데이터에서 같은 값을 가진 원소들의 순서가 정렬 후 바뀔 수도 있습니다.

- 예시:
  - 입력 데이터: `[(3, 'A'), (1, 'B'), (3, 'C'), (2, 'D')]`
  - 첫 번째 요소(숫자)를 기준으로 불안정 정렬한 결과: `[(1, 'B'), (2, 'D'), (3, 'C'), (3, 'A')]`
  - 'A'와 'C'의 순서가 바뀌었습니다.


### 정렬 방식에  따른 분류


#### 비교 기반 정렬

- 데이터를 비교하여 정렬을 수행.
- 예: **버블 정렬**, **삽입 정렬**, **퀵 정렬**, **합병 정렬**, **힙 정렬**.

비교하지 않는 정렬

- 데이터의 비교 없이 정렬.
- 예: **카운팅 정렬**, **기수 정렬**, **버킷 정렬**.


### 입력 데이터 처리 방법에 따른 분류

데이터가 입력되는 시점에 따라 정렬을 수행하는지, 모든 데이터가 입력된 후에 정렬을 수행하는지에 따라 구분됩니다. 온라인 알고리즘은 항상 정렬된 목록을 가지고 새로운 데이터가 들어오면 이를 목록에 추가합니다. 반면 오프라인 알고리즘은 모든 데이터가 사용 가능해질 때까지 기다려야 합니다.


#### 온라인 정렬 (Online Sort)

데이터가 순차적으로 입력되는 즉시 정렬을 수행하는 방식입니다. 모든 데이터가 한 번에 주어지지 않고, 데이터가 스트림 형태로 실시간으로 입력되는 상황에서 유용합니다.

- 특징
  - 데이터가 입력될 때마다 정렬된 상태를 유지합니다.
  - 모든 데이터를 저장할 필요가 없으므로 메모리 사용량이 적을 수 있습니다.
  - 데이터가 실시간으로 변하는 환경에 적합합니다.
- 예시
  - 삽입 정렬: 새로운 데이터가 입력될 때마다 이미 정렬된 부분에 적절한 위치에 삽입합니다.
  - 균형 이진 탐색 트리 (Balanced Binary Search Tree)를 이용한 정렬: 데이터가 입력될 때마다 트리에 삽입하여 정렬된 상태를 유지합니다.
- 장점
  - 실시간 데이터 처리에 적합합니다.
  - 메모리 효율적일 수 있습니다 (모든 데이터를 저장할 필요가 없는 경우).
- 단점
  - 모든 데이터를 한 번에 정렬하는 방식에 비해 효율성이 떨어질 수 있습니다.
  - 특정 시점의 전체 정렬된 결과를 얻기 어려울 수 있습니다 (계속 데이터가 입력되는 경우).


#### 오프라인 정렬 (Offline Sort)

모든 데이터가 입력된 후에 한 번에 정렬을 수행하는 방식입니다. 일반적인 정렬 알고리즘들이 대부분 오프라인 정렬에 해당합니다.

- 특징
  - 모든 데이터를 메모리 또는 디스크에 저장해야 합니다.
  - 정렬 전에 데이터의 전체적인 특성을 파악할 수 있습니다.
  - 일반적으로 온라인 정렬보다 효율적인 알고리즘을 사용할 수 있습니다.
- 예시
  - 퀵 정렬 (Quick Sort), 병합 정렬 (Merge Sort), 힙 정렬 (Heap Sort)
- 장점
  - 다양하고 효율적인 정렬 알고리즘을 사용할 수 있습니다.
  - 특정 시점의 전체 정렬된 결과를 쉽게 얻을 수 있습니다.
- 단점
  - 모든 데이터를 저장해야 하므로 메모리 사용량이 많을 수 있습니다.
  - 실시간 데이터 처리에 적합하지 않습니다.


### 그 외


#### 적응형 정렬(Adaptive Sort)

입력 데이터의 이미 존재하는 기존 순서를 활용하는 정렬입니다.

이러한 정렬은 데이터가 부분적으로 이미 정렬되어 있을 때 더 나은 성능을 보입니다.

- **입력 데이터의 정렬 상태에 따라 성능이 달라짐:** 거의 정렬된 입력에 대해서는 O(n)에 가까운 시간 복잡도를 가질 수 있지만, 완전히 무작위로 섞인 입력에 대해서는 일반적인 정렬 알고리즘과 비슷한 성능을 보입니다.
- **무질서도(Disorder) 측정:** 입력 데이터가 얼마나 정렬되지 않았는지를 측정하는 다양한 방법이 사용됩니다. 예를 들어, 역전(Inversion)의 개수, 연속된 정렬되지 않은 부분의 개수 등을 측정하여 무질서도를 판단합니다.


#### 제자리 정렬(In-place Sort)

제자리 정렬(In-place Sort)은 추가적인 메모리 공간을 상수 수준(O(1))으로 사용하는 정렬 알고리즘입니다.

정렬할 입력 데이터의 크기 n 만큼 저장하는 것 이외에 추가적인 메모리 공간이 필요할 때 제자리 이탈(out-of-place) 알고리즘이라고 합니다.

같은 알고리즘이라도 구현 방식에 따라 추가 메모리 공간이 필요하거나 필요하지 않을 수 있습니다.

- 정렬 과정에서 입력 배열 내의 원소들을 교환(swap)하거나 이동시키면서 정렬을 수행
- **메모리 효율성:** 추가적인 메모리 할당이 거의 필요 없기 때문에 메모리 사용량이 매우 적습니다. 특히, 대용량 데이터를 정렬할 때 메모리 효율성이 중요해지는데, 제자리 정렬은 이러한 상황에서 매우 유리합니다.
- **캐시 효율성:** 데이터가 연속된 메모리 공간에 저장되어 있기 때문에 캐시 메모리를 효율적으로 사용할 수 있습니다. 이는 프로그램의 실행 속도를 향상시키는 데 도움이 됩니다. (참고: 메모리가 연속적이지 않으면 캐시 메모리를 사용할 때 불이익이 있을 수 있습니다)
- 주요 제자리 정렬 알고리즘: 선택 정렬, 삽입 정렬, 버블 정렬, 힙 정렬, 퀵 정렬
- 제자리 정렬이 아닌 정렬 알고리즘: 병합 정렬(정렬된 두 부분을 병합하기 위해 추가적인 메모리 공간이 필요)


## 버블 정렬 (Bubble Sort)

가장 큰 값이 "거품처럼" 목록의 맨 위로 이동한다는 아이디어에서 버블 정렬이라는 이름이 탄생했습니다.

- **원리**:
   1. 인접한 두 요소를 비교합니다.
   2. 가장 큰 값을 맨 뒤로 보냅니다.
   3. 두 번째로 큰 값을 맨 뒤에서 두 번째로 보냅니다.
   4. 이러한 과정을 반복하면서 맨 뒤쪽부터 정렬이 완료됩니다.

- **시간 복잡도**
  - 최선: **O(n)** (이미 정렬된 경우)
  - 최악: **O(n²)** (역순 정렬된 경우)

- **공간 복잡도**: **O(1)** (추가 메모리 사용 없음)

```javascript
function bubbleSort(arr, from = 0, to = arr.length - 1) {
  for (let i = to; i > from; i--) {
    for (let j = from; j < i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```


## 셔플 정렬 (Shuffle Sort)

버블링 정렬과 싱킹 정렬을 번갈아가며 수행하는 정렬 방식입니다.

- **원리**:
   1. 먼저 버블링 정렬을 수행하여 가장 큰 값을 맨 뒤로 보냅니다.
   2. 다음으로 싱킹 정렬을 수행하여 가장 작은 값을 맨 앞으로 보냅니다.
   3. 이러한 과정을 반복하면서 정렬이 완료됩니다.

- **시간 복잡도**
  - 최선: **O(n)** (이미 정렬된 경우)
  - 최악: **O(n²)** (역순 정렬된 경우)

- **공간 복잡도**: **O(1)** (추가 메모리 사용 없음)

```javascript
function shuffleSort(arr, from = 0, to = arr.length - 1) {
  let left = from;
  let right = to;

  while (left < right) {
    for (let i = left; i < right; i++) {
      if (arr[i] > arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
      }
    }
    right--;

    for (let i = right; i > left; i--) {
      if (arr[i] < arr[i - 1]) {
        [arr[i], arr[i - 1]] = [arr[i - 1], arr[i]];
      }
    }
    left++;
  }

  return arr;
}
```


## 선택 정렬 (Selection Sort)

가장 작은 값을 찾아 맨 앞으로 보내는 방식의 정렬입니다.

- **원리**:
   1. 주어진 리스트 중 최소값을 찾아 맨 앞의 요소와 교체합니다.
   2. 다음으로 두 번째로 작은 요소를 찾아 두 번째 위치에 놓습니다.
   3. 이렇게 앞 부분이 정렬되면서 전체 리스트가 정렬됩니다.

- **시간 복잡도**
  - 최선: **O(n²)**
  - 최악: **O(n²)**

- **공간 복잡도**: **O(1)**

```javascript
function selectionSort(arr, from = 0, to = arr.length - 1) {
  for (let i = from; i < to; i++) {
    let minIndex = i;

    for (let j = i + 1; j <= to; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }

    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }

  return arr;
}
```


## 삽입 정렬 (Insertion Sort)

각 요소를 적절한 위치에 삽입하여 정렬하는 방식의 정렬입니다.

- **원리**:
   1. 두 번째 요소부터 시작합니다.
   2. 현재 요소를 정렬된 부분의 적절한 위치에 삽입합니다.
   3. 이러한 과정을 반복하면서 정렬이 완료됩니다.

- **시간 복잡도**
  - 최선: **O(n)** (이미 정렬된 경우)
  - 최악: **O(n²)** (역순 정렬된 경우)

- **공간 복잡도**: **O(1)**

```javascript
function insertionSort(arr, from = 0, to = arr.length - 1) {
  for (let i = from + 1; i <= to; i++) {
    const key = arr[i];
    let j = i - 1;

    // key보다 큰 요소를 오른쪽으로 이동
    while (j >= from && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }

    arr[j + 1] = key;
  }

  return arr;
}
```


## 셸 정렬 (Shell Sort)

셸 정렬은 삽입 정렬의 개선된 버전으로, 삽입 정렬의 장점을 살리면서도 단점을 보완한 정렬 알고리즘입니다. 간격(gap)은 삽입 정렬을 수행하는 데 필요한 요소들의 간격을 의미합니다. 셸 정렬의 성능은 간격의 크기에 따라 달라집니다.

삽입 정렬은 거의 정렬된 배열에 대해서는 빠르게 동작하지만, 역순으로 정렬된 배열에 대해서는 매우 느리게 동작합니다. 왜냐하면 삽입 정렬은 한 번에 한 요소씩만 이동하기 때문에 역순으로 정렬된 배열에서는 매우 많은 이동이 필요합니다. 셸 정렬은 이러한 단점을 보완하기 위해 간격을 두어 삽입 정렬을 수행합니다.

- **원리**:
   1. 정렬할 데이터를 일정한 간격으로 나누어 삽입 정렬을 수행합니다.
   2. 간격을 점차 줄여가며 삽입 정렬을 수행합니다.
   3. 간격이 1이 되면 삽입 정렬을 수행하여 정렬을 완료합니다.

- **시간 복잡도**
  - 최선: **O(n log n)**
  - 최악: **O(n²)** (최악의 간격), **O(n^1.25)** (최선의 간격)


## 퀵 정렬 (Quick Sort)

분할 정복 알고리즘 중 하나로, 평균적으로 가장 빠른 정렬 알고리즘 중 하나입니다.

- **원리**:
   1. 배열에서 하나의 요소를 선택하고, 이를 피벗(pivot)으로 설정합니다.
   2. 피벗을 기준으로 작은 요소는 왼쪽, 큰 요소는 오른쪽으로 이동시킵니다.
   3. 왼쪽과 오른쪽 부분 배열에 대해 재귀적으로 퀵 정렬을 수행합니다.
   4. 부분 배열의 크기가 0이나 1이 될 때까지 반복합니다.
   5. 모든 부분 배열이 정렬되면 전체 배열도 정렬됩니다.

- **시간 복잡도**
  - 평균: **O(n log n)**
  - 최악: **O(n²)** (pivot 선택이 항상 최악일 경우)

- **공간 복잡도**: **O(log n)** (재귀 호출로 인한 스택 공간)

```javascript
function quickSort(arr, from = 0, to = arr.length - 1) {
    if (from >= to) return arr;
    
    const pivot = partition(arr, from, to);
    quickSort(arr, from, pivot - 1);
    quickSort(arr, pivot + 1, to);
    
    return arr;
}

function partition(arr, from, to) {
    const pivot = arr[to];
    let i = from - 1;
    
    for (let j = from; j < to; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    [arr[i + 1], arr[to]] = [arr[to], arr[i + 1]];
    return i + 1;
}

```


## 합병 정렬 (Merge Sort)

합병 정렬은 좋은 성능을 가진 알고리즘이지만 추가적인 메모리를 사용한다는 단점이 있습니다.

- **원리**:
   1. 배열을 반으로 나눕니다.
   2. 나눈 배열을 재귀를 통해 정렬합니다.
   3. 정렬된 배열을 합병하여 하나의 정렬된 배열로 만듭니다.

- **시간 복잡도**: **O(n log n)** (항상)
- **공간 복잡도**: **O(n)** (추가적인 배열 사용)

```javascript
function mergeSort(arr, from = 0, to = arr.length - 1) {
  if (from >= to) return arr;

  const mid = Math.floor((from + to) / 2);
  mergeSort(arr, from, mid);
  mergeSort(arr, mid + 1, to);
  merge(arr, from, mid, to);

  return arr;
}

function merge(arr, from, mid, to) {
  const left = arr.slice(from, mid + 1);
  const right = arr.slice(mid + 1, to + 1);

  let i = 0;
  let j = 0;
  let k = from;

  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      arr[k++] = left[i++];
    } else {
      arr[k++] = right[j++];
    }
  }

  while (i < left.length) {
    arr[k++] = left[i++];
  }

  while (j < right.length) {
    arr[k++] = right[j++];
  }
}
```


## 힙 정렬 (Heap Sort)

- **원리**: 최대 힙(또는 최소 힙)을 생성한 뒤, 루트 노드와 마지막 노드를 교환하며 정렬.
- **시간 복잡도**: **O(n log n)** (항상)
- **공간 복잡도**: **O(1)**

```javascript
function heapSort(arr) {
  function heapify(arr, n, i) {
    let largest = i;
    const left = 2 * i + 1;
    const right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest !== i) {
      [arr[i], arr[largest]] = [arr[largest], arr[i]];
      heapify(arr, n, largest);
    }
  }

  const n = arr.length;

  // 최대 힙 구성
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }

  // 요소를 하나씩 힙에서 추출
  for (let i = n - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]];
    heapify(arr, i, 0);
  }

  return arr;
}
```


## 정렬 알고리즘 비교

정렬은 문제 상황에 따라 선택적으로 사용할 수 있으며, 데이터 크기와 특성에 따라 효율적인 정렬 알고리즘을 선택하는 것이 중요합니다.

| 알고리즘  | 최선       | 평균       | 최악       | 안정성 | 공간 복잡도 |
| --- | ---- | ---- | ---- |  | ----- |
| 버블 정렬, 셔플 정렬 | O(n)       | O(n²)      | O(n²)      | 안정   | O(1)        |
| 선택 정렬 | O(n²) | O(n²) | O(n²) | 비안정 | O(1) |
| 삽입 정렬 | O(n)       | O(n²)      | O(n²)      | 안정   | O(1)        |
| 셸 정렬 | O(n log n) | 간격에 따라 다름 | n log² n [최선 간격], O(n²) [최악 간격] | 비안정 | O(1) |
| 퀵 정렬   | O(n log n) | O(n log n) | O(n²)      | 비안정 | O(log n)    |
| 합병 정렬 | O(n log n) | O(n log n) | O(n log n) | 안정   | O(n)        |
| 힙 정렬   | O(n log n) | O(n log n) | O(n log n) | 비안정 | O(1)        |


## 비트맵 정렬 (Bitmap Sort)

비트맵 정렬은 정수 정렬 알고리즘 중 하나로, 정수의 범위가 작을 때 사용할 수 있는 효율적인 정렬 방법입니다.

- **비교가 아닌 정렬**
- **제한 사항**:
  1. 숫자만 단독으로 정렬 가능합니다.
  2. 정렬할 정수의 범위를 알고 있어야 하며, 범위가 작아야 합니다.
  3. 정렬할 정수가 중복되지 않아야 합니다.
- **원리**:
  1. 정렬할 정수의 범위를 알고 있을 때, 해당 범위만큼의 비트 배열을 생성합니다.
  2. 정렬할 정수를 비트 배열의 인덱스로 사용하여 해당 인덱스의 비트를 1로 설정합니다.
  3. 비트 배열을 순회하며 1로 설정된 비트를 찾아 정렬된 배열에 추가합니다.
- **시간 복잡도**: **O(n)**
- **공간 복잡도**: **O(k)** (k: 정렬할 정수의 범위)


```javascript
// arr은 부울 배열
function bitmapSort(arr, from = 0, to = arr.length - 1) {
  const copied = arr.slice(from, to + 1);
  const minKey = Math.min(...copied);
  const maxKey = Math.max(...copied);

  const bitmap = new Array(maxKey - minKey + 1).fill(false);

  for (let i = from; i <= to; i++) {
    if (bitmap[arr[i] - minKey]) {
      throw new Error('입력 데이터에 중복된 값이 있습니다.');
    } else {
      bitmap[arr[i] - minKey] = true;
    }
  }

  let index = from;
  for (let i = 0; i < bitmap.length; i++) {
    if (bitmap[i]) {
      arr[index++] = i + minKey;
    }
  }

  return arr;
}
```


## 계수 정렬 (Counting Sort)

계수 정렬은 각 키가 몇 번 등장했는지 세어 정렬하는 방식의 정렬 알고리즘입니다.

- **비교가 아닌 정렬**
- **원리**:
  1. 정렬할 정수의 범위를 알고 있을 때, 해당 범위만큼의 배열을 생성합니다.
  2. 정렬할 정수를 배열의 인덱스로 사용하여 해당 인덱스의 값을 증가시킵니다.
  3. 배열을 순회하며 0이 아닌 인덱스를 찾아 정렬된 배열에 추가합니다.
- **시간 복잡도**: **O(n + k)** (n: 정렬할 데이터의 개수, k: 정렬할 정수의 범위)
- **공간 복잡도**: **O(k)** (k: 정렬할 정수의 범위)


```javascript
function countingSort(arr, from = 0, to = arr.length - 1) {
  const copied = arr.slice(from, to + 1);
  const minKey = Math.min(...copied);
  const maxKey = Math.max(...copied);

  const count = new Array(maxKey - minKey + 1).fill(0);

  for (let i = from; i <= to; i++) {
    count[arr[i] - minKey]++;
  }

  let index = from;
  for (let i = 0; i < count.length; i++) {
    while (count[i]-- > 0) {
      arr[index++] = i + minKey;
    }
  }

  return arr;
}
```


## 기수 정렬 (Radix Sort)

기수 정렬은 IBM의 Herman Hollerith가 개발한 정렬 알고리즘으로, 정수를 자릿수 별로 비교하여 정렬하는 방식입니다.

- **비교가 아닌 정렬**
- **원리**:
  1. 정렬할 정수의 자릿수를 기준으로 정렬합니다.
  2. 각 자릿수를 기준으로 정렬할 때는 안정 정렬을 사용합니다.
  3. 가장 낮은 자릿수부터 가장 높은 자릿수까지 반복하여 정렬합니다.
- **LSD 사용 시간 복잡도**: **O(n * d)** (n: 정렬할 데이터의 개수, d: 정수의 자릿수)
- **MSD 사용 시간 복잡도**: **O(n * log n)** (n: 정렬할 데이터의 개수)
- **공간 복잡도**: **O(n + k)** (n: 정렬할 데이터의 개수, k: 정렬할 정수의 범위)


```javascript
function radixSort(arr, from = 0, to = arr.length - 1) {
  const copied = arr.slice(from, to + 1);
  const maxKey = Math.max(...copied);
  const maxDigit = maxKey.toString().length;

  // 각 자릿수를 기준으로 정렬할 때는 안정 정렬을 사용해야 함
  for (let digit = 1; digit <= maxDigit; digit++) {
    countingSort(arr, from, to, digit);
  }

  return arr;
}
```
