---
title: SQL
description: 이 문서는 SQL(Structured Query Language)에 대해 다룹니다.
---

## SQL의 배경

1970년대 IBM의 Ted Codd가 제안한 관계형 데이터베이스 모델을 기반으로 1974년 IBM에서 개발한 SEQUEL(Structured English Query Language)이 SQL의 원조입니다. 이후 1986년 ANSI에서 SQL 표준을 제정하였고, 1987년 ISO에서 SQL 표준을 제정하였습니다.


## 테이블

은행에서 테이블 예시

Account 테이블

| account_number | first_name | last_name | balance |
|----------------|------------|-----------|---------|
| 1001           | Alice      | Smith     | 1000    |
| 1002           | Bob        | Jones     | 2000    |
| 1003           | Charlie    | Brown     | 3000    |

Transaction 테이블

| transaction_id | account_number | amount | transaction_date |
|----------------|----------------|--------|------------------|
| 1              | 1001           | 100    | 2021-01-01       |
| 2              | 1002           | 200    | 2021-01-02       |
| 3              | 1003           | 300    | 2021-01-03       |


## 주요 용어


| 용어 | 설명 |
|------|------|
| 엔티티(Entity) | 데이터베이스에서 사용자가 관심을 갖는 모든 요소 |
| 데이터베이스(Database) | 데이터를 체계적으로 저장하고 관리하는 공간 |
| 테이블(Table) | 행(Row)과 열(Column)로 구성된 데이터가 저장되는 기본 단위 |
| 스키마(Schema) | 데이터베이스의 구조(테이블, 컬럼, 데이터 타입, 제약 조건 등)를 정의 |
| 열(Column) | 테이블의 속성 |
| 행(Row) | 테이블의 레코드 |
| 키(Key) | 테이블에서 행을 식별하는 열 |
| 기본 키(Primary Key) | 테이블에서 각 행을 고유하게 식별하는 열 |
| 외래 키(Foreign Key) | 다른 테이블의 Primary Key를 참조하는 열 |
| 복합 키(Compound Key) | 두 개 이상의 열을 조합하여 Primary Key를 만드는 방법 |
| 자연 키(Natural Key) | 비즈니스에서 사용하는 실제 값 |
| 대리 키(Surrogate Key) | 데이터베이스에서 생성하는 인위적인 값 |
| 인덱스(Index) | 테이블의 검색 성능을 향상시키기 위해 사용하는 데이터베이스 객체 |
| 정규화(Normalization) | 중복을 최소화하고 데이터 무결성을 보장하기 위한 데이터베이스 설계 기법 |
| 데이터 딕셔너리(Data Dictionary) | 데이터베이스의 메타 데이터 정보를 저장하는 시스템 테이블 |
| DDL(Data Definition Language) | 데이터베이스 객체(테이블, 인덱스, 뷰 등)를 정의하는 언어 |
| DML(Data Manipulation Language) | 데이터베이스 객체(테이블, 인덱스, 뷰 등)를 조작하는 언어 |
| DCL(Data Control Language) | 데이터베이스 객체(테이블, 인덱스, 뷰 등)에 대한 접근 권한을 제어하는 언어 |
| TCL(Transaction Control Language) | 데이터베이스 트랜잭션을 제어하는 언어 |
| 트랜잭션(Transaction) | 데이터베이스에서 수행하는 작업의 단위 |
| 커밋(Commit) | 트랜잭션의 작업을 영구적으로 반영하는 명령 |
| 롤백(Rollback) | 트랜잭션의 작업을 취소하는 명령 |
| 저장 프로시저(Stored Procedure) | 데이터베이스에 저장된 SQL 코드 블록 |
| 트리거(Trigger) | 특정 이벤트가 발생하면 자동으로 실행되는 SQL 코드 블록 |
| 조인(Join) | 두 개 이상의 테이블을 연결하여 하나의 결과 집합으로 반환하는 연산 |
| 서브쿼리(Subquery) | 다른 SQL 문장 안에 포함된 SQL 문장 |
| 뷰(View) | 하나 이상의 테이블을 기반으로 생성된 가상 테이블 |
| 샤딩(Sharding) | 대용량 데이터베이스를 분할하여 저장하는 기술 |
| 파티셔닝(Partitioning) | 대용량 데이터베이스를 논리적 또는 물리적으로 분할하여 저장하는 기술 |


## PostgreSQL 소개

PostgreSQL은 관계형 데이터베이스 관리 시스템(RDBMS)의 하나로, 오픈 소스이며 ACID 트랜잭션을 지원합니다. PostgreSQL은 ANSI SQL 표준을 준수하며, 다양한 데이터 타입, 인덱스, 제약 조건, 함수, 트리거, 뷰, 저장 프로시저 등을 제공합니다.

PostgreSQL은 1970년대 IBM의 Ted Codd가 제안한 관계형 데이터베이스 모델을 기반으로 1986년 UC Berkeley에서 개발되었습니다. PostgreSQL은 1996년 PostgreSQL로 이름이 변경되었으며, 현재는 PostgreSQL Global Development Group이 개발하고 있습니다.


## PostgreSQL 데이터 유형


### 숫자형


#### 정수형

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `SMALLINT` | 작은 정수 | 2바이트 | -32768 ~ 32767 | 100 |
| `INTEGER` | 정수 | 4바이트 | -2,147,483,648 ~ 2,147,483,647 | 1234567 |
| `BIGINT` | 큰 정수 | 8바이트 | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 1234567890 |
| `SERIAL` | 자동 증가 정수 | 4바이트 | 1 ~ 2,147,483,647 | 1 |
| `BIGSERIAL` | 큰 자동 증가 정수 | 8바이트 | 1 ~ 9,223,372,036,854,775,807 | 1 |


#### 실수형

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `REAL` | 부동 소수점 | 4바이트 | 가변 | 123.45 |
| `DOUBLE PRECISION` | 더블 부동 소수점 | 8바이트 | 가변 | 123.45 |


#### 고정 소수점

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `DECIMAL` | 고정 소수점 | 가변 | 가변 | 123.45 |
| `NUMERIC` | 가변 소수점 | 가변 | 가변 | 123.45 |


### 화폐

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `MONEY` | 화폐 | 8바이트 | 가변 | $123.45 |


### 문자열

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `CHAR(n)` | 고정 길이 문자열 | n바이트 | 최대 255바이트 | `abc` |
| `VARCHAR(n)` | 가변 길이 문자열 | 최대 n바이트 | 최대 65535바이트 | `abc` |
| `TEXT` | 가변 길이 문자열 | 가변 | 가변 | `abc` |


### 이진 데이터

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `BYTEA` | 이진 데이터 | 가변 | 가변 | 0x010203 |


### 날짜 및 시간

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `DATE` | 날짜 | 4바이트 | 4713 BC ~ 294276 AD | `2021-01-01` |
| `TIME` | 시간 | 8바이트 | 00:00:00 ~ 23:59:59 | `12:34:56` |
| `TIME WITH TIME ZONE` | 타임존을 고려한 시간 | 8바이트 | 00:00:00 ~ 23:59:59 | `12:34:56+09` |
| `TIMESTAMP` | 날짜 및 시간 | 8바이트 | 4713 BC ~ 294276 AD | `2021-01-01 12:34:56` |
| `TIMESTAMP WITH TIME ZONE` | 타임존을 고려한 날짜 및 시간 | 8바이트 | 4713 BC ~ 294276 AD | `2021-01-01 12:34:56+09` |
| `INTERVAL` | 시간 간격 | 12바이트 | 가변 | `1 day 2 hours 3 minutes 4 seconds` |


### 불리언

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `BOOLEAN` | 불리언 | 1바이트 | `TRUE`, `FALSE`, `NULL` | `TRUE` |


### 열거형

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `ENUM` | 열거형 | 4바이트 | 열거형 값 | `A` |


### 지오메트리

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `POINT` | 점 | 16바이트 | 가변 | `(1, 2)` |
| `LINE` | 선 | 16바이트 | 가변 | `{1, 2}, {3, 4}` |
| `LSEG` | 선분 | 32바이트 | 가변 | `[(1, 2), (3, 4)]` |
| `BOX` | 박스 | 32바이트 | 가변 | `(1, 2), (3, 4)` |
| `PATH` | 닫힌 경로 | 16바이트 | 가변 | `((1, 2), (3, 4))` |
| `PATH` | 열린 경로 | 16바이트 | 가변 | `[(1, 2), (3, 4)]` |
| `POLYGON` | 다각형 | 40바이트 | 가변 | `((1, 2), (3, 4), (5, 6))` |
| `CIRCLE` | 원 | 24바이트 | 가변 | `<(1, 2), 3>` |


### 네트워크 주소

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `CIDR` | CIDR 주소 | 7바이트 | 가변 | IPv4, IPv6 네트워크 |
| `INET` | IP 주소 | 7바이트 | 가변 | IPv4, IPv6 호스트와 네트워크 주소 |
| `MACADDR` | MAC 주소 | 6바이트 | 가변 | MAC 주소 |
| `MACADDR8` | MAC 주소 | 8바이트 | 가변 | MAC 주소(IEEE EUI-64) |


### 이진 문자열

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `BIT(n)` | 비트 문자열 | n바이트 | 가변 | B`1010` |


### 텍스트 검색

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `TSVECTOR` | 텍스트 검색 | 가변 | 가변 | `The quick brown fox` |
| `TSQUERY` | 텍스트 검색 | 가변 | 가변 | `quick & (brown | fox)` |


### UUID

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `UUID` | UUID | 16바이트 | 가변 | `a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11` |


### XML

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `XML` | XML | 가변 | 가변 | `<book><title>Harry Potter</title></book>` |


### JSON

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `JSON` | JSON | 가변 | 가변 | `{"title": "Harry Potter"}` |
| `JSONB` | JSONB | 가변 | 가변 | `{"title": "Harry Potter"}` |


### 배열

| 데이터 유형 | 설명 | 저장 크기 | 범위 | 예시 |
|------------|------|----------|------|------|
| `ARRAY` | 배열 | 가변 | 가변 | `{1, 2, 3}` |
| `INT[]` | 정수 배열 | 가변 | 가변 | `{1, 2, 3}` |
| `TEXT[]` | 문자열 배열 | 가변 | 가변 | `{"a", "b", "c"}` |
| `JSON[]` | JSON 배열 | 가변 | 가변 | `{"a": 1, "b": 2}` |
| `INT[][]` | 2차원 정수 배열 | 가변 | 가변 | `{{1, 2}, {3, 4}}` |
| `TEXT[][]` | 2차원 문자열 배열 | 가변 | 가변 | `{{"a", "b"}, {"c", "d"}}` |
| `JSON[][]` | 2차원 JSON 배열 | 가변 | 가변 | `{{{"a": 1}, {"b": 2}}, {{"c": 3}, {"d": 4}}}` |


## 테이블 조작하기


### 1. 포함할 정보 정의하기

테이블을 생성하는 첫 단계는 브레인 스토밍을 통해 포함할 정보를 정의하는 것입니다. 예를 들어, 은행에서 계좌 정보를 저장하는 테이블을 생성한다고 가정해보겠습니다. 계좌 정보에는 계좌 번호, 이름, 잔액이 포함될 수 있습니다.

- 계좌 번호(account_number)
- 이름(name)
- 성별(gender)
- 잔액(balance)
- 생성일(created_at)


### 2. 적절한 자료형 선택하기

포함할 정보를 정의한 후에는 각 정보에 적절한 데이터베이스의 자료형을 선택해야 합니다. 예를 들어, 계좌 번호는 정수형으로, 이름은 문자열로, 잔액은 실수형으로 저장할 수 있습니다.

- 계좌 번호(account_number): `INTEGER`
- 이름(name): `VARCHAR(255)`
- 성별(gender): `CHAR(1)`
- 잔액(balance): `DECIMAL(10, 2)`
- 생성일(created_at): `TIMESTAMP`


### 3. 데이터 정제

테이블을 생성하기 전에 정규화를 통해 중복을 최소화하고 데이터 무결성을 보장할 수 있도록 테이블을 정제해야 합니다. 예를 들어, 계좌 정보를 저장하는 테이블을 생성한다고 가정해보겠습니다. 계좌 정보에서 계좌 번호는 각 계좌를 식별하는 기본 키로 설정할 수 있습니다. 또한, 계좌 번호는 중복되지 않아야 하며, NULL 값을 허용하지 않아야 합니다. 이름은 NULL 값을 허용하지 않아야 하며, 잔액은 음수 값을 허용하지 않아야 합니다.

- 계좌 번호(account_number): 고유하며, NULL 값을 허용하지 않음
- 이름(name): NULL 값을 허용하지 않음
- 성별(gender): NULL 값을 허용하지 않고, `M` 또는 `F` 값만 허용
- 잔액(balance): 음수 값을 허용하지 않음
- 생성일(created_at): NULL 값을 허용하지 않음


### 4. 테이블 생성 SQL 작성하기

데이터베이스에 테이블을 생성하기 위해 SQL 문을 작성해야 합니다. PostgreSQL에서 테이블을 생성하는 SQL 구문은 다음과 같은 형식을 가집니다.


- IF NOT EXISTS: 테이블이 존재하지 않을 때에만 테이블을 생성합니다.
- table_name: 테이블의 이름을 지정합니다.
- column_name: 열의 이름을 지정합니다.
- column_type: 열의 데이터 유형을 지정합니다.
- column_constraints: 열의 제약 조건을 지정합니다.
- table_constraints: 테이블의 제약 조건을 지정합니다.

```sql
CREATE TABLE [IF NOT EXISTS] table_name (
    column1_name column1_type [column1_constraints],
    column2_name column2_type [column2_constraints],
    ...
    [table_constraints]
);
```

위의 구문에 따라 계좌 정보를 저장하는 테이블을 생성하는 SQL 문은 다음과 같이 작성할 수 있습니다.

```sql
CREATE TABLE IF NOT EXISTS account (
    account_number INTEGER PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    gender CHAR(1) NOT NULL CHECK (gender IN (`M`, `F`)),
    balance DECIMAL(10, 2) NOT NULL CHECK (balance >= 0),
    created_at TIMESTAMP NOT NULL
);
```


### 5. 테이블에 데이터 삽입하기

테이블을 생성한 후에는 `INSERT INTO...VALUES 문`을 사용하여 테이블에 데이터를 삽입할 수 있습니다. PostgreSQL에서 데이터를 삽입하는 SQL 구문은 다음과 같은 형식을 가집니다.

```sql
INSERT INTO table_name (column1_name, column2_name, ...)
VALUES (value1, value2, ...);
```

위의 구문에 따라 계좌 정보를 저장하는 테이블에 데이터를 삽입하는 SQL 문은 다음과 같이 작성할 수 있습니다.

```sql
INSERT INTO account (account_number, name, gender, balance, created_at)
VALUES 
(1001, `Alice`, `F`, 1000.00, `2025-01-01 10:00:00`),
(1002, `Bob`, `M`, 2000.00, `2025-01-02 11:00:00`),
(1003, `Charlie`, `M`, 3000.00, `2025-01-03 12:00:00`);
```


### 6. 테이블의 데이터 조회하기

테이블에 저장된 데이터를 조회하기 위해 `SELECT 문`을 사용할 수 있습니다. PostgreSQL에서 데이터를 조회하는 SQL 구문은 다음과 같은 형식을 가집니다.

- DISTINCT: 중복된 행을 제거합니다.
- ORDER BY: 결과를 정렬합니다.
- GROUP BY: 결과를 그룹화합니다.
- HAVING: 그룹화된 결과에 조건을 지정합니다.
- WHERE: 조건을 지정하여 특정 행을 조회합니다.
- LIMIT: 결과의 행 수를 제한합니다.
- OFFSET: 결과의 시작 위치를 지정합니다.
- INNER JOIN: 두 개 이상의 테이블을 조인합니다.
- LEFT JOIN: 왼쪽 테이블을 기준으로 오른쪽 테이블을 조인합니다.
- RIGHT JOIN: 오른쪽 테이블을 기준으로 왼쪽 테이블을 조인합니다.
- FULL JOIN: 왼쪽과 오른쪽 테이블을 모두 포함하는 조인을 수행합니다.
- CROSS JOIN: 두 개 이상의 테이블의 모든 조합을 생성합니다.
- UNION: 두 개 이상의 결과 집합을 합칩니다.
- INTERSECT: 두 개 이상의 결과 집합의 교집합을 반환합니다.
- EXCEPT: 첫 번째 결과 집합에서 두 번째 결과 집합을 제외한 결과를 반환합니다.


```sql
SELECT column1_name, column2_name, ...
FROM table_name
[WHERE condition]
[ORDER BY column_name [ASC | DESC]]
[LIMIT number]
[OFFSET number];
```

위의 구문에 따라 계좌 정보를 저장하는 테이블에서 데이터를 조회하는 SQL 문은 다음과 같이 작성할 수 있습니다.

```sql
SELECT * FROM account;
```


### 7. 테이블의 데이터 수정하기

테이블에 저장된 데이터를 수정하기 위해 `UPDATE 문`을 사용할 수 있습니다. PostgreSQL에서 데이터를 수정하는 SQL 구문은 다음과 같은 형식을 가집니다.


```sql
UPDATE table_name
SET column1_name = value1, column2_name = value2, ...
[WHERE condition];
```

위의 구문에 따라 계좌 정보를 저장하는 테이블에서 데이터를 수정하는 SQL 문은 다음과 같이 작성할 수 있습니다.

```sql
UPDATE account
SET balance = 1500.00
WHERE account_number = 1001;
```


### 8. 테이블의 데이터 삭제하기

테이블에 저장된 데이터를 삭제하기 위해 `DELETE 문`을 사용할 수 있습니다. PostgreSQL에서 데이터를 삭제하는 SQL 구문은 다음과 같은 형식을 가집니다.

```sql
DELETE FROM table_name
[WHERE condition];
```

위의 구문에 따라 계좌 정보를 저장하는 테이블에서 데이터를 삭제하는 SQL 문은 다음과 같이 작성할 수 있습니다.

```sql
DELETE FROM account
WHERE account_number = 1001;
```
