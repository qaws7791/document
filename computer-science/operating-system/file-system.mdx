# 파일 시스템(File System)

- 파일 시스템은 **운영체제의 핵심 구성 요소 중 하나**
- 데이터를 디스크와 같은 저장 장치에 효율적으로 저장하고, 이를 관리
- 파일 시스템이라는 단어는 종이 문서를 정리하고 저장, 검색하는 방법에서 기원
- 사용자와 애플리케이션이 파일을 접근할 수 있도록 지원
- 파일 시스템은 저장 장치를 추상화하여 데이터를 파일과 디렉토리 구조로 관리
- 데이터 저장, 검색, 보호 등의 기능을 제공


## 파일 시스템의 주요 역할

1. **데이터 저장 및 관리**
   - 저장 장치에 데이터를 파일로 저장하고, 데이터를 체계적으로 정리하여 효율적인 관리와 접근성을 보장.
2. **사용자 인터페이스 제공**
   - 사용자가 파일을 읽거나 쓰는 작업을 쉽게 수행할 수 있도록 명령어(`open`, `read`, `write`, `delete`)와 인터페이스 제공.
3. **데이터 무결성 보장**
   - 저장된 데이터가 손상되지 않도록 보호하며, 갑작스러운 시스템 오류에도 데이터를 복구할 수 있는 기능 제공.
4. **데이터 보안 및 접근 제어**
   - 파일의 읽기, 쓰기, 실행 권한을 관리하여 데이터에 대한 불법적 접근을 방지.
5. **효율적인 공간 관리**
   - 저장 장치의 공간을 최적화하고, 파일의 크기가 동적으로 증가하거나 감소할 때 효율적으로 처리.


## 파일 시스템 설계 시 고려 사항

1. **효율성:**
   - 디스크 공간과 데이터 접근 속도를 최적화.
2. **확장성:**
   - 파일 시스템이 대용량 저장 장치를 지원하도록 설계.
3. **안정성:**
   - 데이터 손실을 방지하고, 오류 발생 시 복구 가능.
4. **보안:**
   - 데이터 보호를 위한 접근 제어 및 암호화 기능.
5. **호환성:**
   - 다양한 운영체제 및 애플리케이션과 호환 가능.


## 파일 시스템의 구성 요소


### 파일(File)

파일은 데이터를 저장하는 기본 단위로, 텍스트, 이미지, 비디오 등 다양한 형태를 가질 수 있습니다. 파일의 주요 속성은 다음과 같습니다:

- **파일 이름(File Name):** 사용자가 파일을 식별할 수 있는 고유 이름.
- **파일 크기(Size):** 파일이 차지하는 저장 공간의 크기.
- **파일 유형(Type):** 텍스트 파일, 바이너리 파일, 실행 파일 등.
- **파일 위치(Location):** 파일이 저장된 디스크의 주소.
- **파일 보호(Protection):** 파일의 접근 권한 정보.


### 디렉토리(Directory)

디렉토리는 파일을 체계적으로 관리하기 위한 구조입니다. 디렉토리는 파일과 다른 디렉토리를 포함할 수 있으며, 트리 형태로 조직됩니다.


##### 디렉토리 구조의 유형

1. **단일 수준 디렉토리(Single-Level Directory):**
   - 모든 파일이 하나의 디렉토리에 저장되는 평면적 구조.
   - 구조가 단순하지만, 파일 이름 충돌 문제가 발생할 수 있음.
2. **2단계 디렉토리(Two-Level Directory):**
   - 사용자별로 개별 디렉토리를 제공.
   - 사용자 간 파일 이름 충돌 문제를 해결.
3. **계층적 디렉토리(Hierarchical Directory):**
   - 트리 구조를 가지며, 파일과 디렉토리를 재귀적으로 포함.
   - 대부분의 현대 운영체제에서 사용.
4. **그래프 디렉토리(Acyclic Graph Directory):**
   - 파일이나 디렉토리에 여러 경로로 접근 가능.
   - 심볼릭 링크나 하드 링크를 지원.


### 메타데이터(Metadata)

메타데이터는 파일이나 디렉토리와 관련된 정보를 파일 내용과 별도로 저장한다.

- 파일 이름
- 파일 크기
- 파일 유형
- 생성일, 수정 시간, 마지막 접근일, 마지막 백업일
- 소유 사용자 및 그룹
- 접근 권한
- 읽기 전용, 실행 가능 여부 등의 파일 속성
- 장치 유형


## 파일 시스템의 주요 기능

1. **파일 생성 및 삭제**

   - **파일 생성(Create):** 디스크의 빈 공간에 파일을 저장하고, 파일 메타데이터와 디렉토리 항목을 갱신.
   - **파일 삭제(Delete):** 파일의 메타데이터와 디렉토리 항목을 제거하고, 디스크 공간을 해제.

2. **파일 읽기 및 쓰기**

   - **파일 읽기(Read):** 디스크에서 데이터를 메모리로 복사.
   - **파일 쓰기(Write):** 메모리 데이터를 디스크로 저장.

3. **파일 보호**
   - 사용자 및 그룹별 파일 접근 권한 설정.
   - 읽기(Read), 쓰기(Write), 실행(Execute) 권한.
   - UNIX 파일 시스템 예: `rwxr--r--`.
4. **파일 이름 관리**
   - 사용자가 이해하기 쉽도록 파일 이름과 디렉토리 구조 제공.
5. **저장 공간 할당**
   - 운영체제는 파일이 저장될 디스크 블록을 효율적으로 할당
   - 파일 시스템은 파티션을 블록으로 나눈다. 블록의 크기는 파일 시스템에 따라 다름.
   - 대부분의 블록은 파일 내용을 저장하기 위해 사용
   - 나머지 블록은 파일의 메타데이터나 파일 시스템 및 운영체제 관리를 위한 데이터로 사용
6. **파일 검색 및 정렬**
   - 파일 검색 알고리즘과 디렉토리 구조를 통해 빠르게 파일을 찾을 수 있도록 지원.


## 파일 시스템의 데이터 저장 방식


### 연속 할당(Contiguous Allocation)

- 파일 데이터를 디스크의 연속된 블록에 저장.
- **장점:** 빠른 데이터 접근.
- **단점:** 파일 크기가 증가할 경우, 공간 재할당이 필요.


### 연결 할당(Linked Allocation)

- 파일 데이터를 서로 연결된 디스크 블록에 저장.
- **장점:** 파일 크기 증가 시 유연성.
- **단점:** 랜덤 접근이 느림.


### 인덱스 할당(Indexed Allocation)

- 파일 데이터의 위치를 가리키는 인덱스 블록을 사용.
- **장점:** 랜덤 접근과 파일 크기 관리가 용이.
- **단점:** 추가적인 인덱스 블록이 필요.


## 파일 시스템의 주요 알고리즘 및 기술


### 디스크 스케줄링

- 여러 I/O 요청을 효율적으로 처리하기 위해 디스크 스케줄링 알고리즘을 사용.
  - FCFS, SSTF, SCAN, C-SCAN 등.


### 버퍼 캐싱(Buffer Caching)

- 파일 데이터를 캐시에 저장하여 디스크 접근을 줄이고, I/O 성능 향상.


### 저널링(Journaling)

- 파일 시스템의 데이터 무결성을 보장하기 위해 변경 내용을 로그 파일에 기록.
- 시스템 충돌 시 데이터를 복구 가능.


### RAID(Redundant Array of Independent Disks)

- 여러 디스크를 조합하여 데이터 복원력과 성능을 향상.


## 파일 시스템의 종류


### FAT(File Allocation Table)

- 초기 파일 시스템으로 MS-DOS 및 초기 Windows에서 사용.
- 간단하지만 대용량 디스크에서 비효율적.


### NTFS(New Technology File System)

- Windows의 기본 파일 시스템에서 사용
- 보안, 압축, 저널링 등 고급 기능 제공.


### ext(Extended File System)

- 리눅스 및 유닉스 기반 파일 시스템에서 사용
  - **ext2:** 저널링 미지원.
  - **ext3:** 저널링 지원.
  - **ext4:** ext3의 확장판으로, 성능과 안정성 강화.


### HFS(Apple Hierarchical FileSystem)

- Apple에서 MacOS를 위해 개발한 독점 파일 시스템


### APFS(Apple File System)

- macOS 및 iOS의 파일 시스템.
- SSD 최적화, 스냅샷, 암호화 기능 지원.


### HDFS(Hadoop Distributed File System)

- 빅데이터 처리를 위해 설계된 분산 파일 시스템.
- 대규모 데이터를 효율적으로 관리.


## **리눅스 파일 시스템 아키텍처**

- 리눅스의 파일 시스템 아키텍처는 데이터를 효율적으로 저장, 관리, 검색, 보호하기 위해 계층화된 구조로 설계
- 리눅스 파일 시스템은 유닉스 철학을 기반
- 다양한 파일 시스템을 지원합니다(예: ext4, XFS, Btrfs, ZFS)


### 리눅스 파일 시스템의 특징

1. **계층적 디렉토리 구조**:
   - 루트 디렉토리 `/`를 기준으로 모든 파일과 디렉토리가 트리 구조로 구성됩니다.
   - 모든 저장 장치와 디바이스 파일이 `/` 하위에 마운트됩니다.
2. **모듈식 설계**:
   - **VFS(Virtual File System)**를 통해 다양한 파일 시스템을 추상화.
   - 하드웨어 독립적인 동작을 보장.
3. **파일 접근 권한 및 보안**:
   - 소유자, 그룹, 기타 사용자에 대한 권한 설정.
   - ACL(Access Control List) 및 SELinux와 같은 보안 확장 지원.


### 리눅스 파일 시스템 아키텍처 계층


#### 애플리케이션 계층

- **역할**:
  - 사용자가 파일을 생성, 읽기, 쓰기, 삭제하는 데 필요한 인터페이스를 제공합니다.
  - 파일 시스템과의 상호작용은 POSIX 인터페이스를 통해 이루어집니다.
- **주요 인터페이스**:
  - 시스템 호출: `open()`, `read()`, `write()`, `close()` 등.
  - 쉘 명령: `ls`, `cp`, `mv`, `rm`, `mkdir` 등.


#### 가상 파일 시스템 (Virtual File System, VFS)

- **역할**:
  - 다양한 파일 시스템을 추상화하여 일관된 인터페이스를 제공.
  - ext4, XFS, Btrfs와 같은 서로 다른 파일 시스템을 단일 인터페이스로 통합.
- **구성 요소**:
  - **슈퍼블록 (Superblock)**: 파일 시스템 메타데이터를 관리.
  - **인덱스 노드 (Inode)**: 파일 및 디렉토리의 메타데이터를 저장.
  - **디렉토리 엔트리 (Directory Entry)**: 파일 이름과 inode 번호를 연결.
  - **파일 객체 (File Object)**: 열린 파일에 대한 상태 정보를 관리.
- **작동 원리**:
  1. 애플리케이션이 파일에 접근하면 VFS가 해당 요청을 처리.
  2. 요청을 하위 파일 시스템으로 전달.
  3. 각 파일 시스템의 드라이버가 요청을 디스크로 전달.


#### 파일 시스템 드라이버 계층

- **역할**:

  - 특정 파일 시스템(ext4, XFS 등)의 로직을 구현.
  - 데이터 저장 방식, 메타데이터 구조, 오류 복구 메커니즘 등을 처리.

- **예시**:

  - ext4

    - 표준 리눅스 파일 시스템으로 높은 안정성과 성능 제공.

  - XFS

    - 대용량 데이터와 병렬 처리를 지원하는 저널링 파일 시스템.

  - Btrfs

    - 스냅샷, RAID 지원, 데이터 무결성 보장을 위한 고급 파일 시스템.


#### 버퍼 캐시 및 페이지 캐시 계층

- **역할**:
  - 디스크 I/O 성능을 향상시키기 위해 파일 데이터를 메모리에 캐싱.
  - 읽기/쓰기 작업을 디스크에 직접 수행하지 않고 메모리를 통해 처리.
- **주요 캐싱 메커니즘**:
  - **페이지 캐시**: 파일 데이터를 메모리에 저장하여 읽기 성능 최적화.
  - **버퍼 캐시**: 디스크 블록에 대한 메타데이터(슈퍼블록, inode 등)를 저장.


#### 블록 I/O 계층 (Block I/O Layer)

- **역할**:
  - 파일 시스템의 논리적 데이터 요청을 물리적 디스크 요청으로 변환.
  - 블록 디바이스 드라이버와 협력하여 데이터를 읽거나 씀.
- **주요 작업**:
  - 요청 스케줄링: 디스크 접근 최적화를 위해 I/O 요청 정렬.
  - 데이터 전송: 데이터를 저장 장치로 전송.
- **I/O 스케줄러**:
  - CFQ(Completely Fair Queuing): 각 프로세스에 공평하게 I/O 대역폭 할당.
  - NOOP: 단순 FIFO 기반 스케줄링.


#### 블록 디바이스 계층

- **역할**:
  - 하드웨어와 파일 시스템 간의 인터페이스 역할.
  - 데이터의 물리적 저장을 담당.
- **디스크 드라이버**:
  - 디스크의 저수준 작업을 처리.
  - SATA, NVMe, USB 드라이버 등을 포함.
- **물리적 디스크**:
  - HDD, SSD, RAID 디스크 등.


### 리눅스 파일 시스템의 데이터 구조


#### 슈퍼블록 (Superblock)

- 파일 시스템의 전반적인 정보를 포함.
- 파일 시스템의 유형과 크기, 총 블록 수와 사용 가능한 블록 수, inode 수와 정보 등을 저장.


#### 인덱스 노드 (Inode)

- inode는 고유 번호로 식별되며 파일 및 디렉토리의 메타데이터를 저장.
- 메타데이터 정보:
  - 파일 소유자 및 그룹.
  - 파일 크기.
  - 파일 유형(일반 파일, 디렉토리, 장치 파일 등).
  - 마지막 수정 및 접근 시간.
  - 데이터 블록 포인터.


#### 데이터 블록 (Data Block)

- 파일의 실제 데이터가 저장되는 공간으로 파일의 점유된 블록의 대부분을 차지
- 파일 시스템에 따라 크기가 달라질 수 있음(4KB 등).


#### 저널링 (Journaling)

- 데이터 무결성을 보장하기 위해 변경 사항을 로그에 기록.
- 시스템 장애 시 파일 시스템을 복구 가능.


### 리눅스 파일 시스템 종류

- **ext4**
  - 가장 널리 사용되는 리눅스 파일 시스템.
  - 대용량 파일과 볼륨 지원.
  - 저널링 및 파일 단편화 방지.
- **XFS**
  - 고성능 파일 시스템으로 대규모 데이터 처리에 적합.
  - 병렬 데이터 처리 및 저널링 지원.
- **Btrfs**
  - 고급 기능(Snapshot, RAID, 데이터 무결성) 제공.
  - 데이터 압축 및 자동 복구 지원.
- **ZFS**
  - 데이터 무결성과 스냅샷, 복제를 중점으로 설계된 파일 시스템.
  - 강력한 RAID 지원.


### 리눅스 파일 시스템의 주요 동작

1. **마운트 (Mount)**
   - 파일 시스템을 특정 디렉토리 경로에 연결.
   - 명령: `mount /dev/sda1 /mnt`
2. **읽기/쓰기 작업**
   - 데이터가 요청되면 페이지 캐시를 먼저 확인.
   - 페이지 캐시에 데이터가 없으면 디스크에서 읽기.
3. **파일 삭제**
   - 파일의 데이터 블록을 비우고 inode를 해제.
   - 디렉토리 엔트리에서 해당 파일 이름 제거.


### 리눅스 파일 시스템의 성능 최적화

1. **디스크 캐싱**:
   - 파일 데이터를 메모리에 저장하여 I/O 속도 개선.
2. **디스크 조각 모음 방지**:
   - ext4 등은 조각화를 최소화하는 설계.
3. **I/O 스케줄러 최적화**:
   - 사용 환경에 따라 스케줄러(CFQ, NOOP 등) 선택.
4. **파일 시스템 튜닝**:
   - 마운트 옵션 변경(예: `noatime`, `data=writeback` 등).
