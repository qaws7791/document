---
title: "8. Dockerfile로 이미지 빌드하기"
description: "이 문서에서는 Dockerfile을 사용하여 이미지를 빌드하는 방법과 빌드 과정에서의 레이어 개념, 빌드 캐시 활용법 등을 배웁니다."
---

## 8.1 `docker build` 명령어 사용법

`Dockerfile`로부터 Docker 이미지를 생성하는 명령어는 `docker build`입니다. 기본적인 사용 형식은 다음과 같습니다.

```bash
docker build [OPTIONS] PATH | URL | -
```

* **`PATH | URL | -`**: 이 부분이 바로 **빌드 컨텍스트(Build Context)** 를 지정하는 경로입니다.
  * **빌드 컨텍스트란?** `docker build` 명령이 실행될 때 Docker 데몬이 이미지 빌드 과정에서 접근할 수 있는 파일 및 디렉토리들의 집합입니다. 사용자가 지정한 `PATH`에 있는 모든 내용(하위 디렉토리 포함)이 빌드 시작 전에 Docker 데몬으로 전송됩니다. `Dockerfile` 내의 `COPY`나 `ADD` 명령어는 이 빌드 컨텍스트 내의 파일만 참조할 수 있습니다.
  * 일반적으로 `Dockerfile`이 위치한 디렉토리를 빌드 컨텍스트로 지정합니다. 현재 디렉토리를 빌드 컨텍스트로 사용하려면 `.` (점)을 사용합니다.
  * **중요:** 빌드 컨텍스트에는 이미지 빌드에 필요한 파일만 포함하는 것이 좋습니다. 불필요한 파일(예: `.git` 폴더, 로컬 의존성 폴더 `node_modules`, 로그 파일, 임시 파일 등)이 포함되면 빌드 컨텍스트 크기가 커져 Docker 데몬으로 전송하는 시간이 길어지고 빌드 속도가 느려질 수 있습니다. (`.dockerignore` 파일로 제외 가능, 후술)
  * `URL`을 지정하면 Git 리포지토리 주소를 빌드 컨텍스트로 사용할 수도 있습니다. `-`를 사용하면 표준 입력(STDIN)으로부터 `Dockerfile` 또는 빌드 컨텍스트(tar 아카이브)를 파이프라이닝할 수 있습니다 (고급 사용법).
* **`[OPTIONS]`**: 빌드 과정을 제어하는 다양한 옵션들을 지정합니다.


### 8.1.1 이미지 이름 및 태그 지정 (`-t` 옵션)

빌드된 이미지에 사람이 식별하기 쉬운 이름과 태그(버전 정보 등)를 부여하는 것은 이미지를 관리하고 사용하는 데 매우 중요합니다. 이때 `-t` (또는 `--tag`) 옵션을 사용합니다.

**형식:** `-t <저장소 이름>[:<태그>]`

* `<저장소 이름>`: 이미지의 이름입니다. 나중에 Docker Hub 등에 푸시(push)하려면 보통 `<사용자명>/<이미지명>` 형식을 사용합니다.
* `[:<태그>]`: 이미지의 버전이나 종류를 나타내는 태그입니다. 생략하면 기본값으로 `latest`가 사용됩니다.

**예시:** 이전 챕터에서 작성한 `Dockerfile`이 있는 디렉토리에서 다음 명령어를 실행하면, 현재 디렉토리(`.`)를 빌드 컨텍스트로 사용하여 이미지를 빌드하고 `hello-node`라는 이름과 `0.1`이라는 태그를 부여합니다.

```bash
# 현재 디렉토리의 Dockerfile을 사용하여 이미지를 빌드하고 태그 지정
docker build -t hello-node:0.1 .
```

하나의 이미지에 여러 개의 태그를 동시에 부여할 수도 있습니다. `-t` 옵션을 여러 번 사용하면 됩니다.

```bash
docker build -t hello-node:0.1 -t hello-node:latest .
```


### 8.1.2 Dockerfile 경로 지정 (`-f` 옵션)

기본적으로 `docker build` 명령어는 빌드 컨텍스트의 최상위 디렉토리에서 `Dockerfile`이라는 이름의 파일을 찾습니다. 만약 다른 이름의 Dockerfile을 사용하거나 다른 경로에 있는 Dockerfile을 사용하고 싶다면 `-f` (또는 `--file`) 옵션으로 해당 파일의 경로를 명시적으로 지정해야 합니다.

**형식:** `-f /path/to/your/Dockerfile`

**예시:** 개발 환경용 Dockerfile(`Dockerfile.dev`)과 운영 환경용 Dockerfile(`Dockerfile.prod`)을 따로 관리하는 경우 유용합니다.

```bash
# 현재 디렉토리의 Dockerfile.dev 파일을 사용하여 빌드
docker build -t my-app:dev -f Dockerfile.dev .

# 현재 디렉토리의 Dockerfile.prod 파일을 사용하여 빌드
docker build -t my-app:prod -f Dockerfile.prod .
```


## 8.2 빌드 과정 이해하기 (레이어 개념)

`docker build` 명령어를 실행하면 어떤 일이 일어날까요? Docker 데몬은 `Dockerfile`의 명령어들을 위에서부터 아래로 하나씩 처리하며 다음과 같은 과정을 거칩니다.

1. **빌드 컨텍스트 전송:** Docker 클라이언트는 지정된 빌드 컨텍스트(`PATH`)의 모든 내용을 압축하여 Docker 데몬으로 전송합니다.
2. **명령어 실행 및 레이어 생성:** Docker 데몬은 `Dockerfile`의 각 명령어(`FROM`, `RUN`, `COPY`, `ADD` 등)를 순서대로 실행합니다. 대부분의 명령어는 실행 결과로 **새로운 이미지 레이어(Layer)** 를 생성합니다.
3. **레이어란?** 각 레이어는 이전 레이어에서 변경된 내용만을 담고 있는 읽기 전용 파일 시스템 스냅샷과 같습니다. 예를 들어, `RUN apt-get install nginx` 명령어는 이전 레이어 상태에서 Nginx 패키지가 설치된 변경 사항만을 포함하는 새로운 레이어를 만듭니다.
4. **레이어 스태킹:** 이렇게 생성된 레이어들은 `FROM` 명령어로 지정된 베이스 이미지의 레이어들 위에 차곡차곡 쌓여 최종적인 이미지를 구성합니다.
5. **최종 이미지:** 모든 명령어가 성공적으로 실행되면, 마지막 레이어를 가리키는 최종 이미지가 생성되고, `-t` 옵션으로 지정한 이름과 태그가 이 이미지에 부여됩니다.

**비유:** 이미지 레이어는 투명한 필름(오버레이)과 같습니다. 베이스 이미지라는 밑그림 위에 각 명령어 실행 결과를 투명 필름에 그려 한 장씩 덧씌워 최종 그림(이미지)을 완성하는 것과 유사합니다. 또는, Git과 같은 버전 관리 시스템에서 각 커밋(Commit)이 이전 상태로부터의 변경 사항을 저장하는 것과도 비슷합니다.

이러한 레이어 구조는 Docker 이미지의 중요한 특징이며, 효율적인 저장 공간 활용과 **빌드 캐시**의 기반이 됩니다.


## 8.3 빌드 캐시(Build Cache) 활용하기

Docker 이미지를 처음 빌드할 때는 모든 명령어를 실행해야 하므로 시간이 다소 걸릴 수 있습니다. 하지만 동일한 `Dockerfile`과 빌드 컨텍스트로 다시 빌드를 실행하면 Docker는 매우 빠르게 빌드를 완료할 수 있습니다. 이는 **빌드 캐시(Build Cache)** 덕분입니다.

**빌드 캐시 작동 원리:**

1. `docker build` 실행 시, Docker 데몬은 `Dockerfile`의 각 명령어를 실행하기 전에 먼저 캐시를 확인합니다.
2. **캐시 히트(Cache Hit):** 만약 현재 명령어와 동일한 명령어이고, 그 명령어가 기반하는 부모 레이어(이전 명령어의 결과 레이어)가 동일한 결과로 이전에 빌드된 레이어가 캐시에 존재한다면, Docker는 해당 명령어를 다시 실행하는 대신 캐시에 저장된 기존 레이어를 **재사용**합니다. 터미널 출력에 `---> Using cache` 와 같이 표시됩니다.
3. **캐시 미스(Cache Miss):** 만약 캐시에 해당되는 레이어가 없거나(처음 실행하는 명령어), 명령어가 변경되었거나, 또는 명령어 실행에 영향을 미치는 파일(예: `COPY` 명령어의 원본 파일)이 변경되었다면 캐시를 사용할 수 없습니다. 이 경우 Docker는 해당 명령어를 **다시 실행**하고 새로운 레이어를 생성합니다.
4. **캐시 무효화:** 일단 특정 명령어에서 캐시 미스가 발생하면, 그 이후의 **모든 명령어들은 캐시를 사용하지 않고 무조건 다시 실행**됩니다.

**빌드 캐시의 장점:** 이미지 빌드 시간을 획기적으로 단축시켜 줍니다. 특히 소스 코드만 약간 변경하고 다시 빌드하는 경우, 변경된 `COPY` 명령어 이후의 단계만 다시 실행되므로 매우 빠르게 빌드가 완료됩니다.

**캐시 활용을 위한 팁 (Dockerfile 작성 순서의 중요성):**

* 변경 가능성이 낮은 명령어(예: 운영체제 패키지 설치, `package.json`/`requirements.txt` 복사 및 의존성 설치)를 Dockerfile의 **앞부분**에 배치합니다.
* 변경 가능성이 높은 명령어(예: 전체 소스 코드 복사 `COPY . /app`)를 **뒷부분**에 배치합니다.

**실습:**

1. Chapter 7에서 작성한 `Dockerfile`과 `server.js`가 있는 디렉토리에서 첫 빌드를 실행합니다.

    ```bash
    docker build -t hello-node:0.1 .
    ```

    빌드 과정과 각 단계의 실행 시간을 확인합니다.

2. 동일한 명령어를 다시 실행합니다.

    ```bash
    docker build -t hello-node:0.1 .
    ```

    이번에는 거의 모든 단계에서 `Using cache` 메시지가 나타나며 빌드가 매우 빠르게 완료될 것입니다.

3. `server.js` 파일의 내용을 약간 수정합니다 (예: `console.log` 메시지 변경).

4. 다시 빌드 명령어를 실행합니다.

    ```bash
    docker build -t hello-node:0.1 .
    ```

    이제 `COPY server.js .` 명령어 단계에서 캐시를 사용하지 못하고 다시 실행될 것입니다(`---> Running in ...`). 그리고 그 이후의 명령어(`CMD` 등)들도 캐시 없이 다시 처리됩니다. (물론 `CMD` 자체는 레이어를 만들지 않으므로 실행 시간 차이는 거의 없습니다.)


## 8.4 `.dockerignore` 파일을 이용한 빌드 최적화

앞서 언급했듯이, `docker build` 명령어는 빌드 컨텍스트(`PATH`)의 모든 내용을 Docker 데몬으로 전송합니다. 만약 빌드 컨텍스트에 `.git` 디렉토리, `node_modules` 폴더, 로그 파일, 로컬 빌드 결과물, IDE 설정 파일 등 이미지 빌드에 불필요하거나 포함되어서는 안 되는 파일/디렉토리가 있다면, 이들이 모두 데몬으로 전송되어 빌드 속도를 저하시키고 불필요하게 이미지 용량을 차지할 수 있습니다. 또한, 이런 파일들의 변경이 불필요한 캐시 무효화를 유발할 수도 있습니다.

이 문제를 해결하기 위해 `.gitignore` 파일과 유사한 역할을 하는 **`.dockerignore`** 파일을 사용합니다. 빌드 컨텍스트의 루트 디렉토리에 `.dockerignore` 파일을 생성하고 그 안에 빌드 컨텍스트에서 제외(무시)할 파일이나 디렉토리의 패턴 목록을 작성하면, `docker build` 실행 시 Docker 클라이언트는 해당 파일/디렉토리를 아예 Docker 데몬으로 보내지 않습니다.

**.dockerignore 파일 위치:** 빌드 컨텍스트의 **루트 디렉토리**에 위치해야 합니다.

**.dockerignore 파일 문법:** `.gitignore` 파일과 동일한 형식(glob 패턴)을 사용합니다.

**예시 (`.dockerignore` - Node.js 프로젝트):**

```
# Git 관련 파일 제외
.git
.gitignore

# Node.js 의존성 폴더 제외 (이미지 내에서 npm install/ci 로 설치 예정)
node_modules

# npm 디버그 로그 파일 제외
npm-debug.log

# Dockerfile 자체와 .dockerignore 파일 제외
Dockerfile*
.dockerignore

# 운영체제 자동 생성 파일 제외 (macOS)
.DS_Store

# 문서 파일 제외 (이미지 빌드에 필요 없는 경우)
*.md
README

# 로그 파일 제외
*.log

# 빌드 결과물 폴더 제외 (소스에서 빌드하는 경우)
dist
build
```

**`.dockerignore` 사용의 이점:**

* **빌드 속도 향상:** Docker 데몬으로 전송되는 빌드 컨텍스트의 크기를 줄여 전송 시간을 단축합니다 (특히 원격 데몬 사용 시 효과 큼).
* **이미지 용량 감소:** 불필요한 파일이 이미지에 복사되는 것을 방지합니다.
* **보안 강화:** 민감한 정보(예: 비밀번호 파일, `.env` 파일 등)가 실수로 이미지에 포함되는 것을 방지합니다.
* **캐시 효율성 증대:** 무시된 파일의 변경이 `COPY . .` 같은 명령어의 캐시를 불필요하게 무효화하는 것을 막아줍니다.

Chapter 7의 예제 디렉토리에 간단한 `.dockerignore` 파일을 추가해 봅시다 (예: `.git` 폴더가 있다면 제외).

```
# .dockerignore
.git
```

이제 `docker build` 명령을 실행하면 `.git` 폴더는 빌드 컨텍스트에 포함되지 않습니다.
