---
title: "10. 개발 환경으로서의 Docker"
description: "Docker를 활용하여 로컬 개발 환경을 개선하는 방법을 알아봅니다."
---

전통적인 방식의 로컬 개발 환경 설정은 종종 많은 어려움을 동반합니다. 새로운 프로젝트를 시작할 때마다 필요한 언어 런타임(Node.js, Python, PHP 등), 데이터베이스(MySQL, PostgreSQL 등), 각종 개발 도구 및 라이브러리를 직접 설치하고 설정해야 합니다. 이 과정은 시간이 많이 소요될 뿐만 아니라, 여러 프로젝트를 동시에 진행하거나 팀원들과 협업할 때 버전 충돌, 환경 불일치 문제로 이어져 "제 PC에서는 잘 되는데요?"라는 익숙한 좌절감을 안겨주곤 합니다.

Docker는 이러한 문제점들을 해결하고 **일관성 있고, 격리되며, 이식성 높은 개발 환경**을 구축할 수 있는 강력한 솔루션을 제공합니다. 이번 챕터에서는 왜 Docker가 웹 개발자의 로컬 개발 환경에 혁신을 가져올 수 있는지, 그 구체적인 이점들을 중심으로 살펴보겠습니다.


## 10.1 로컬 환경 오염 방지

기존 방식에서는 개발에 필요한 모든 소프트웨어를 개발자의 PC, 즉 호스트 운영체제(Windows, macOS, Linux)에 직접 설치했습니다. 예를 들어, Node.js 프로젝트를 위해 특정 버전의 Node.js와 npm을 설치하고, 다른 프로젝트를 위해 MySQL 데이터베이스 서버를 설치하며, 또 다른 프로젝트 때문에 Redis 서버를 설치하는 식입니다.

이 방식의 문제점은 명확합니다.

* **버전 충돌:** 프로젝트 A는 Node.js 14 버전을 요구하는데, 새로 시작하는 프로젝트 B는 Node.js 18 버전이 필요하다면 어떻게 해야 할까요? `nvm`(Node Version Manager), `pyenv`(Python), `phpbrew`(PHP) 같은 버전 관리 도구를 사용하면 어느 정도 해결은 가능하지만, 설정이 복잡해지고 여러 버전이 섞이면서 예기치 않은 충돌이 발생할 수 있습니다. 데이터베이스나 다른 시스템 라이브러리 버전 문제도 마찬가지입니다.
* **설치 잔여물:** 다양한 소프트웨어를 설치하고 제거하는 과정에서 시스템에는 각종 설정 파일, 레지스트리 항목(Windows의 경우), 백그라운드 서비스, 임시 파일 등이 남게 됩니다. 시간이 지날수록 시스템은 점점 복잡해지고 느려지며, 서로 다른 소프트웨어 간의 보이지 않는 간섭이 발생할 가능성도 커집니다.
* **깔끔한 제거의 어려움:** 특정 프로젝트가 끝나서 관련 의존성(예: 특정 버전의 데이터베이스)을 시스템에서 완전히 제거하고 싶을 때, 관련된 모든 파일과 설정을 깨끗하게 삭제하는 것이 어려울 수 있습니다.

**Docker는 이 문제를 어떻게 해결할까요?**

Docker를 사용하면, 이러한 모든 개발 의존성(Node.js, Python, MySQL, Redis 등)을 호스트 OS에 직접 설치하는 대신, **격리된 컨테이너📦 내부에서 실행**합니다. 개발자의 로컬 PC에는 Docker 엔진(또는 Docker Desktop)만 설치하면 됩니다.

* Node.js 14 버전이 필요하면, Node.js 14 공식 이미지를 사용하여 컨테이너를 실행합니다.
* Node.js 18 버전이 필요하면, 별도의 Node.js 18 컨테이너를 실행합니다. 두 버전은 서로 완전히 격리되어 충돌 없이 동시에 사용할 수 있습니다.
* MySQL 5.7과 PostgreSQL 14가 서로 다른 프로젝트에 필요하다면, 각각의 데이터베이스를 별도의 컨테이너로 실행하면 됩니다.
* 프로젝트가 완료되어 더 이상 특정 환경이 필요 없다면, 관련 컨테이너와 이미지만 간단히 중지하고 삭제(`docker stop`, `docker rm`, `docker rmi`)하면 됩니다. **호스트 OS는 설치 전과 같이 깨끗한 상태를 유지**합니다.


## 10.2 프로젝트별 개발 환경 격리

Docker의 컨테이너는 각 애플리케이션과 그 의존성을 독립적인 환경으로 격리시켜 줍니다. 이를 활용하면 각 프로젝트마다 필요한 모든 구성 요소(애플리케이션 서버, 데이터베이스, 캐시 서버 등)를 포함하는 **완전히 분리된 개발 환경**을 구축할 수 있습니다.

**예시 시나리오:**

* **프로젝트 A (레거시 PHP 애플리케이션):**
  * PHP 7.2 버전 필요
  * MySQL 5.6 버전 필요
  * Apache 웹 서버 필요
  * -> 이 모든 것을 프로젝트 A만을 위한 컨테이너들로 구성합니다.

* **프로젝트 B (최신 Node.js 마이크로서비스):**
  * Node.js 18 버전 필요
  * PostgreSQL 15 버전 필요
  * Redis 캐시 필요
  * -> 이 서비스들을 프로젝트 B 전용 컨테이너들로 구성합니다.

**장점:**

* **상호 간섭 없음:** 프로젝트 A의 MySQL 5.6 서버와 프로젝트 B의 PostgreSQL 15 서버는 서로의 존재를 알지 못하며 영향을 주지 않습니다. 만약 두 프로젝트 모두 MySQL을 사용하더라도, 다른 버전의 MySQL 서버를 별도의 컨테이너로 실행하고 호스트 머신의 다른 포트(예: 3306과 3307)로 매핑하여 충돌 없이 사용할 수 있습니다.
* **자체 포함 환경 (Self-Contained):** 각 프로젝트의 개발 환경 설정(Dockerfile, Docker Compose 파일 등)은 해당 프로젝트의 소스 코드 저장소 내에 함께 포함됩니다. 즉, 개발 환경 자체가 프로젝트의 일부가 되는 것입니다.
* **환경 재현성:** 프로젝트 코드를 내려받으면, 해당 프로젝트 실행에 필요한 정확한 버전의 도구와 설정으로 구성된 개발 환경 정의도 함께 얻게 됩니다.


## 10.3 팀원 간의 개발 환경 통일 및 공유

"제 PC에서는 잘 되는데요?"라는 문제는 팀 협업 환경에서 더욱 심각한 생산성 저하를 유발합니다. 새로운 팀원이 합류했을 때, 복잡한 README 파일을 따라 수많은 소프트웨어를 설치하고 설정하는 데 몇 시간, 심지어 며칠을 허비하는 경우가 흔합니다. 그 과정에서 발생하는 미묘한 환경 차이(OS 버전, 기존 설치된 다른 프로그램과의 충돌, 설정 실수 등)는 특정 개발자의 PC에서만 발생하는 버그로 이어지기도 합니다.

**Docker는 이 문제를 어떻게 해결할까요?**

1. 프로젝트에 필요한 모든 구성 요소(웹 서버 컨테이너, API 서버 컨테이너, 데이터베이스 컨테이너, 캐시 컨테이너 등)와 그 설정을 `Dockerfile`과 **`docker-compose.yml`** 파일(여러 컨테이너를 정의하고 실행하는 도구, 이후 챕터에서 자세히 다룸)을 사용하여 코드로 명확하게 정의합니다.
2. 이 설정 파일들(`Dockerfile`, `docker-compose.yml` 등)을 프로젝트의 소스 코드와 함께 Git과 같은 버전 관리 시스템에 저장합니다.
3. **새로운 팀원의 온보딩 과정:**
    * 프로젝트 소스 코드를 Git 저장소에서 내려받습니다 (`git clone`).
    * 자신의 PC에 Docker Desktop(Windows/macOS) 또는 Docker Engine(Linux)을 설치합니다.
    * 터미널에서 프로젝트 디렉토리로 이동한 후, **단 하나의 명령어**(예: `docker-compose up`)를 실행합니다.
    * Docker는 `docker-compose.yml` 파일을 읽어 필요한 모든 이미지를 다운로드하거나 빌드하고, 정의된 모든 서비스 컨테이너를 정확한 설정과 버전으로 실행시켜 완전한 개발 환경을 자동으로 구축해 줍니다.

**장점:**

* **획기적인 설치 시간 단축:** 개발 환경 구축에 걸리는 시간이 몇 시간 또는 며칠에서 **몇 분**으로 단축됩니다.
* **완벽한 환경 일관성 보장:** 모든 팀원이 **코드로 정의된 동일한 개발 환경**을 사용하게 됩니다. 이로 인해 환경 차이로 인한 버그가 거의 사라집니다.
* **간소화된 협업:** 실행 가능한 프로젝트 환경을 쉽게 공유하고, 문제가 발생했을 때 동일한 환경에서 함께 디버깅하기 용이해집니다.


## 10.4 다양한 버전의 개발 도구 사용하기

Docker를 사용하면 서로 다른 버전의 프로그래밍 언어, 데이터베이스, 또는 기타 개발 도구들을 로컬 시스템에서 충돌 없이 손쉽게 사용할 수 있습니다.

**활용 사례:**

* **다양한 Node.js 버전 테스트:** 개발 중인 애플리케이션이 여러 Node.js 버전(예: LTS 버전인 16, 18, 최신 버전인 20)과 호환되는지 테스트해야 할 때, 각 버전에 맞는 Node.js 컨테이너 내부에서 테스트 스크립트를 실행할 수 있습니다. 로컬에 여러 버전을 설치하고 관리할 필요가 없습니다.
* **레거시 프로젝트 유지보수:** PHP 5.6 버전을 사용하는 오래된 프로젝트와 PHP 8.1 버전을 사용하는 새로운 프로젝트를 동시에 유지보수해야 할 때, 각 프로젝트에 맞는 PHP 및 웹 서버(Apache/Nginx) 환경을 별도의 컨테이너 세트로 구성하여 관리할 수 있습니다.
* **신기술 실험:** 새로운 버전의 데이터베이스(예: PostgreSQL 16)나 새로운 기술(예: RabbitMQ 메시지 큐)을 프로젝트에 도입하기 전에, 기존 시스템에 영향을 주지 않고 격리된 컨테이너 환경에서 안전하게 실험하고 테스트해 볼 수 있습니다.

이 모든 것이 가능한 이유는 Dockerfile의 `FROM` 명령어에서 필요한 버전의 공식 이미지(예: `node:16`, `node:18`, `php:5.6-apache`, `php:8.1-fpm`, `postgres:16`)를 선택하여 해당 프로젝트나 작업에 맞는 컨테이너를 정의하기만 하면 되기 때문입니다.
