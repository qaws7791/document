---
title: "4. 파일과 디렉토리"
---

Chapter 3에서 터미널과 쉘이라는 리눅스와 소통하는 기본 창구를 익혔습니다. 이제 리눅스 세계의 지도를 펼쳐보고, 그 안을 자유롭게 탐험할 시간입니다. 리눅스에서 모든 정보와 프로그램은 **파일(File)** 형태로 저장되고, 이 파일들은 **디렉토리(Directory)** 라는 폴더 안에 체계적으로 정리됩니다. 마치 도서관에 책(파일)들이 있고, 이 책들이 주제별 서가(디렉토리)에 꽂혀 있는 것과 같습니다.

이번 Chapter 4에서는 리눅스 시스템이 어떤 구조로 이루어져 있는지(파일 시스템 구조) 살펴보고, 이 구조 속에서 우리가 원하는 위치로 이동하고(`pwd`, `cd`), 그곳에 무엇이 있는지 확인하며(`ls`), 새로운 파일을 만들거나 삭제하고(`mkdir`, `touch`, `rm`, `rmdir`), 파일을 복사하거나 옮기는(`cp`, `mv`) 등 가장 기본적이면서도 핵심적인 파일 및 디렉토리 조작 방법들을 배우게 됩니다. 또한 파일의 내용을 들여다보고(`cat`, `less` 등), 필요한 파일을 찾거나(`find`, `locate`) 파일 안의 특정 내용을 검색하는(`grep`) 방법까지 다룰 것입니다.

이 챕터에서 배우는 명령어들은 앞으로 리눅스를 사용하면서 거의 매일 사용하게 될 가장 기본적인 도구들이니, 확실하게 익혀두는 것이 중요합니다.


## 4.1 리눅스 파일 시스템 구조 (FHS: Filesystem Hierarchy Standard)

리눅스는 독특하고 일관성 있는 방식으로 파일과 디렉토리를 구성합니다. 그 기본 철학과 표준 구조를 이해하면 리눅스 시스템을 훨씬 쉽게 파악할 수 있습니다.


### 4.1.1 모든 것은 파일이다? (Everything is a File?)

리눅스(및 유닉스)의 중요한 설계 철학 중 하나는 **"모든 것을 파일로 취급한다"** 는 것입니다. 우리가 흔히 생각하는 문서 파일이나 이미지 파일뿐만 아니라, 다음과 같은 것들도 파일 시스템 내에서 파일 형태로 표현됩니다.

* **디렉토리:** 사실 디렉토리도 내부에 다른 파일이나 디렉토리 목록 정보를 담고 있는 특별한 종류의 파일입니다.
* **하드웨어 장치:** 하드 디스크, 키보드, 마우스, 프린터 등 시스템에 연결된 하드웨어 장치들도 `/dev` 디렉토리 아래에 특수한 파일 형태로 존재합니다. (예: `/dev/sda`, `/dev/tty1`)
* **프로세스 정보:** 현재 실행 중인 프로그램(프로세스)에 대한 정보도 `/proc` 디렉토리 아래에 파일 형태로 접근할 수 있습니다.
* **네트워크 통신:** 네트워크 소켓 등도 파일 시스템을 통해 관리될 수 있습니다.

이렇게 다양한 시스템 자원을 '파일'이라는 일관된 방식으로 다루기 때문에, `ls`, `cat` 같은 기본적인 파일 처리 명령어를 다양한 대상에 적용할 수 있고, 입출력 리다이렉션(`>`)이나 파이프(`|`) 같은 쉘 기능을 활용하여 시스템을 유연하게 제어할 수 있습니다. (지금 당장 이 모든 것을 이해할 필요는 없습니다. 앞으로 계속 접하게 될 개념입니다.)


### 4.1.2 중요한 디렉토리 살펴보기 (FHS - Filesystem Hierarchy Standard)

리눅스 파일 시스템은 최상위 디렉토리인 **루트 디렉토리(`/`)** 부터 시작하여 나무처럼 가지를 뻗어나가는 계층적인 구조를 가지고 있습니다. 대부분의 리눅스 배포판은 **FHS(Filesystem Hierarchy Standard)** 라는 표준을 따라 디렉토리 구조와 각 디렉토리의 역할을 정의합니다. 덕분에 우리는 어떤 배포판을 사용하든 비교적 일관된 구조를 만날 수 있습니다.

주요 디렉토리와 그 역할은 다음과 같습니다. (마치 도시의 주요 구역과 같습니다!)

* `/` (루트 디렉토리): 파일 시스템 계층 구조의 **최상위 시작점**입니다. 모든 디렉토리와 파일은 이 아래에 존재합니다.
* `/bin`: **B**inary의 약자. `ls`, `cp`, `mv` 등 시스템을 사용하는 데 필요한 **기본적인 명령어(실행 파일)** 들이 들어 있습니다. 시스템 복구나 단일 사용자 모드에서도 사용 가능해야 하는 필수 명령어들입니다.
* `/sbin`: **S**ystem **Bin**ary의 약자. `reboot`, `fdisk`, `ifconfig` 등 주로 **시스템 관리자(root)가 사용하는 시스템 관리용 명령어**들이 있습니다.
* `/etc`: **Etc**etera의 약자. 운영체제 자체의 설정 파일이나 여러 프로그램들의 **주요 설정 파일**들이 모여 있는 매우 중요한 디렉토리입니다. (주로 텍스트 기반 파일)
* `/dev`: **Dev**ice의 약자. 시스템에 연결된 **하드웨어 장치들을 나타내는 특수 파일**들이 있는 곳입니다. (예: 하드 디스크, 키보드, 터미널 등)
* `/proc`: **Proc**ess의 약자. 현재 실행 중인 **프로세스와 커널 상태에 대한 정보를 담고 있는 가상 파일 시스템**입니다. (파일처럼 보이지만 실제 디스크에 저장된 것이 아니라 메모리 상의 정보를 보여줍니다.)
* `/var`: **Var**iable의 약자. 시스템 운영 중에 **크기가 변하거나 자주 변경되는 데이터**를 저장하는 곳입니다. 대표적으로 시스템 로그 파일(`/var/log`), 웹 서버 데이터(`/var/www`), 메일 스풀, 데이터베이스 파일 등이 이곳에 위치합니다.
* `/tmp`: **T**e**mp**orary의 약자. 프로그램들이 실행 중에 잠시 사용하는 **임시 파일**들을 저장하는 곳입니다. 시스템 재부팅 시 내용이 삭제될 수 있습니다.
* `/usr`: **U**nix **S**ystem **R**esources의 약자 (또는 User System Resources). 시스템에 설치된 **대부분의 사용자용 프로그램과 라이브러리, 문서** 등이 저장되는 가장 큰 디렉토리 중 하나입니다.
  * `/usr/bin`: 일반 사용자들이 사용하는 대부분의 프로그램 명령어들이 있습니다. (`/bin` 보다는 덜 필수적인 명령어들)
  * `/usr/sbin`: 일반 시스템 관리용 명령어들이 있습니다. (`/sbin` 보다는 덜 필수적인 명령어들)
  * `/usr/lib`: `/usr/bin`, `/usr/sbin` 에 있는 프로그램들이 사용하는 공유 라이브러리 파일들이 있습니다.
  * `/usr/local`: 패키지 관리자(apt, dnf 등)가 아닌, **관리자가 직접 컴파일하여 설치하는 프로그램**들이 위치하는 곳입니다.
  * `/usr/share`: 프로그램들 간에 공유되는 데이터(문서, 아이콘, 폰트 등)가 있습니다.
* `/home`: **사용자들의 개인 홈 디렉토리**가 생성되는 곳입니다. 시스템에 'alice'라는 사용자가 있다면, `/home/alice` 라는 디렉토리가 생성되고, 이 사용자의 개인 파일, 설정 파일 등은 이곳에 저장됩니다. **일반 사용자는 주로 자신의 홈 디렉토리 안에서 작업하게 됩니다.**
* `/root`: 시스템 **관리자(root) 계정의 홈 디렉토리**입니다. 일반 사용자의 홈 디렉토리인 `/home`과는 분리되어 있습니다.
* `/boot`: 리눅스 시스템이 **부팅될 때 필요한 파일**들이 있는 곳입니다. 리눅스 커널 이미지, 부트로더(예: GRUB) 설정 파일 등이 여기에 있습니다.
* `/opt`: **Opt**ional의 약자. 추가적으로 설치되는 서드파티 응용 프로그램 패키지들이 위치하는 경우가 있습니다. (예: Google Chrome)
* `/mnt`, `/media`: 외장 하드 드라이브, USB 메모리, CD-ROM 등 **외부 저장 장치를 일시적으로 연결(마운트)할 때 사용**하는 디렉토리입니다. (`mnt`는 수동 마운트, `media`는 자동 마운트되는 경향이 있습니다.)

이 구조를 처음부터 다 외울 필요는 없습니다. 자주 사용하다 보면 자연스럽게 익숙해질 것입니다. 중요한 것은 최상위 루트(`/`) 디렉토리부터 시작하는 계층 구조와, `/etc` (설정), `/var` (변하는 데이터, 로그), `/home` (사용자 공간), `/usr` (설치된 프로그램) 등의 주요 디렉토리 역할을 이해하는 것입니다.


## 4.2 현재 위치 확인하고 이동하기 (`pwd`, `cd`)

리눅스 터미널에서 작업할 때는 항상 '현재 작업 디렉토리(Current Working Directory)'라는 개념이 중요합니다. 이것은 내가 지금 위치하고 있는 디렉토리(폴더)를 의미합니다.

* **`pwd` (Print Working Directory): 현재 위치 확인하기**
    현재 내가 어느 디렉토리에 있는지 전체 경로를 알고 싶을 때 사용하는 가장 기본적인 명령어입니다.

    ```bash
    pwd
    ```

    예를 들어, 여러분의 사용자 이름이 'guest'라면, 터미널을 처음 열었을 때 `pwd`를 실행하면 보통 `/home/guest` 와 같은 결과가 나올 것입니다.

* **`cd` (Change Directory): 다른 디렉토리로 이동하기**
    현재 작업 디렉토리를 다른 디렉토리로 변경(이동)할 때 사용합니다. `cd` 명령어 뒤에는 이동하고 싶은 디렉토리의 경로를 적어줍니다.

    ```bash
    cd /usr/bin
    pwd  # 이동 후 현재 위치 확인 -> /usr/bin 이 출력됨
    cd /var/log
    pwd  # -> /var/log 가 출력됨
    ```


### 4.2.1 절대 경로와 상대 경로 이해하기

`cd` 명령어로 이동할 때 경로를 지정하는 방식에는 두 가지가 있습니다.

* **절대 경로 (Absolute Path):** 루트 디렉토리(`/`)부터 시작하여 목표 디렉토리까지 이어지는 전체 경로를 모두 명시하는 방식입니다. 내가 현재 어느 디렉토리에 있든 상관없이 항상 동일한 위치를 가리킵니다. 마치 건물의 전체 주소와 같습니다.
  * 예시: `cd /home/guest/documents`, `cd /etc/ssh`

* **상대 경로 (Relative Path):** 현재 작업 디렉토리를 기준으로 목표 디렉토리까지의 상대적인 경로를 명시하는 방식입니다. 루트(`/`)로 시작하지 않습니다. 마치 "옆방으로 가" 또는 "두 블록 아래로 가" 라고 말하는 것과 같습니다.
  * 예시: 만약 현재 위치가 `/home/guest` 라면,
    * `cd documents` 명령은 `/home/guest/documents` 로 이동합니다.
    * 현재 위치가 `/home/guest/documents` 라면, `cd ../downloads` 명령은 한 단계 위(`/home/guest`)로 올라갔다가 `downloads` 디렉토리로 내려가므로 `/home/guest/downloads` 로 이동합니다. (아래 `..` 설명 참고)

* **언제 무엇을 사용할까?**
  * **절대 경로:** 스크립트 파일 안에서 경로를 지정하거나, 현재 위치와 상관없이 항상 특정 위치를 가리켜야 할 때 유용합니다. 경로가 명확합니다.
  * **상대 경로:** 현재 디렉토리 근처의 다른 디렉토리로 이동할 때 타이핑하기 편리합니다.


### 4.2.2 특수 디렉토리 기호

경로를 입력할 때 자주 사용되는 유용한 특수 기호들이 있습니다.

* `.` (점 하나): **현재 디렉토리**를 의미합니다.
  * 예시: `ls .` 는 `ls` 와 동일하게 현재 디렉토리 목록을 보여줍니다.

* `..` (점 두개): **부모 디렉토리(상위 디렉토리)**, 즉 현재 디렉토리보다 한 단계 위의 디렉토리를 의미합니다. 파일 시스템 계층 구조를 거슬러 올라갈 때 매우 유용합니다.
  * 예시: 현재 `/home/guest/documents` 에 있다면, `cd ..` 명령은 `/home/guest` 로 이동합니다. `cd ../..` 명령은 `/home` 으로 이동합니다.

* `~` (틸드): **현재 로그인한 사용자의 홈 디렉토리**를 의미하는 약어입니다. 어느 위치에 있든지 `~` 는 항상 나의 홈 디렉토리를 가리킵니다.
  * 예시: `cd ~` 명령은 `/home/guest` (사용자 이름이 guest일 경우) 로 이동합니다.
  * `cd` 명령어 뒤에 아무것도 입력하지 않고 `cd` 만 실행해도 보통 홈 디렉토리로 이동합니다.
  * `cd ~/pictures` 명령은 홈 디렉토리 아래의 `pictures` 디렉토리로 이동합니다.

* `-` (하이픈): **바로 이전에 있었던 작업 디렉토리**를 의미합니다. 두 디렉토리를 자주 왔다 갔다 할 때 편리합니다.
  * 예시: `/home/guest` 에서 `cd /etc` 로 이동한 후, `cd -` 를 실행하면 다시 `/home/guest` 로 돌아옵니다. 다시 `cd -` 를 실행하면 `/etc` 로 이동합니다.


## 4.3 파일 및 디렉토리 목록 보기 (`ls`)

현재 디렉토리나 특정 디렉토리 안에 어떤 파일과 디렉토리들이 있는지 목록을 보여주는 명령어입니다. 가장 기본적이고 가장 자주 사용하는 명령어 중 하나입니다.

* **기본 사용법:**
  * `ls`: 현재 작업 디렉토리의 목록을 보여줍니다. (숨김 파일 제외)
  * `ls /path/to/directory`: 지정한 디렉토리의 목록을 보여줍니다. (예: `ls /bin`)


### 4.3.1 다양한 옵션 활용하기

`ls` 명령어는 다양한 옵션을 통해 출력 형식이나 내용을 변경할 수 있습니다. 자주 사용되는 옵션은 다음과 같습니다.

* `-l` (long format): 파일/디렉토리의 **상세 정보**를 긴 형식으로 보여줍니다. (권한, 소유자, 그룹, 크기, 마지막 수정 시간, 이름 등)

    ```bash
    ls -l
    ```

* `-a` (all): 이름이 점(`.`)으로 시작하는 **숨김 파일(hidden file) 및 디렉토리를 포함하여 모든 항목**을 보여줍니다. (리눅스 설정 파일은 주로 숨김 파일 형태입니다.)

    ```bash
    ls -a
    ls -al  # -a 와 -l 옵션을 함께 사용 (순서 무관)
    ```

* `-h` (human-readable): `-l` 옵션과 함께 사용하며, 파일 크기를 사람이 읽기 쉬운 단위(KB, MB, GB 등)로 표시해줍니다.

    ```bash
    ls -lh
    ls -alh # 세 가지 옵션을 함께 사용
    ```

* `-t`: 파일을 **마지막 수정 시간(modification time)** 순서로 정렬하여 보여줍니다. (최신 파일이 가장 위로)

    ```bash
    ls -lt
    ls -lth # 시간순 + 상세정보 + 읽기 쉬운 크기
    ```

* `-r` (reverse): 현재 정렬 순서를 **거꾸로(reverse)** 뒤집습니다.

    ```bash
    ls -lr  # 이름 역순으로 정렬 (z부터 a)
    ls -ltr # 시간 역순으로 정렬 (오래된 파일이 가장 위로) - 로그 파일 등 시간 순서대로 볼 때 유용
    ```

옵션들은 필요에 따라 조합하여 사용할 수 있습니다. 예를 들어 `ls -altrh` 와 같이 여러 옵션을 한 번에 사용할 수 있습니다.


### 4.3.2 파일 종류 및 권한 정보 읽는 법 (간략 소개)

`ls -l` 명령의 출력 결과는 많은 정보를 담고 있습니다. 지금 당장 모든 것을 이해할 필요는 없지만, 첫 번째 문자와 주요 필드를 알아두면 좋습니다.

예시 출력:

```
-rw-r--r-- 1 guest users  1024 Apr  8 22:10 my_document.txt
drwxr-xr-x 2 guest users  4096 Mar 15 11:30 projects
lrwxrwxrwx 1 root  root     15 Apr  1 09:00 shortcut -> /usr/bin/python3
```

* **첫 번째 문자:** 파일의 종류를 나타냅니다.
  * `-`: 일반 파일 (텍스트, 이미지, 실행 파일 등)
  * `d`: 디렉토리
  * `l`: 심볼릭 링크 (바로가기 파일)
  * (그 외 `c`: 문자 특수 장치 파일, `b`: 블록 특수 장치 파일 등이 있습니다.)
* **그 뒤 9개 문자:** 파일 접근 권한을 나타냅니다. (r=읽기, w=쓰기, x=실행). 세 묶음으로 나뉘며 각각 소유자, 그룹, 그 외 사용자의 권한을 의미합니다. (자세한 내용은 Chapter 7에서 다룹니다.)
* **숫자:** 하드 링크의 수 (파일의 경우 보통 1, 디렉토리는 2 이상)
* **guest:** 파일의 소유자 이름
* **users:** 파일이 속한 그룹 이름
* **1024 / 4096:** 파일의 크기 (바이트 단위, `-h` 옵션 사용 시 KB/MB 등으로 표시됨)
* **Apr 8 22:10 / Mar 15 11:30:** 마지막으로 수정된 날짜 및 시간
* **my_document.txt / projects / shortcut -> ...:** 파일 또는 디렉토리의 이름 (심볼릭 링크의 경우 원본 경로도 함께 표시됨)


## 4.4 파일과 디렉토리 만들고 삭제하기 (`mkdir`, `touch`, `rmdir`, `rm`)

리눅스에서 파일과 디렉토리를 생성하고 삭제하는 명령어들을 알아봅시다.


### 4.4.1 파일/디렉토리 생성

* **`mkdir <디렉토리 이름>` (Make Directory): 새 디렉토리 만들기**
    지정한 이름으로 새로운 디렉토리(폴더)를 생성합니다.

    ```bash
    mkdir my_project
    mkdir backups reports # 여러 개 동시 생성 가능
    ```

  * **`-p` 옵션:** 경로상의 중간 디렉토리들이 없을 경우 자동으로 함께 생성해줍니다.

        ```bash
        mkdir -p level1/level2/level3 # level1, level2 디렉토리가 없어도 자동으로 생성됨
        ```

* **`touch <파일 이름>`: 빈 파일 생성 또는 시간 정보 업데이트**
    지정한 이름의 파일이 없다면, 내용이 비어있는 새로운 파일을 생성합니다. 만약 파일이 이미 존재한다면, 파일의 내용 변경 없이 마지막 접근 시간과 수정 시간을 현재 시간으로 업데이트합니다.

    ```bash
    touch new_file.txt
    touch config.yaml data.csv # 여러 개 동시 생성 가능
    ```

    (파일 내용을 편집하는 것은 `vim` 이나 `nano` 같은 편집기 프로그램을 사용하며, Chapter 5에서 배웁니다.)


### 4.4.2 파일/디렉토리 삭제

**!!! 경고: 리눅스 명령줄에서 파일을 삭제하면 일반적으로 휴지통으로 가지 않고 영구적으로 삭제됩니다. 복구가 매우 어려우니 삭제 명령어 사용 시에는 항상 극도의 주의가 필요합니다 !!!**

* **`rmdir <디렉토리 이름>` (Remove Directory): 빈 디렉토리 삭제하기**
    **비어 있는** 디렉토리만 삭제할 수 있습니다. 내용물이 있는 디렉토리는 삭제하지 못합니다. 비교적 안전한 삭제 명령어입니다.

    ```bash
    rmdir empty_dir
    ```

* **`rm <파일 이름>` (Remove): 파일 삭제하기**
    파일을 삭제합니다.

    ```bash
    rm old_file.txt
    rm temp1.tmp temp2.tmp # 여러 개 동시 삭제
    ```

  * **`-r` 옵션 (Recursive): 디렉토리와 그 내용물 모두 삭제하기**
        디렉토리와 그 안에 포함된 모든 파일, 하위 디렉토리까지 재귀적으로 전부 삭제합니다. **이 옵션은 매우 강력하고 위험하므로 사용 시 반드시 경로를 재차 확인해야 합니다!**

        ```bash
        rm -r directory_to_delete
        ```

  * **`-i` 옵션 (Interactive): 삭제 전 확인하기**
        삭제할 각 파일/디렉토리에 대해 정말 삭제할 것인지 사용자에게 물어봅니다. 실수 방지에 도움이 됩니다.

        ```bash
        rm -i important_file.cfg
        rm -ri sensitive_directory # 디렉토리 내부 항목마다 물어봄
        ```

  * **`-f` 옵션 (Force): 강제로 삭제하기**
        존재하지 않는 파일에 대한 경고 메시지 등을 무시하고, 쓰기 금지된 파일 등도 강제로 삭제하려고 시도합니다. (권한이 없으면 실패). `-r` 옵션과 함께 `rm -rf <경로>` 형태로 사용될 경우, **시스템에 심각한 손상을 초래할 수 있는 매우 위험한 명령어 조합**입니다. (예: `rm -rf /` 는 시스템 전체를 삭제하라는 명령!) 꼭 필요한 경우가 아니면 사용하지 않는 것이 좋으며, 사용 시에는 경로를 열 번 이상 확인해야 합니다.

**"삭제하기 전엔 두 번 생각하고, 삭제 명령은 한 번만 내린다!"** 는 마음가짐을 가지는 것이 중요합니다.


## 4.5 파일과 디렉토리 복사하고 옮기기 (`cp`, `mv`)

파일이나 디렉토리를 복제하거나 다른 위치로 이동하는 방법을 알아봅시다.


### 4.5.1 파일/디렉토리 복사 (`cp` - Copy)

원본 파일이나 디렉토리를 그대로 두고, 사본을 만들 때 사용합니다.

* **파일 복사:**

    ```bash
    cp source.txt destination.txt   # source.txt 를 destination.txt 라는 이름으로 복사
    cp report.doc /home/guest/backups/ # report.doc 파일을 backups 디렉토리 안으로 복사 (이름 유지)
    cp file1.txt file2.txt notes/    # 여러 파일을 notes 디렉토리 안으로 복사
    ```

* **디렉토리 복사:** 디렉토리를 복사할 때는 반드시 **`-r` 또는 `-R` (Recursive)** 옵션을 사용해야 합니다. 디렉토리와 그 안의 모든 내용물이 함께 복사됩니다.

    ```bash
    cp -r project_a project_a_backup # project_a 디렉토리를 project_a_backup 이라는 이름으로 복사
    cp -r configs/ /etc/backup/      # configs 디렉토리를 /etc/backup/ 디렉토리 안으로 복사
    ```

* **주요 옵션:**
  * `-i` (interactive): 복사 대상 위치에 같은 이름의 파일이 이미 존재할 경우, 덮어쓸지 물어봅니다.
  * `-v` (verbose): 복사되는 파일/디렉토리의 이름을 화면에 보여줍니다.
  * `-p` (preserve): 원본 파일의 소유권, 권한, 시간 정보 등을 최대한 유지하며 복사합니다.


### 4.5.2 파일/디렉토리 이동 및 이름 변경 (`mv` - Move)

파일이나 디렉토리를 다른 위치로 옮기거나, 이름을 변경할 때 사용합니다. `mv` 명령어는 **이동**과 **이름 변경** 두 가지 용도로 사용됩니다.

* **이동:**

    ```bash
    mv document.pdf archives/       # document.pdf 파일을 archives 디렉토리 안으로 이동
    mv report_v1.doc report_v2.doc drafts/ # 여러 파일을 drafts 디렉토리 안으로 이동
    mv old_project /opt/storage/   # old_project 디렉토리를 /opt/storage/ 디렉토리 안으로 이동
    ```

* **이름 변경:** **같은 디렉토리 내에서** `mv` 명령어를 사용하여 대상 이름을 다르게 지정하면 이름이 변경됩니다. 이것이 리눅스에서 파일/디렉토리 이름을 바꾸는 표준적인 방법입니다.

    ```bash
    mv report_final.txt report_final_v2.txt # 파일 이름 변경
    mv my_app my_application            # 디렉토리 이름 변경
    ```

* **주요 옵션:**
  * `-i` (interactive): 이동/이름 변경 대상 위치에 같은 이름이 존재할 경우, 덮어쓸지 물어봅니다.
  * `-v` (verbose): 이동/이름 변경되는 항목의 이름을 보여줍니다.


## 4.6 파일 내용 살펴보기 (`cat`, `less`, `more`, `head`, `tail`)

파일 내용을 편집하지 않고 단순히 터미널에서 확인하고 싶을 때 사용하는 명령어들입니다.


### 4.6.1 전체 내용 보기 (`cat` - Concatenate)

파일의 **전체 내용**을 터미널 화면에 쭉 출력합니다. 여러 파일을 지정하면 내용을 이어서 보여줍니다. (원래는 파일들을 '연결(concatenate)'하는 기능이 주 목적입니다.)

```bash
cat my_file.txt
cat chapter1.txt chapter2.txt > book.txt # 두 파일 내용을 합쳐 book.txt 파일 생성 (리다이렉션 활용)
```

* **장점:** 파일 내용 전체를 빠르게 훑어보거나 다른 명령어와 파이프(`|`)로 연결할 때 유용합니다.
* **단점:** 파일 내용이 길 경우, 앞부분이 너무 빨리 지나가서 제대로 보기 어렵습니다.


### 4.6.2 페이지 단위로 보기 (`less`, `more`)

파일 내용이 길어서 한 화면에 다 보이지 않을 때 유용합니다. 내용을 페이지 단위로 나누어 보여줍니다.

* **`less <파일 이름>`:** `more` 보다 향상된 기능의 페이저(pager) 프로그램입니다. **일반적으로 `less` 사용을 권장합니다.**
  * 화살표 키(↑, ↓), Page Up, Page Down, 스페이스바 키로 내용을 **위아래로 자유롭게 스크롤**할 수 있습니다.
  * `/` 키를 누르고 검색어를 입력하면 파일 내에서 **내용 검색**이 가능합니다. (`n` 다음 찾기, `N` 이전 찾기)
  * `q` 키를 누르면 보기 모드를 종료하고 터미널로 돌아갑니다.

    ```bash
    less system.log
    ```

* **`more <파일 이름>`:** 전통적인 페이저 프로그램입니다.
  * 스페이스바를 누르면 다음 페이지로, Enter 키를 누르면 다음 줄로 이동합니다.
  * 일반적으로 **앞 페이지로 되돌아가는 기능이 없습니다.**
  * `q` 키로 종료합니다.

    ```bash
    more old_config.cfg
    ```


### 4.6.3 처음/마지막 부분만 보기 (`head`, `tail`)

파일의 내용 전체가 아닌, 앞부분이나 뒷부분의 일부만 빠르게 확인하고 싶을 때 사용합니다.

* **`head <파일 이름>`:** 파일의 **처음 10줄**을 보여줍니다. (기본값)
  * `-n <숫자>` 옵션: 처음부터 지정한 `<숫자>`만큼의 줄 수를 보여줍니다.

        ```bash
        head data.csv
        head -n 5 script.sh # 처음 5줄만 보기
        ```

* **`tail <파일 이름>`:** 파일의 **마지막 10줄**을 보여줍니다. (기본값)
  * `-n <숫자>` 옵션: 마지막부터 지정한 `<숫자>`만큼의 줄 수를 보여줍니다.

        ```bash
        tail access.log
        tail -n 20 error.log # 마지막 20줄만 보기
        ```

  * **`-f` 옵션 (Follow): 실시간 로그 감시**
        파일의 마지막 부분을 보여주고, 그 이후 **파일에 내용이 추가될 때마다 계속해서 화면에 업데이트**하여 보여줍니다. 실시간으로 변경되는 로그 파일을 모니터링할 때 매우 유용합니다. (종료하려면 `Ctrl` + `C` 키를 누릅니다.)

        ```bash
        tail -f /var/log/syslog # syslog 파일의 변경 내용을 실시간으로 확인
        ```


## 4.7 파일 찾기 (`find`, `locate`, `which`, `whereis`)

파일 시스템 어딘가에 있는 특정 파일을 찾아야 할 때 사용하는 명령어들입니다.


### 4.7.1 강력한 파일 검색 도구 (`find`)

지정한 디렉토리부터 시작하여 하위 디렉토리까지 재귀적으로 탐색하면서, 다양한 조건(이름, 종류, 크기, 수정 시간, 소유자, 권한 등)에 맞는 파일을 찾아냅니다. 매우 강력하지만 옵션이 많아 조금 복잡할 수 있습니다.

* **기본 형식:** `find <검색 시작 디렉토리> <조건식>`
* **자주 사용되는 조건식:**
  * `-name "<패턴>"`: 지정한 이름 패턴(와일드카드 `*`, `?` 사용 가능)에 맞는 파일을 찾습니다. (패턴은 따옴표로 감싸주는 것이 좋습니다.)
  * `-type <타입>`: 지정한 파일 타입만 찾습니다. (`f`: 일반 파일, `d`: 디렉토리, `l`: 심볼릭 링크 등)
  * `-mtime <숫자>`: 파일의 마지막 수정 시간(Modification time)을 기준으로 찾습니다.
    * `-mtime -7`: 최근 7일 이내에 수정된 파일
    * `-mtime 7`: 정확히 7일 전에 수정된 파일
    * `-mtime +7`: 7일보다 이전에 수정된 파일
  * `-size <크기>`: 파일 크기를 기준으로 찾습니다.
    * `-size +100M`: 100MB보다 큰 파일
    * `-size -10k`: 10KB보다 작은 파일
    * `-size 1G`: 정확히 1GB인 파일 (단위: `c`=바이트, `k`=KB, `M`=MB, `G`=GB)
  * `-user <사용자명>`: 특정 사용자가 소유한 파일을 찾습니다.
  * `-group <그룹명>`: 특정 그룹이 소유한 파일을 찾습니다.
  * `-perm <권한>`: 특정 권한 설정(예: `777`, `644`)을 가진 파일을 찾습니다.
  * `-exec <명령어> {} \;`: 찾은 파일에 대해 특정 명령어를 실행합니다. (고급 기능)

* **예시:**

    ```bash
    find . -name "*.log"            # 현재 디렉토리 및 하위에서 .log 파일 찾기
    find /home -type d -name "images" # /home 아래에서 이름이 images 인 디렉토리 찾기
    find /etc -mtime -3             # /etc 아래에서 최근 3일 내 수정된 파일 찾기
    find /var/log -size +50M        # /var/log 아래에서 50MB 보다 큰 파일 찾기
    find /tmp -user guest -delete   # /tmp 아래에서 guest 사용자가 소유한 파일 찾아 삭제 (주의!)
    ```

`find` 명령어는 실제 파일 시스템을 직접 탐색하므로, 검색 범위가 넓으면 시간이 오래 걸릴 수 있습니다.


### 4.7.2 빠른 파일 검색 (`locate`)

미리 만들어진 파일 목록 데이터베이스를 사용하여 파일 이름으로 매우 빠르게 검색합니다.

* **사용법:** `locate <검색 패턴>`

    ```bash
    locate my_report.pdf
    locate bashrc
    ```

* **특징:**
  * 매우 빠릅니다.
  * 파일 이름의 일부만 포함해도 찾아줍니다.
  * 데이터베이스는 보통 주기적으로(`cron` 작업) `updatedb` 명령어를 통해 자동 갱신되지만, **아주 최근에 생성되거나 변경된 파일은 데이터베이스가 갱신되기 전까지 `locate` 로 찾지 못할 수 있습니다.**
  * 필요하다면 `sudo updatedb` 명령으로 데이터베이스를 수동 갱신할 수 있습니다. (시간이 걸릴 수 있음)
* **용도:** 파일 이름으로 빠르게 찾아야 할 때 유용합니다.


### 4.7.3 명령어 위치 찾기 (`which`, `whereis`)

내가 사용하는 명령어가 실제로는 어떤 경로에 있는 실행 파일인지 찾아주는 명령어들입니다.

* **`which <명령어>`:** 환경 변수 `$PATH` 에 설정된 디렉토리들을 순서대로 검색하여, 가장 먼저 찾아지는 해당 명령어의 **실행 파일 전체 경로**를 보여줍니다.

    ```bash
    which ls    # 예: /bin/ls 또는 /usr/bin/ls 출력
    which python3
    which cp
    ```

* **`whereis <명령어>`:** 명령어의 실행 파일 위치뿐만 아니라, 관련 소스 코드 파일이나 매뉴얼 페이지 파일의 위치까지 찾아서 보여줍니다. `which` 보다 좀 더 많은 정보를 제공합니다.

    ```bash
    whereis ls
    whereis bash
    ```


## 4.8 파일 내용 검색하기 (`grep` - Global Regular Expression Print)

파일 안의 내용 중에서 특정 텍스트 패턴(문자열 또는 정규 표현식)이 포함된 행을 찾아 출력하는 매우 강력하고 유용한 명령어입니다. 로그 파일 분석, 설정 파일 확인, 코드 검색 등 다양한 용도로 활용됩니다.


### 4.8.1 기본 사용법 및 옵션

* **기본 형식:** `grep "<검색 패턴>" <검색 대상 파일(들)>`

    ```bash
    grep "error" application.log       # application.log 파일에서 "error" 문자열이 포함된 행 찾기
    grep "192.168.1.100" access.log    # IP 주소 검색
    grep "user_id" *.conf             # 현재 디렉토리의 .conf 파일들에서 "user_id" 검색
    ```

* **자주 사용되는 옵션:**
  * `-i` (**i**gnore case): 대소문자를 무시하고 검색합니다.

        ```bash
        grep -i "warning" system.log
        ```

  * `-n` (line **n**umber): 검색된 행의 번호를 함께 출력합니다.

        ```bash
        grep -n "password" config.ini
        ```

  * `-v` (in**v**ert match): 패턴을 포함하지 **않는** 행들만 출력합니다.

        ```bash
        grep -v "debug" messages.log # "debug" 를 제외한 모든 행 출력
        ```

  * `-r` 또는 `-R` (**r**ecursive): 지정한 디렉토리부터 시작하여 하위 디렉토리까지 모든 파일을 대상으로 재귀적으로 검색합니다.

        ```bash
        grep -r "API_KEY" /var/www/my_app
        ```

  * `-l` (**l**ist filenames): 패턴이 포함된 행 내용을 출력하는 대신, 패턴을 포함하고 있는 **파일의 이름**만 출력합니다.

        ```bash
        grep -l "TODO" *.py
        ```

  * `-w` (**w**ord match): 패턴이 독립된 단어(공백이나 특수문자로 구분된)로 존재할 경우에만 일치하는 것으로 간주합니다. 예를 들어 `grep -w "error"` 는 "error_code" 는 제외하고 "error" 만 찾습니다.
  * `-c` (**c**ount): 패턴과 일치하는 행의 개수만 출력합니다.

`grep`은 다른 명령어의 출력 결과를 파이프(`|`)로 넘겨받아 필터링하는 용도로도 매우 많이 사용됩니다. (예: `ls -l | grep ".txt"`)


### 4.8.2 정규 표현식 맛보기 (Basic Regular Expressions)

`grep`의 진정한 힘은 단순 문자열 검색뿐만 아니라 **정규 표현식(Regular Expression, Regex)** 이라는 특별한 패턴 규칙을 사용하여 복잡한 패턴 검색을 할 수 있다는 점에 있습니다. 정규 표현식은 그 자체로 방대한 주제이지만, 몇 가지 기본적인 기호만 알아두어도 매우 유용합니다.

* `^`: 행의 **시작** 부분과 일치합니다.

    ```bash
    grep "^start" data.txt # "start"로 시작하는 행 찾기
    ```

* `$`: 행의 **끝** 부분과 일치합니다.

    ```bash
    grep "end$" data.txt   # "end"로 끝나는 행 찾기
    ```

* `.` (점): **임의의 한 문자**와 일치합니다. (줄바꿈 문자 제외)

    ```bash
    grep "f.le" data.txt   # "file", "fale", "fole" 등과 일치
    ```

* `*`: 바로 앞의 문자가 **0번 이상 반복**되는 경우와 일치합니다.

    ```bash
    grep "ab*c" data.txt   # "ac", "abc", "abbc", "abbbc" 등과 일치
    ```

* `[]`: 대괄호 안에 있는 **문자 중 하나**와 일치합니다.

    ```bash
    grep "[aeiou]" words.txt # 모음(a, e, i, o, u) 중 하나라도 포함된 행 찾기
    grep "[0-9]" data.txt   # 숫자(0~9)가 하나라도 포함된 행 찾기
    ```

정규 표현식은 처음에는 조금 어렵게 느껴질 수 있지만, 익숙해지면 텍스트 데이터를 다루는 능력이 비약적으로 향상될 것입니다. 앞으로 더 자세히 다룰 기회가 있을 것입니다.

이제 여러분은 리눅스 파일 시스템이라는 지도 위에서 길을 찾고(`pwd`, `cd`), 주변을 살피고(`ls`), 새로운 건물을 짓거나 철거하고(`mkdir`, `touch`, `rmdir`, `rm`), 물건을 옮기거나 복사하며(`cp`, `mv`), 책의 내용을 훑어보고(`cat`, `less`, `head`, `tail`), 필요한 정보나 책을 찾아내는(`find`, `locate`, `grep`) 기본적인 방법들을 모두 배웠습니다!

이 명령어들은 리눅스 사용의 근간을 이루므로, 시간을 내어 직접 터미널에서 연습해보는 것이 매우 중요합니다. 자신만의 디렉토리를 만들고, 파일을 생성하고, 복사하고, 이동하고, 안전하게 삭제하는 연습을 해보세요. 파일 내용을 확인하고, `find` 와 `grep` 으로 원하는 것을 찾아보는 연습도 잊지 마세요. 궁금한 점이 생기면 언제든지 `--help` 옵션이나 `man` 페이지를 참고하는 습관을 들이는 것이 좋습니다.

다음 Chapter 5에서는 리눅스 환경에서 파일의 내용을 직접 편집할 수 있게 해주는 강력한 텍스트 편집기인 `Vim`과 `Nano`의 사용법을 배우게 됩니다.
