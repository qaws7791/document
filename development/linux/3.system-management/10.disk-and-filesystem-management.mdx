---
title: "10. 디스크와 파일 시스템 관리"
---

이전 Chapter 9에서는 리눅스 시스템에 필요한 소프트웨어를 어떻게 설치하고 관리하는지 패키지 관리 시스템을 통해 배웠습니다. 이렇게 설치된 소프트웨어와 우리가 생성하는 데이터는 결국 **디스크(Disk)** 라는 물리적인 저장 장치 위에, **파일 시스템(Filesystem)** 이라는 논리적인 구조를 통해 저장되고 관리됩니다.

이번 챕터에서는 리눅스 시스템의 저장 공간을 효율적으로 사용하고 관리하는 데 필수적인 **디스크 및 파일 시스템 관리** 방법을 다룹니다. 디스크 공간이 얼마나 남았는지 확인하는 방법(`df`, `du`)부터 시작하여, 리눅스에서 주로 사용하는 파일 시스템의 종류와 특징을 알아봅니다. 또한, 디스크를 나누어 사용하는 파티션(Partition) 개념과 이를 시스템에 연결하는 마운트(Mount) 과정을 배우고 (`fdisk`/`parted`, `mkfs`, `mount`/`umount`, `/etc/fstab`), 파일 시스템의 유연성을 더하는 링크 파일(`ln`)에 대해서도 다시 한번 자세히 살펴봅니다. 마지막으로, 좀 더 유연하고 안정적인 디스크 관리를 위한 고급 기술인 LVM과 RAID의 기본 개념도 소개합니다.

디스크와 파일 시스템 관리는 시스템의 안정성, 성능, 데이터 보존과 직결되는 중요한 주제이므로, 기본 개념과 명령어 사용법을 잘 익혀두는 것이 좋습니다.


## 10.2 디스크 공간 확인하기 (`df`, `du`) (Checking Disk Space)

*(가장 먼저 실용적으로 필요한 디스크 사용량 확인부터 알아봅니다)*

리눅스 시스템을 운영하다 보면 디스크 공간이 부족해지는 경우가 발생할 수 있습니다. 디스크가 꽉 차면 새로운 파일을 저장할 수 없을 뿐만 아니라, 시스템 로그 기록이 중단되거나 응용 프로그램이 오작동하는 등 심각한 문제가 발생할 수 있으므로 주기적으로 디스크 사용량을 확인하고 관리하는 것이 중요합니다.


### 10.2.1 `df` (Disk Free): 전체 파일 시스템 사용량 확인

`df` 명령어는 현재 시스템에 **마운트된** 파일 시스템 각각의 전체 크기, 사용 중인 공간, 사용 가능한 공간, 사용률 등을 보여줍니다. 시스템 전체의 디스크 여유 공간을 확인할 때 사용합니다.

* **기본 사용:** `df` (단위가 1K 블록으로 표시되어 보기 불편할 수 있습니다.)
* **권장 사용법:** `df -h` (**h**uman-readable) 옵션을 사용하면 파일 크기를 KB, MB, GB 등 사람이 읽기 쉬운 단위로 보여줍니다.

    ```bash
    df -h
    ```

    출력 예시:

    ```
    Filesystem      Size  Used Avail Use% Mounted on
    /dev/sda1        50G   20G   28G  42% /
    tmpfs           3.9G     0  3.9G   0% /dev/shm
    /dev/sdb1       200G  150G   50G  75% /data
    /dev/sda2       950M  250M  650M  28% /boot
    ```

  * `Filesystem`: 파일 시스템이 위치한 장치 이름 (예: 파티션)
  * `Size`: 파일 시스템의 전체 크기
  * `Used`: 사용 중인 공간 크기
  * `Avail`: 사용 가능한 여유 공간 크기
  * `Use%`: 사용률 (%)
  * `Mounted on`: 파일 시스템이 마운트된 위치 (마운트 포인트)
* **기타 유용한 옵션:**
  * `-T`: 파일 시스템의 **타입(Type)** 을 함께 보여줍니다. (예: `ext4`, `xfs`)
  * `-i`: 디스크 공간 대신 **아이노드(Inode)** 사용량 정보를 보여줍니다. (파일/디렉토리 개수 제한 관련)


### 10.2.2 `du` (Disk Usage): 특정 디렉토리/파일 크기 확인

`du` 명령어는 특정 디렉토리나 파일이 **실제로 사용하고 있는 디스크 공간**을 추정하여 보여줍니다. 특정 디렉토리 아래에서 어떤 파일이나 하위 디렉토리가 공간을 많이 차지하는지 파악할 때 유용합니다.

* **기본 사용:** `du <경로>` (지정한 경로와 그 하위 모든 디렉토리의 크기를 K 블록 단위로 보여주어 출력이 매우 길어질 수 있습니다.)
* **권장 사용법:**
  * `du -sh <경로>`: **s**ummary(총합계), **h**uman-readable 옵션을 사용하여 지정한 경로의 **전체 크기 합계**를 사람이 읽기 쉬운 단위로 보여줍니다. 가장 많이 사용하는 형태입니다.

        ```bash
        du -sh /var/log    # /var/log 디렉토리의 전체 크기 확인
        du -sh .           # 현재 디렉토리(.)의 전체 크기 확인
        du -sh * # 현재 디렉토리 내의 각 파일/디렉토리들의 전체 크기 확인
        du -sh my_large_file.dat # 특정 파일의 크기 확인
        ```

  * `du -h <경로>`: `-s` 옵션 없이 사용하면 하위 디렉토리들의 크기를 각각 읽기 쉬운 단위로 보여줍니다.
  * `du -a <경로>`: 디렉토리뿐만 아니라 **개별 파일(All)** 의 크기까지 모두 보여줍니다.

* **팁:** `du` 명령어 결과를 크기순으로 정렬하여 가장 큰 용량을 차지하는 항목을 쉽게 찾을 수 있습니다.

    ```bash
    # 현재 디렉토리에서 한 단계 아래 항목들의 크기를 내림차순으로 정렬하여 보기
    du -h --max-depth=1 | sort -hr
    ```


## 10.1 리눅스 파일 시스템 종류 (Types of Linux Filesystems)

*(디스크 공간 확인 후, 그 공간을 관리하는 방식인 파일 시스템 종류를 알아봅니다)*

**파일 시스템(Filesystem)** 이란 운영체제가 하드 드라이브나 SSD 같은 저장 장치에 **파일을 어떻게 구성하고 저장하며, 이름을 지정하고, 찾고, 관리할 것인지에 대한 규칙과 구조**를 정의하는 방식입니다. 리눅스는 다양한 종류의 파일 시스템을 지원하며, 각각 특징과 장단점이 있습니다.

* **`ext4` (Fourth Extended Filesystem):**
  * 오랫동안 많은 리눅스 배포판(Ubuntu 등)의 **기본 파일 시스템**으로 널리 사용되어 왔습니다.
  * 이전 버전(`ext2`, `ext3`)에 비해 성능, 안정성, 용량 지원(매우 큰 파일 및 파일 시스템 지원)이 크게 향상되었습니다.
  * **저널링(Journaling)** 기능을 지원하여, 시스템 비정상 종료 시 파일 시스템 손상을 방지하고 빠른 복구를 돕습니다.
  * 매우 안정적이고 성숙했으며, 대부분의 환경에서 좋은 성능을 보여주는 **범용적인 파일 시스템**입니다.

* **`XFS` (eXtents File System):**
  * SGI에서 개발했으며, 특히 **대용량 파일 처리 및 대규모 파일 시스템 환경에서 뛰어난 성능**을 보이는 것으로 알려져 있습니다.
  * 병렬 I/O 처리 능력이 우수하여 확장성이 좋습니다.
  * RHEL/CentOS 7 이후 버전 및 관련 배포판(Rocky, Alma)의 기본 파일 시스템으로 채택되었습니다.
  * 저널링 기능을 지원하며 안정성도 뛰어납니다. 대규모 스토리지 서버나 미디어 파일 서버 등에 적합합니다.

* **`Btrfs` (B-Tree Filesystem):**
  * 비교적 최신 파일 시스템으로, **다양한 고급 기능**을 내장하고 있는 것이 특징입니다.
  * **스냅샷(Snapshots):** 특정 시점의 파일 시스템 상태를 빠르게 저장하고 복원할 수 있습니다.
  * **데이터 무결성:** 체크섬(Checksum) 기능을 통해 데이터 손상을 감지하고 일부 복구할 수 있습니다.
  * **통합 볼륨 관리:** LVM과 유사한 기능을 내장하여 여러 디스크를 유연하게 관리할 수 있습니다.
  * **내장 압축 및 RAID 지원:** 파일 시스템 레벨에서 압축 및 RAID 기능을 제공합니다.
  * Fedora Workstation, openSUSE 등의 배포판에서 기본 파일 시스템으로 채택하며 점차 사용이 늘고 있습니다. 기능이 많은 만큼 `ext4`나 `XFS`보다는 다소 복잡하게 느껴질 수 있습니다.

* **`FAT32` / `exFAT`:**
  * 주로 **Windows와의 호환성**이나 **USB 드라이브, SD 카드** 등 이동식 저장 매체에서 사용되는 파일 시스템입니다.
  * 리눅스에서도 읽고 쓸 수 있지만, 파일 권한 관리 기능이 없고 저널링을 지원하지 않아 안정성이 떨어집니다.
  * `FAT32`는 단일 파일 크기 제한(4GB)이 있지만, `exFAT`는 이 제한이 훨씬 큽니다.

* **`NTFS` (New Technology File System):**
  * **Windows**의 기본 파일 시스템입니다.
  * 리눅스에서는 `ntfs-3g` 드라이버를 통해 읽기 및 쓰기를 지원합니다. 듀얼 부팅 환경에서 Windows 파티션에 접근할 때 사용됩니다.

어떤 파일 시스템을 사용할지는 시스템의 용도, 필요한 기능, 안정성 요구 수준 등에 따라 선택할 수 있습니다. 특별한 요구사항이 없다면 배포판의 기본 파일 시스템(주로 `ext4` 또는 `XFS`)을 사용하는 것이 일반적입니다.


## 10.3 파티션과 마운트 개념 이해하기 (Understanding Partitions and Mounting)

새로운 하드 디스크나 SSD를 리눅스 시스템에 추가하여 사용하려면 몇 가지 단계를 거쳐야 합니다. 디스크를 구획(파티션)으로 나누고, 각 구획을 특정 파일 시스템으로 포맷(Format)한 다음, 이 파일 시스템을 리눅스의 전체 디렉토리 구조에 연결(마운트)해야 합니다.


### 10.3.1 디스크 파티션이란? (What are Disk Partitions?)

**파티션(Partition)** 이란 물리적인 디스크 드라이브 하나를 **논리적인 구역으로 나누는 것**을 의미합니다. 마치 하나의 큰 땅을 용도에 따라 여러 필지로 나누는 것과 같습니다.

* **파티션 사용 이유:**
  * 운영체제 영역과 사용자 데이터 영역 분리
  * 하나의 디스크에 여러 운영체제 설치 (듀얼 부팅 등)
  * 특정 파티션에만 다른 파일 시스템 사용
  * 디스크 관리 및 백업 단위 분리

* **파티션 확인 및 관리 도구:** (시스템 변경 작업이므로 `sudo` 필요, **데이터 손실 위험이 크므로 매우 주의!**)
  * **`lsblk` (List Block Devices):** 시스템의 디스크(예: `sda`, `sdb`)와 그 위의 파티션(예: `sda1`, `sda2`) 구조를 트리 형태로 보여주는 **안전한 조회용** 명령어입니다.

        ```bash
        lsblk
        ```

  * `fdisk -l`: 시스템의 모든 디스크와 파티션 정보를 목록 형태로 보여줍니다. (과거 MBR 방식 및 최신 GPT 방식 모두 지원)
  * `fdisk /dev/sdx`: (예: `fdisk /dev/sdb`) 특정 디스크(`sdx`)의 파티션 정보를 보고 **수정**할 수 있는 대화형 명령줄 도구입니다. MBR 방식에 주로 사용되며, 강력하지만 사용자 인터페이스가 다소 불편합니다. **사용 시 극도의 주의가 필요합니다.**
  * `parted /dev/sdx`: MBR과 GPT 파티션 테이블을 모두 지원하는 더 현대적인 대화형 명령줄 도구입니다. `fdisk`보다 기능이 많습니다. `(parted)` 프롬프트에서 `print` 명령으로 파티션 정보를 볼 수 있습니다. 역시 **매우 주의해서 사용해야 합니다.**
  * `gparted`: GUI 환경이 있다면 사용할 수 있는 **그래픽 파티션 편집기**입니다. 명령줄 도구보다 직관적이지만, 파티션 작업 자체의 위험성은 동일합니다.

* **MBR vs GPT:** (간략 소개)
  * **MBR (Master Boot Record):** 오래된 파티션 방식. 최대 2TB 디스크, 최대 4개의 주(Primary) 파티션 제한이 있습니다.
  * **GPT (GUID Partition Table):** 현대적인 파티션 방식. 2TB 이상의 디스크 지원, 훨씬 많은 파티션 생성 가능(기본 128개). 요즘 대부분의 시스템은 GPT를 사용합니다.


### 10.3.2 파일 시스템 생성 (포맷팅) (`mkfs` - Make Filesystem)

파티션을 나누었다면, 해당 파티션에 파일을 저장할 수 있도록 특정 **파일 시스템으로 포맷(Format)** 해야 합니다. 이 과정을 통해 파일 시스템의 구조(아이노드 테이블, 디렉토리 구조 등)가 파티션 위에 생성됩니다. **포맷 과정은 해당 파티션의 모든 데이터를 영구적으로 삭제합니다!**

* `mkfs` (Make Filesystem) 명령어는 실제로는 특정 파일 시스템을 만드는 도구들(예: `mkfs.ext4`, `mkfs.xfs`, `mkfs.btrfs`)을 연결해주는 역할을 합니다.
* **형식:** `sudo mkfs -t <파일시스템 타입> /dev/sdxN` 또는 `sudo mkfs.<파일시스템 타입> /dev/sdxN`
  * `<파일시스템 타입>`: `ext4`, `xfs`, `btrfs` 등
  * `/dev/sdxN`: 포맷할 파티션의 장치 이름 (예: `/dev/sdb1`)

* **예시:**

    ```bash
    # /dev/sdb1 파티션을 ext4 파일 시스템으로 포맷
    sudo mkfs.ext4 /dev/sdb1

    # /dev/sdc1 파티션을 xfs 파일 시스템으로 포맷
    sudo mkfs.xfs /dev/sdc1
    ```


### 10.3.3 마운트와 언마운트 (`mount`, `umount`)

포맷된 파일 시스템을 사용하려면, 리눅스 시스템의 **디렉토리 구조 내의 특정 지점(마운트 포인트)에 연결**해야 하는데, 이 과정을 **마운트(Mount)** 라고 합니다. 마운트되어야만 해당 파일 시스템에 접근하여 파일을 읽고 쓸 수 있습니다.

* **마운트 포인트 (Mount Point):** 파일 시스템을 연결할 디렉토리입니다. 일반적으로 비어 있는 디렉토리를 미리 만들어 사용합니다. (예: `/mnt/mydata`, `/media/usbdisk`, `/data`)
* **`mount` 명령어:**
  * `mount`: 옵션 없이 실행하면 현재 시스템에 마운트된 모든 파일 시스템 목록을 보여줍니다.
  * `sudo mount <장치명> <마운트 포인트>`: 지정한 장치(파티션)의 파일 시스템을 지정한 마운트 포인트 디렉토리에 연결합니다. 리눅스는 보통 파일 시스템 타입을 자동으로 감지합니다.

        ```bash
        sudo mkdir /mnt/mydata  # 마운트 포인트 디렉토리 생성
        sudo mount /dev/sdb1 /mnt/mydata # /dev/sdb1 을 /mnt/mydata 에 마운트
        ```

  * `sudo mount -t <파일시스템 타입> <장치명> <마운트 포인트>`: 파일 시스템 타입을 명시적으로 지정하여 마운트합니다.
  * `sudo mount -o <옵션들> ...`: 마운트 시 적용할 옵션들을 지정합니다. (예: `ro`=읽기 전용, `rw`=읽기/쓰기(기본값))

* **`umount` 명령어 (주의: unmount 아님!):**
  * 마운트된 파일 시스템을 시스템 디렉토리 구조에서 **분리(Unmount)** 합니다.
  * **중요:** 해당 파일 시스템이 **사용 중(busy)** 일 때는 언마운트할 수 없습니다. (예: 어떤 사용자가 해당 마운트 포인트 안에서 작업 중이거나, 해당 파일 시스템 내의 파일이 열려 있는 경우). 먼저 사용 중인 상태를 해제해야 합니다.
  * **형식:** `sudo umount <장치명>` 또는 `sudo umount <마운트 포인트>`

        ```bash
        sudo umount /dev/sdb1
        # 또는
        sudo umount /mnt/mydata
        ```


### 10.3.4 부팅 시 자동 마운트 설정 (`/etc/fstab`)

`mount` 명령어를 이용한 마운트는 시스템을 재부팅하면 사라집니다. 시스템이 부팅될 때마다 특정 파일 시스템이 **자동으로 마운트되도록 하려면 `/etc/fstab` (File System Table)** 파일에 해당 정보를 등록해야 합니다.

**!!! 경고: `/etc/fstab` 파일을 잘못 수정하면 시스템이 부팅되지 않을 수 있습니다! 수정 전에는 반드시 백업 (`sudo cp /etc/fstab /etc/fstab.bak`) 하고, 내용을 정확히 확인해야 합니다. !!!**

`/etc/fstab` 파일은 각 줄마다 하나의 파일 시스템 마운트 정보를 담고 있으며, 총 6개의 필드가 공백 또는 탭으로 구분됩니다.

| 필드 순서 | 필드 이름       | 설명                                                                                                                                  | 예시                              |
| :-------- | :-------------- | :------------------------------------------------------------------------------------------------------------------------------------ | :-------------------------------- |
| 1         | **Device** | 마운트할 장치 또는 파일 시스템. 장치명(`/dev/sdb1`)보다는 **UUID**(고유 식별자) 사용 권장! (`blkid` 명령어로 확인) 또는 LABEL 도 가능. | `UUID=123e4567-e89b-12d3-a456-…` |
| 2         | **Mount Point** | 마운트할 디렉토리 경로. 반드시 미리 생성되어 있어야 함.                                                                                 | `/data`                           |
| 3         | **Type** | 파일 시스템 타입 (`ext4`, `xfs`, `btrfs`, `ntfs-3g`, `vfat`, `swap`, `auto` 등)                                                       | `ext4`                            |
| 4         | **Options** | 마운트 옵션 (쉼표로 구분). `defaults` (일반적인 기본 옵션 집합), `rw`(읽기쓰기), `ro`(읽기전용), `user`(일반사용자 마운트허용), `noauto`(자동마운트 안함), `nofail`(부팅 시 장치 없어도 오류 무시) 등 | `defaults`                        |
| 5         | **Dump** | `dump` 유틸리티 사용 여부 (보통 `0` = 사용 안 함)                                                                                       | `0`                               |
| 6         | **Pass** | 부팅 시 `fsck` 파일 시스템 검사 순서. `0`=검사 안 함, `1`=루트 파일 시스템(가장 먼저), `2`=그 외 검사할 파일 시스템                     | `2`                               |

* **UUID 확인:** `sudo blkid /dev/sdb1` 등으로 특정 파티션의 UUID를 확인할 수 있습니다. UUID를 사용하면 디스크 순서가 바뀌어도 정확히 해당 파티션을 찾아 마운트할 수 있어 안정적입니다.
* **/etc/fstab 항목 예시:**

  ```fstab
  # <device>                                <mount point>  <type>  <options>   <dump> <pass>
  UUID=123e4567-e89b-12d3-a456-426614174000 /data          ext4    defaults    0      2
  /dev/sdc1                                 /backup        xfs     defaults,noatime 0      0
  ```

* **수정 후 테스트:** `/etc/fstab` 파일을 수정한 후에는 **재부팅하기 전에 반드시 `sudo mount -a` 명령을 실행**하여 `fstab` 파일에 오류가 없는지, 새로 추가한 항목이 제대로 마운트되는지 확인해야 합니다. 오류가 발생하면 시스템이 부팅되지 않을 수 있으므로 즉시 수정해야 합니다.


## 10.4 링크 파일 이해하기 (하드 링크 vs 심볼릭 링크) (Understanding Link Files: Hard vs. Symbolic)

리눅스에서는 하나의 파일이나 디렉토리를 여러 위치에서 참조할 수 있도록 하는 **링크(Link)** 기능을 제공합니다. 링크에는 하드 링크와 심볼릭 링크 두 종류가 있습니다.

* **하드 링크 (Hard Link):**
  * **개념:** 원본 파일과 **동일한 아이노드(inode, 파일 시스템에서 파일을 식별하는 고유 번호)** 를 가리키는 또 다른 파일 이름을 만드는 것입니다. 즉, 동일한 데이터 내용에 대해 여러 개의 파일 이름이 존재하는 방식입니다.
  * **생성:** `ln <원본 파일> <하드 링크 이름>`
  * **특징:**
    * 원본 파일과 하드 링크는 내용뿐만 아니라 아이노드 번호까지 동일합니다. (`ls -li` 로 아이노드 확인 가능)
    * 원본 파일을 삭제해도 하드 링크가 남아있다면 파일 데이터는 삭제되지 않습니다. 모든 하드 링크가 삭제되어야 데이터가 실제로 삭제됩니다 (`ls -l` 의 링크 수가 0이 될 때).
    * **다른 파일 시스템(파티션) 간에는 하드 링크를 만들 수 없습니다.** (아이노드는 파일 시스템 내에서만 고유하기 때문)
    * **디렉토리에 대해서는 하드 링크를 만들 수 없습니다.** (일반적으로 시스템에서 제한)
  * **비유:** 하나의 방에 문(파일 이름)을 여러 개 만드는 것과 같습니다. 어떤 문으로 들어가든 같은 방입니다.

* **심볼릭 링크 (Symbolic Link / Soft Link / Symlink):**
  * **개념:** 원본 파일이나 디렉토리의 **경로(Path) 정보**를 담고 있는 **특수한 파일**을 만드는 것입니다. Windows의 '바로 가기'와 매우 유사합니다.
  * **생성:** `ln -s <원본 파일 또는 디렉토리 경로> <심볼릭 링크 이름>` (**`-s` 옵션 필수!**)
  * **특징:**
    * 심볼릭 링크 파일 자체는 원본의 경로 정보만 담고 있는 작은 파일입니다. 아이노드 번호도 원본과 다릅니다.
    * 심볼릭 링크 파일을 삭제해도 원본 파일/디렉토리에는 아무런 영향이 없습니다.
    * **원본 파일/디렉토리를 삭제하면 심볼릭 링크는 "깨진 링크(broken link)" 상태**가 되어 작동하지 않습니다.
    * **다른 파일 시스템 간에도 심볼릭 링크를 만들 수 있습니다.**
    * **디렉토리에 대해서도 심볼릭 링크를 만들 수 있습니다.**
    * `ls -l` 로 보면 파일 종류가 `l` 로 표시되고, 이름 뒤에 `-> <원본 경로>` 가 함께 표시됩니다.
  * **비유:** 특정 장소를 가리키는 표지판(심볼릭 링크)과 같습니다. 표지판을 없애도 장소는 그대로 있지만, 장소가 사라지면 표지판은 쓸모없어집니다.

**일반적으로 유연성이 더 높은 심볼릭 링크가 하드 링크보다 더 널리 사용됩니다.**


## 10.5 [고급] LVM(Logical Volume Manager) 개념 소개 (Advanced: Introduction to LVM)

LVM은 전통적인 디스크 파티션 방식보다 **더 유연하게 디스크 공간을 관리**할 수 있도록 해주는 기술입니다. 디스크나 파티션들을 하나의 큰 저장 공간 풀(Pool)로 묶은 다음, 필요한 크기만큼 논리적인 볼륨(가상 파티션)을 만들어 사용하는 방식입니다.

* **주요 개념:**
  * **물리 볼륨 (Physical Volume, PV):** LVM에서 사용하도록 준비된 물리 디스크 또는 파티션입니다. (`pvcreate` 명령으로 생성)
  * **볼륨 그룹 (Volume Group, VG):** 하나 이상의 PV들을 묶어서 만드는 저장 공간 풀입니다. 마치 하나의 거대한 가상 디스크처럼 취급됩니다. (`vgcreate` 명령으로 생성)
  * **논리 볼륨 (Logical Volume, LV):** VG라는 저장 공간 풀에서 필요한 만큼 할당받아 생성하는 논리적인 파티션입니다. 사용자는 이 LV를 일반 파티션처럼 포맷(`mkfs`)하고 마운트하여 사용합니다. (`lvcreate` 명령으로 생성)

* **LVM의 장점:**
  * **유연한 크기 조절:** LV의 크기를 (파일 시스템이 지원한다면) 비교적 쉽게 늘리거나 줄일 수 있습니다.
  * **디스크 확장 용이:** VG에 새로운 PV(디스크)를 추가하여 전체 저장 공간 풀을 확장하고, 기존 LV의 크기를 늘릴 수 있습니다. (종종 시스템 재부팅 없이 가능)
  * **스냅샷:** LV의 특정 시점 상태를 저장하는 스냅샷을 생성할 수 있어 백업 등에 유용합니다.
  * **여러 디스크에 걸친 볼륨 생성:** 하나의 LV가 여러 물리 디스크에 걸쳐 존재할 수 있습니다.

LVM은 약간의 복잡성이 추가되지만, 저장 공간을 유연하게 관리해야 하는 서버 환경 등에서 매우 유용하게 사용됩니다. 주요 명령어로는 `pvcreate`, `vgcreate`, `lvcreate`, `lvextend`, `lvreduce`, `pvdisplay`, `vgdisplay`, `lvdisplay` 등이 있습니다.


## 10.6 [고급] RAID 개념 소개 (Advanced: Introduction to RAID)

**RAID(Redundant Array of Independent Disks)** 는 여러 개의 물리적인 디스크 드라이브를 **하나의 논리적인 유닛으로 묶어서 사용하는 기술**입니다. 주된 목적은 **성능 향상(Performance)** 또는 **데이터 안정성/중복성(Redundancy)** 확보, 혹은 이 둘의 조합입니다.

* **주요 RAID 레벨:**
  * **RAID 0 (스트라이핑 - Striping):** 데이터를 여러 디스크에 분산하여 동시에 읽고 씁니다. **성능(속도)은 향상**되지만, **데이터 중복성이 전혀 없어** 디스크 중 하나만 고장 나도 전체 데이터가 손실됩니다. (최소 2개 디스크 필요)
  * **RAID 1 (미러링 - Mirroring):** 데이터를 두 개 이상의 디스크에 **완전히 동일하게 복제**하여 저장합니다. **데이터 안정성이 매우 높습니다.** (디스크 하나가 고장 나도 다른 디스크에 데이터가 그대로 있음). 하지만 사용 가능한 용량은 전체 디스크 용량의 절반(2개 기준)이 됩니다. (최소 2개 디스크 필요)
  * **RAID 5 (분산 패리티 스트라이핑 - Striping with Distributed Parity):** 데이터와 함께 패리티(오류 검출 및 복구 정보)를 여러 디스크에 분산 저장합니다. **성능과 안정성의 균형**을 제공하며, **디스크 하나가 고장 나도 데이터를 복구**할 수 있습니다. RAID 1보다 공간 효율성이 좋습니다. (최소 3개 디스크 필요)
  * **RAID 6 (이중 분산 패리티 스트라이핑 - Striping with Dual Distributed Parity):** RAID 5와 유사하지만 패리티 정보를 이중으로 저장하여 **동시에 디스크 2개가 고장 나도 데이터를 복구**할 수 있습니다. 안정성이 더 높지만 RAID 5보다 공간 효율성과 쓰기 성능은 약간 낮습니다. (최소 4개 디스크 필요)
  * **RAID 10 (1+0):** 미러링된 디스크들을 다시 스트라이핑으로 묶는 방식입니다. **성능과 안정성이 모두 우수**하지만, 최소 4개의 디스크가 필요하고 공간 효율성은 50%입니다.

* **소프트웨어 RAID vs 하드웨어 RAID:**
  * **소프트웨어 RAID:** 운영체제(리눅스의 경우 `mdadm` 유틸리티 사용)가 RAID 기능을 직접 처리합니다. 추가 하드웨어 비용이 들지 않고 유연하지만, OS 부하가 약간 증가할 수 있습니다.
  * **하드웨어 RAID:** 전용 RAID 컨트롤러 카드가 RAID 연산을 처리합니다. OS 부하가 적고 성능이 우수할 수 있지만, 추가 비용이 들고 특정 하드웨어에 종속될 수 있습니다.

RAID는 데이터의 중요도, 성능 요구 사항, 예산 등을 고려하여 적절한 레벨을 선택해야 합니다.


## 결론

이번 챕터에서는 리눅스 시스템의 저장 공간을 관리하는 다양한 측면을 살펴보았습니다. `df` 와 `du` 명령어로 디스크 사용량을 확인하는 실용적인 방법부터 시작하여, `ext4`, `XFS`, `Btrfs` 등 다양한 리눅스 파일 시스템의 특징을 이해했습니다.

또한 디스크를 나누는 파티션 개념과 `lsblk`, `fdisk`, `parted` 같은 도구, 파일 시스템을 생성하는 `mkfs`, 그리고 이를 디렉토리 구조에 연결하는 `mount` 와 `umount`, 부팅 시 자동 연결을 위한 `/etc/fstab` 설정 방법까지 중요한 과정들을 다루었습니다. 특히 `/etc/fstab` 수정 시에는 UUID 사용과 `-a` 옵션을 통한 테스트의 중요성을 강조했습니다. 파일 시스템의 유연성을 더하는 하드 링크와 심볼릭 링크의 차이점도 명확히 했습니다.

마지막으로 고급 디스크 관리 기술인 LVM의 유연성과 RAID의 성능/안정성 향상 개념을 소개하여 앞으로 더 복잡한 스토리지 환경을 접할 때 도움이 될 수 있도록 했습니다.

디스크와 파일 시스템 관리는 시스템 운영의 기초이면서도 데이터 손실과 직결될 수 있는 중요한 작업이므로, 명령어를 사용할 때 항상 신중하고 내용을 정확히 이해하려는 노력이 필요합니다.

다음 Chapter 11에서는 다시 쉘(Shell)의 세계로 돌아가, 앞에서 배운 명령어들을 조합하고 프로그래밍적인 요소를 더하여 반복적인 작업을 자동화하는 강력한 기술인 **쉘 스크립팅(Shell Scripting)** 의 기초를 배우게 됩니다.
