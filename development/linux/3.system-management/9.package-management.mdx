---
title: "9. 패키지 관리"
---

이전 Chapter 8에서는 리눅스 시스템에서 실행 중인 프로그램, 즉 프로세스를 관리하는 방법을 배웠습니다. 그렇다면 이러한 프로그램들, 즉 **소프트웨어**는 리눅스 시스템에 어떻게 설치하고 관리할까요? 윈도우에서는 `.exe` 파일을 다운로드하여 설치하고, macOS에서는 `.dmg` 파일을 이용하거나 App Store를 사용하는 것이 일반적입니다. 리눅스에도 물론 비슷한 방식이 있지만, 훨씬 더 체계적이고 강력한 **패키지 관리(Package Management)** 시스템을 주로 사용합니다.

소프트웨어는 종종 다른 소프트웨어 라이브러리나 도구들에 의존하는 경우가 많습니다. 예를 들어, 이미지 편집 프로그램을 설치하려면 그래픽 처리 라이브러리가 필요할 수 있습니다. 이러한 의존성(Dependency)을 사용자가 일일이 확인하고 수동으로 설치하는 것은 매우 복잡하고 오류가 발생하기 쉬운 작업입니다.

리눅스의 패키지 관리 시스템은 이러한 소프트웨어 설치, 업데이트, 의존성 관리, 삭제 과정을 자동화하여 쉽고 안전하게 만들어주는 핵심적인 기능입니다. 마치 스마트폰의 앱 스토어나 프로그래밍 언어의 패키지 매니저(예: Python의 `pip`, Node.js의 `npm`)와 유사한 역할을 합니다.

이번 Chapter 9에서는 리눅스 패키지 관리의 기본 개념을 이해하고, 주요 리눅스 배포판 계열(Debian/Ubuntu, Red Hat/Fedora)에서 사용하는 대표적인 패키지 관리 도구(`apt`, `dnf`/`yum`)의 사용법을 익힙니다. 또한 패키지들이 어디에서 오는지(저장소), 그리고 고급 사용자를 위한 소스 코드 직접 컴파일 및 설치 방법까지 간략하게 알아보겠습니다.


## 9.1 패키지 매니저: 쉽고 안전한 소프트웨어 관리 (Package Manager: Easy and Safe Software Management)

리눅스에서 소프트웨어는 일반적으로 **패키지(Package)** 라는 단위로 묶여서 배포됩니다.

* **패키지란?** 소프트웨어를 실행하는 데 필요한 모든 것을 담고 있는 하나의 묶음 파일입니다. 보통 컴파일된 프로그램 실행 파일, 관련 라이브러리 파일, 설정 파일 예시, 도움말 문서, 그리고 패키지 자체에 대한 정보(이름, 버전, 의존성 목록 등)인 **메타데이터(Metadata)** 를 포함합니다. 대표적인 패키지 형식으로는 Debian/Ubuntu 계열의 `.deb` 파일과 Red Hat/Fedora/SUSE 계열의 `.rpm` 파일이 있습니다.

* **패키지 매니저(Package Manager)란?** 이러한 패키지들을 관리(설치, 업데이트, 삭제 등)하는 시스템 소프트웨어입니다. 사용자가 직접 복잡한 과정을 처리할 필요 없이, 간단한 명령어를 통해 소프트웨어를 관리할 수 있게 해줍니다.

**패키지 매니저의 주요 기능 및 장점:**

1. **의존성 관리 (Dependency Management):** 패키지 매니저의 가장 강력한 기능 중 하나입니다. 특정 패키지를 설치할 때, 해당 패키지가 필요로 하는 다른 라이브러리나 프로그램들(의존성)을 자동으로 파악하여 함께 설치해줍니다. 반대로 패키지를 삭제할 때는, 더 이상 필요 없어진 의존성 패키지들을 찾아서 함께 제거할 수도 있습니다.
2. **일관성 있는 설치 및 관리 (Consistency):** 소프트웨어가 시스템의 표준적인 위치(예: `/usr/bin`, `/etc`)에 설치되도록 관리하여 시스템 구조의 일관성을 유지하고 다른 프로그램과의 충돌을 방지합니다.
3. **간편한 업데이트 (Easy Updates):** 단 몇 개의 명령만으로 시스템에 설치된 모든 소프트웨어(또는 특정 소프트웨어)를 최신 버전으로 안전하게 업데이트할 수 있습니다. 보안 패치나 새로운 기능 업데이트가 매우 용이해집니다.
4. **깨끗한 제거 (Clean Removal):** 패키지를 삭제할 때 관련 파일들을 깔끔하게 제거해줍니다. (`purge` 옵션을 사용하면 설정 파일까지 제거 가능)
5. **신뢰성 및 보안 (Reliability & Security):** 패키지 매니저는 일반적으로 리눅스 배포판 제작팀이나 커뮤니티가 관리하는 공식 **저장소(Repository)** 에서 패키지를 가져옵니다. 이 저장소의 패키지들은 해당 배포판 환경에서 테스트되고 검증되었으며, 악성 코드가 포함될 위험이 인터넷에서 임의의 파일을 다운로드하는 것보다 훨씬 적습니다.


## 9.4 패키지 저장소(Repository) 개념 이해 (Understanding Package Repositories)

*(패키지 매니저의 작동 방식을 이해하는 데 중요하므로 먼저 설명합니다)*

패키지 매니저는 어디서 소프트웨어 패키지들을 가져올까요? 바로 **패키지 저장소(Repository)** 에서 가져옵니다.

* **저장소(Repository)란?** 특정 리눅스 배포판과 버전을 위해 특별히 컴파일되고 패키징된 수천, 수만 개의 소프트웨어 패키지들과 그 메타데이터(패키지 목록, 버전 정보, 의존성 정보 등)를 모아놓은 **원격 서버** (또는 서버들의 네트워크) 입니다.
* **작동 방식:**
    1. 사용자의 리눅스 시스템에 설치된 패키지 매니저는 설정 파일(예: `/etc/apt/sources.list`, `/etc/yum.repos.d/`)에 등록된 저장소들의 주소를 알고 있습니다.
    2. `apt update` 나 `dnf check-update` 같은 명령을 실행하면, 패키지 매니저는 이 저장소들에 접속하여 최신 패키지 목록 정보(메타데이터)를 다운로드하여 로컬 캐시에 저장합니다.
    3. 사용자가 `apt install` 이나 `dnf install` 명령으로 특정 패키지 설치를 요청하면, 패키지 매니저는 로컬 캐시의 메타데이터를 참조하여 필요한 패키지 파일들과 그 의존성 패키지 파일들을 저장소 서버에서 다운로드합니다.
    4. 다운로드한 패키지 파일들을 이용하여 시스템에 소프트웨어를 설치합니다.
* **중요성:** 저장소는 사용자가 자신의 리눅스 버전과 호환되는, 검증된 소프트웨어를 쉽게 찾고 설치할 수 있도록 보장합니다. 배포판 공식 저장소 외에도, 특정 소프트웨어나 최신 버전을 제공하는 **서드파티(Third-party) 저장소**를 추가할 수도 있지만, 이때는 해당 저장소의 신뢰도를 주의 깊게 확인해야 합니다.


## 9.2 Debian/Ubuntu 계열 (`apt`, `dpkg`) (Debian/Ubuntu Family: `apt`, `dpkg`)

Debian, Ubuntu, Linux Mint 등 Debian 계열 배포판에서는 주로 **`apt` (Advanced Package Tool)** 를 사용하여 패키지를 관리합니다. (과거에는 `apt-get`, `apt-cache` 명령어를 분리해서 사용했지만, 최신 버전에서는 `apt` 명령어 하나로 통합되어 더 편리해졌습니다. `apt` 사용을 권장합니다.)

`apt`는 사용자를 위한 고수준 명령어 도구이며, 실제 `.deb` 패키지 파일을 처리하는 저수준 작업은 **`dpkg` (Debian Package)** 라는 프로그램이 담당합니다. `apt`는 `dpkg`를 내부적으로 사용하여 의존성 관리 등 복잡한 작업을 처리해줍니다.

**자주 사용하는 `apt` 명령어:** (설치, 삭제, 업그레이드 등 시스템 변경 작업은 `sudo` 필요)


### 9.2.1 `sudo apt update`: 패키지 목록 갱신

* 저장소에서 **최신 패키지 목록 정보(메타데이터)를 다운로드**하여 로컬 캐시를 업데이트합니다.
* **새 패키지를 설치하거나 시스템을 업그레이드하기 전에 반드시 실행**해야 최신 정보를 반영할 수 있습니다.
* 이 명령어 자체는 실제 소프트웨어를 설치하거나 업그레이드하지 않습니다.

```bash
sudo apt update
```


### 9.2.2 `sudo apt upgrade`: 설치된 패키지 업그레이드

* `apt update`로 갱신된 정보를 바탕으로, 현재 시스템에 설치된 패키지들 중 **업그레이드 가능한 모든 패키지를 최신 버전으로 업그레이드**합니다.
* 의존성 문제가 발생하지 않는 선에서 업그레이드를 진행합니다.

```bash
sudo apt upgrade
```

* `sudo apt full-upgrade`: `upgrade`와 유사하지만, 시스템 전체 버전 업그레이드 등 더 큰 변화가 있을 때, 필요하다면 기존 패키지를 삭제하면서까지 업그레이드를 진행할 수 있습니다. 일반적인 업데이트에는 `upgrade`를 사용하는 것이 더 안전할 수 있습니다.


### 9.2.3 `sudo apt install <패키지명>`: 새 패키지 설치

* 지정한 이름의 패키지를 저장소에서 찾아 **설치**합니다. 이때 필요한 **의존성 패키지들도 자동으로 함께 설치**됩니다.
* 여러 패키지를 동시에 설치할 수도 있습니다.

```bash
sudo apt install nginx          # nginx 웹 서버 설치
sudo apt install git curl wget  # 여러 패키지 동시 설치
```


### 9.2.4 `apt search <검색어>` 및 `apt show <패키지명>`: 패키지 검색 및 정보 확인

* `apt search <검색어>`: 패키지 이름이나 설명에 `<검색어>`가 포함된 패키지들을 **검색**하여 보여줍니다.
* `apt show <패키지명>`: 특정 패키지의 **상세 정보**(버전, 설명, 크기, 의존성 등)를 보여줍니다.

```bash
apt search browser      # 'browser' 관련 패키지 검색
apt show firefox      # firefox 패키지 상세 정보 보기
```


### 9.2.5 `sudo apt remove <패키지명>` 및 `sudo apt purge <패키지명>`: 패키지 삭제

* `sudo apt remove <패키지명>`: 지정한 패키지를 **삭제**합니다. 하지만 **설정 파일들은 시스템에 남겨둘 수 있습니다.**
* `sudo apt purge <패키지명>`: 패키지를 **삭제**하면서 관련된 **설정 파일들까지 모두 깨끗하게 삭제**합니다.

```bash
sudo apt remove nginx
sudo apt purge old-software
```

* `sudo apt autoremove`: 다른 패키지를 설치할 때 의존성 때문에 함께 설치되었지만, 이제는 **더 이상 필요 없어진 패키지들을 자동으로 찾아서 삭제**해줍니다. 시스템을 정리하는 데 유용합니다.


### 9.2.6 `dpkg` 기본 사용법 (저수준 관리)

`dpkg`는 `.deb` 파일을 직접 다루는 저수준 도구입니다. 보통은 `apt`를 사용하는 것이 편리하지만, 가끔 직접 사용할 때가 있습니다.

* `sudo dpkg -i <패키지파일.deb>`: 다운로드 받은 `.deb` 파일을 **설치(Install)** 합니다. **주의: 의존성 문제를 자동으로 해결해주지 않습니다!** 만약 의존성 문제가 발생하면 `sudo apt --fix-broken install` 명령으로 해결을 시도할 수 있습니다.
* `dpkg -l | grep <검색어>`: 설치된 패키지 **목록(List)** 중 검색어에 맞는 것을 보여줍니다.
* `dpkg -s <패키지명>`: 설치된 패키지의 **상태/정보(Status)** 를 보여줍니다.
* `sudo dpkg -r <패키지명>`: 패키지를 **제거(Remove)** 합니다. (`apt remove` 와 유사)
* `sudo dpkg -P <패키지명>`: 패키지와 설정 파일을 모두 **완전히 제거(Purge)** 합니다. (`apt purge` 와 유사)


## 9.3 Red Hat/CentOS/Fedora 계열 (`dnf`, `yum`, `rpm`) (Red Hat/CentOS/Fedora Family: `dnf`, `yum`, `rpm`)

Fedora, RHEL (Red Hat Enterprise Linux) 8 이상, CentOS Stream 8 이상, Rocky Linux, AlmaLinux 등 Red Hat 계열 배포판에서는 **`dnf` (Dandified YUM)** 를 주력 패키지 매니저로 사용합니다. `dnf`는 이전 버전(RHEL 7, CentOS 7 등)에서 사용되던 **`yum` (Yellowdog Updater, Modified)** 을 개선한 것으로, 더 나은 성능과 의존성 해결 능력을 제공합니다. (대부분의 `yum` 명령어는 `dnf` 에서도 호환되지만, 최신 시스템에서는 `dnf` 사용을 권장합니다.)

`dnf`와 `yum` 모두 내부적으로는 `.rpm` (RPM Package Manager) 패키지 파일을 다루는 저수준 도구인 **`rpm`** 을 사용합니다.

**자주 사용하는 `dnf` 명령어:** (시스템 변경 작업은 `sudo` 필요)


### 9.3.1 `sudo dnf check-update`: 업데이트 가능 목록 확인

* 설치된 패키지 중 업데이트 가능한 패키지가 있는지 **확인**합니다. (`apt update` 와는 약간 다르게, 로컬 목록 갱신보다는 원격 저장소와 비교하여 업데이트 가능 여부를 알려주는 데 중점을 둡니다.)

```bash
sudo dnf check-update
```


### 9.3.2 `sudo dnf update` 또는 `sudo dnf upgrade`: 설치된 패키지 업데이트

* 현재 시스템에 설치된 모든 패키지를 사용 가능한 **최신 버전으로 업데이트**합니다. (`dnf`에서는 `update`와 `upgrade`가 거의 동일하게 작동합니다.)

```bash
sudo dnf update
# 또는
sudo dnf upgrade
```


### 9.3.3 `sudo dnf install <패키지명>`: 새 패키지 설치

* 지정한 이름의 패키지를 저장소에서 찾아 **설치**하고, 필요한 **의존성 패키지들도 자동으로 함께 설치**합니다.

```bash
sudo dnf install httpd       # Apache 웹 서버 설치 (RHEL 계열에서는 httpd 라는 이름 사용)
sudo dnf install git vim     # 여러 패키지 동시 설치
```


### 9.3.4 `dnf search <검색어>` 및 `dnf info <패키지명>`: 패키지 검색 및 정보 확인

* `dnf search <검색어>`: 저장소에서 `<검색어>`가 포함된 패키지를 **검색**합니다.
* `dnf info <패키지명>`: 특정 패키지의 **상세 정보**를 보여줍니다.

```bash
dnf search mariadb     # mariadb 관련 패키지 검색
dnf info mariadb-server # mariadb-server 패키지 상세 정보 보기
```


### 9.3.5 `sudo dnf remove <패키지명>`: 패키지 삭제

* 지정한 패키지를 **삭제**합니다. 더 이상 필요 없는 의존성 패키지들도 함께 제거될 수 있습니다.

```bash
sudo dnf remove httpd
```

* `sudo dnf autoremove`: 명시적으로 설치되지 않았고 더 이상 다른 패키지의 의존성으로도 필요하지 않은 패키지들을 **자동으로 찾아서 삭제**합니다.

**기타 유용한 `dnf` 명령어:**

* `dnf list installed`: 설치된 모든 패키지 목록 보기
* `dnf list available`: 저장소에서 설치 가능한 모든 패키지 목록 보기
* `dnf provides <파일경로 또는 기능>`: 특정 파일이나 기능을 어떤 패키지가 제공하는지 찾아줍니다. (예: `dnf provides /usr/sbin/sshd`)

**(참고) `yum` 명령어:** CentOS 7 등 구형 시스템에서는 위 명령어들에서 `dnf` 대신 `yum`을 사용하면 됩니다. (예: `sudo yum update`, `sudo yum install httpd`)


### 9.3.6 `rpm` 기본 사용법 (저수준 관리)

`rpm`은 `.rpm` 파일을 직접 다루는 저수준 도구입니다. `dnf`나 `yum`을 사용하는 것이 일반적으로 더 편리하고 안전합니다.

* `sudo rpm -i <패키지파일.rpm>` 또는 `sudo rpm -ivh <패키지파일.rpm>`: 다운로드 받은 `.rpm` 파일을 **설치(Install)** 합니다. (`-v`: 상세 정보 표시, `-h`: 설치 진행 상태 해시 마크 표시). **주의: 의존성을 자동으로 해결하지 못합니다!** 가능하다면 `sudo dnf install <패키지파일.rpm>` 을 사용하면 `dnf`가 로컬 파일에 대한 의존성 해결을 시도합니다.
* `sudo rpm -U <패키지파일.rpm>`: 시스템에 이미 설치된 패키지를 새 `.rpm` 파일로 **업그레이드(Upgrade)** 합니다. (설치되어 있지 않으면 설치)
* `rpm -q <패키지명>`: 특정 패키지가 설치되어 있는지 **질의(Query)** 하고 버전을 보여줍니다.
* `rpm -qa | grep <검색어>`: 설치된 **모든(All)** 패키지를 질의하고 검색어로 필터링합니다.
* `rpm -qi <패키지명>`: 설치된 패키지의 상세 **정보(Info)** 를 보여줍니다.
* `rpm -ql <패키지명>`: 설치된 패키지에 포함된 **파일 목록(List)** 을 보여줍니다.
* `sudo rpm -e <패키지명>`: 설치된 패키지를 **삭제(Erase)** 합니다. **주의: 의존성 관계를 고려하지 않고 삭제할 수 있어 시스템 문제를 일으킬 수 있습니다!** 가능하면 `dnf remove` 를 사용하세요.


## 9.5 [고급] 소스 코드 컴파일 및 설치 (Advanced: Compiling and Installing from Source Code)

리눅스 배포판의 공식 저장소에 원하는 소프트웨어가 없거나, 가장 최신 버전을 사용하고 싶거나, 특별한 컴파일 옵션을 적용해야 할 경우, 소프트웨어의 **소스 코드(Source Code)** 를 직접 다운로드하여 **컴파일(Compile)** 하고 설치하는 방법이 있습니다. 이 방법은 패키지 관리자를 사용하는 것보다 훨씬 복잡하며 초보자에게는 권장되지 않습니다.

**일반적인 과정 (소프트웨어마다 다를 수 있음):**

1. **소스 코드 다운로드:** 소프트웨어 공식 웹사이트나 GitHub 등에서 소스 코드가 담긴 압축 파일(주로 `.tar.gz` 또는 `.tar.bz2` 형식)을 다운로드합니다.
2. **압축 해제:** 다운로드한 파일의 압축을 풉니다. (예: `tar -xzf software-1.2.3.tar.gz`)
3. **문서 확인:** 압축 해제된 디렉토리 안에서 `README`, `INSTALL` 등의 문서를 찾아 **설치 방법 및 필요 조건(의존성)** 을 반드시 확인합니다.
4. **빌드 의존성 설치:** 컴파일에 필요한 개발 도구(`gcc`, `make` 등)와 라이브러리 헤더 파일(예: `libpng-dev`, `openssl-devel`)들을 **패키지 매니저(`apt`, `dnf`)를 이용하여 먼저 설치**해야 합니다. 이 단계가 가장 까다로울 수 있습니다.
5. **설정 (Configure):** 소스 코드 디렉토리 안에서 `./configure` 스크립트를 실행합니다. 이 스크립트는 시스템 환경을 검사하고 필요한 라이브러리가 있는지 확인하며, 컴파일 환경 설정을 위한 `Makefile` 등을 생성합니다. 설치 경로(`--prefix=/usr/local` 등)나 특정 기능 활성화/비활성화 옵션을 지정할 수도 있습니다.
6. **컴파일 (Compile):** `make` 명령어를 실행합니다. `Makefile` 의 규칙에 따라 소스 코드를 기계어(실행 가능한 바이너리)로 변환하는 컴파일 작업을 수행합니다. 프로젝트 크기에 따라 시간이 오래 걸릴 수 있습니다.
7. **설치 (Install):** `sudo make install` 명령어를 실행합니다. 컴파일된 실행 파일, 라이브러리, 문서 등을 시스템의 지정된 위치(보통 `/usr/local` 아래)로 복사하여 설치를 완료합니다.

**장점:** 최신 버전 사용 가능, 세부적인 컴파일 옵션 설정 가능.
**단점:** 과정이 복잡하고 시간이 오래 걸림, 의존성 문제를 수동으로 해결해야 함, 패키지 매니저를 통하지 않으므로 업데이트 및 삭제 관리가 어려움 (나중에 어떤 파일이 설치되었는지 추적하기 어려울 수 있음. `checkinstall` 같은 도구를 사용하면 `.deb`나 `.rpm` 패키지로 만들어 설치할 수도 있습니다).

**결론:** 가능하면 항상 시스템의 **패키지 관리자를 통해 소프트웨어를 설치하고 관리**하는 것이 가장 쉽고 안전하며 효율적인 방법입니다. 소스 코드 컴파일 설치는 꼭 필요한 경우에만, 과정을 충분히 이해한 후에 시도하는 것이 좋습니다.


## 결론

이번 챕터에서는 리눅스에서 소프트웨어를 관리하는 핵심적인 방법인 패키지 관리에 대해 배웠습니다. 패키지, 패키지 매니저, 저장소, 의존성의 개념을 이해하고, 왜 패키지 관리 시스템이 편리하고 안전한지 알아보았습니다.

Debian/Ubuntu 계열의 `apt` 명령어(`update`, `upgrade`, `install`, `search`, `show`, `remove`, `purge`, `autoremove`)와 Red Hat/Fedora 계열의 `dnf` 명령어(`check-update`, `update`/`upgrade`, `install`, `search`, `info`, `remove`, `autoremove`) 사용법을 익혔습니다. 또한 저수준 도구인 `dpkg`와 `rpm`, 그리고 고급 사용자를 위한 소스 코드 컴파일 및 설치 방법에 대해서도 간략하게 살펴보았습니다.

리눅스 시스템을 최신 상태로 안전하게 유지하고 필요한 소프트웨어를 편리하게 설치하기 위해서는 시스템의 패키지 관리자를 능숙하게 사용하는 것이 매우 중요합니다. 앞으로 리눅스를 사용하면서 필요한 도구나 라이브러리를 설치할 때 이 챕터에서 배운 명령어들을 적극적으로 활용해보시기 바랍니다.

다음 Chapter 10에서는 디스크 공간을 확인하고 파일 시스템을 관리하는 좀 더 자세한 방법들을 다루겠습니다.
