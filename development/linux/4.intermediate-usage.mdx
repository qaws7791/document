---
title: "4. 중급 활용(Intermediate Usage)"
---

이 장에서는 리눅스 사용 경험이 있는 사용자를 대상으로, 시스템 관리 및 활용에 필요한 중급 수준의 주제들을 다룹니다. 패키지 관리, 사용자 및 그룹 관리 심화, 권한 관리 심화, 프로세스 관리 심화, 네트워크 기초 및 도구, 그리고 셸 스크립팅 기초를 학습합니다.


## 4.1. 패키지 관리

리눅스에서는 소프트웨어를 효율적으로 설치, 업데이트, 삭제하기 위해 패키지 관리 시스템을 사용합니다. 패키지 관리 시스템은 소프트웨어와 그 의존성 정보를 패키지 형태로 관리하여, 사용자가 복잡한 의존성 문제를 해결하지 않고도 쉽게 소프트웨어를 관리할 수 있도록 합니다.


### 4.1.1. 패키지 매니저 개념 (APT, YUM/DNF 등)

리눅스 배포판마다 사용하는 기본적인 패키지 매니저가 다릅니다.

* **Debian 계열 (Ubuntu 등): APT (Advanced Package Tool)**

    APT는 Debian과 Ubuntu를 비롯한 Debian 계열 배포판에서 사용되는 강력한 패키지 관리 도구입니다. `.deb` 확장자를 가진 패키지 파일을 관리하며, 다음과 같은 주요 도구들을 포함합니다.

  * `apt-get`: 명령행에서 패키지를 관리하는 기본적인 도구입니다 (설치, 업데이트, 삭제 등).
  * `apt`: `apt-get`의 기능을 개선하고 사용자 편의성을 높인 새로운 명령행 도구입니다.
  * `apt-cache`: 패키지 정보 검색 및 관리를 위한 도구입니다.

* **Red Hat 계열 (CentOS/RHEL 등): YUM (Yellowdog Updater, Modified) / DNF (Dandified YUM)**

    YUM은 Red Hat Enterprise Linux (RHEL) 및 CentOS와 같은 Red Hat 계열 배포판에서 사용되던 패키지 관리 도구입니다. `.rpm` 확장자를 가진 패키지 파일을 관리하며, 의존성 해결 기능을 제공합니다.

    최근에는 YUM의 후속 버전인 DNF가 Red Hat 계열 배포판의 기본 패키지 매니저로 점차 자리 잡고 있습니다. DNF는 YUM의 성능 및 기능을 개선했습니다.

**패키지 저장소 (Repository):**

패키지 매니저는 인터넷 또는 네트워크 상의 패키지 저장소로부터 소프트웨어 패키지 및 관련 정보를 다운로드합니다. 패키지 저장소는 각 배포판 관리 기관 또는 커뮤니티에서 관리하며, 수많은 소프트웨어 패키지를 제공합니다.

패키지 매니저는 설정 파일에 등록된 패키지 저장소 목록을 참조하여 패키지를 검색하고 다운로드합니다.


### 4.1.2. 패키지 검색, 설치, 업데이트, 삭제 (apt install, yum update 등)

**APT (Debian 계열):**

* **패키지 목록 업데이트:** 패키지 저장소의 최신 패키지 목록을 다운로드합니다. 이 작업은 패키지를 설치하거나 업데이트하기 전에 먼저 수행해야 합니다.

    ```bash
    sudo apt update
    ```

* **패키지 검색:** 패키지 저장소에서 특정 이름 또는 키워드를 포함하는 패키지를 검색합니다.

    ```bash
    apt search <패키지 이름 또는 키워드>
    ```

    또는

    ```bash
    apt-cache search <패키지 이름 또는 키워드>
    ```

* **패키지 정보 확인:** 특정 패키지의 상세 정보 (버전, 설명, 의존성 등)를 확인합니다.

    ```bash
    apt show <패키지 이름>
    ```

    또는

    ```bash
    apt-cache show <패키지 이름>
    ```

* **패키지 설치:** 패키지 저장소로부터 특정 패키지를 다운로드하고 설치합니다. 필요한 의존성 패키지도 자동으로 함께 설치됩니다.

    ```bash
    sudo apt install <패키지 이름>
    ```

    여러 개의 패키지를 동시에 설치할 수 있습니다.

    ```bash
    sudo apt install <패키지 이름1> <패키지 이름2> ...
    ```

* **패키지 업그레이드:** 설치된 특정 패키지를 최신 버전으로 업그레이드합니다.

    ```bash
    sudo apt upgrade <패키지 이름>
    ```

* **시스템 전체 업그레이드:** 시스템에 설치된 모든 패키지를 최신 버전으로 업그레이드합니다. 이 작업은 시스템 안정성에 영향을 미칠 수 있으므로 주의해서 수행해야 합니다.

    ```bash
    sudo apt full-upgrade
    ```

    또는

    ```bash
    sudo apt dist-upgrade
    ```

* **패키지 삭제:** 특정 패키지를 제거합니다. 설정 파일은 남아있을 수 있습니다.

    ```bash
    sudo apt remove <패키지 이름>
    ```

* **패키지 삭제 (설정 파일 포함):** 특정 패키지와 함께 설정 파일까지 완전히 제거합니다.

    ```bash
    sudo apt purge <패키지 이름>
    ```

**YUM / DNF (Red Hat 계열):**

* **패키지 목록 업데이트:** 패키지 저장소의 최신 패키지 목록을 다운로드합니다.

    ```bash
    sudo yum updateinfo
    sudo dnf makecache
    ```

* **패키지 검색:** 패키지 저장소에서 특정 이름 또는 키워드를 포함하는 패키지를 검색합니다.

    ```bash
    yum search <패키지 이름 또는 키워드>
    dnf search <패키지 이름 또는 키워드>
    ```

* **패키지 정보 확인:** 특정 패키지의 상세 정보 (버전, 설명, 의존성 등)를 확인합니다.

    ```bash
    yum info <패키지 이름>
    dnf info <패키지 이름>
    ```

* **패키지 설치:** 패키지 저장소로부터 특정 패키지를 다운로드하고 설치합니다. 필요한 의존성 패키지도 자동으로 함께 설치됩니다.

    ```bash
    sudo yum install <패키지 이름>
    sudo dnf install <패키지 이름>
    ```

    여러 개의 패키지를 동시에 설치할 수 있습니다.

    ```bash
    sudo yum install <패키지 이름1> <패키지 이름2> ...
    sudo dnf install <패키지 이름1> <패키지 이름2> ...
    ```

* **패키지 업그레이드:** 설치된 특정 패키지를 최신 버전으로 업그레이드합니다.

    ```bash
    sudo yum update <패키지 이름>
    sudo dnf update <패키지 이름>
    ```

* **시스템 전체 업그레이드:** 시스템에 설치된 모든 패키지를 최신 버전으로 업그레이드합니다.

    ```bash
    sudo yum update
    sudo dnf upgrade
    ```

* **패키지 삭제:** 특정 패키지를 제거합니다. 의존성 패키지도 함께 제거될 수 있습니다.

    ```bash
    sudo yum remove <패키지 이름>
    sudo dnf remove <패키지 이름>
    ```


## 4.2. 사용자 및 그룹 관리 심화

이 장에서는 기본적인 사용자 및 그룹 관리를 넘어, 시스템 운영에 필요한 심화된 사용자 및 그룹 관리 방법에 대해 설명합니다. 사용자를 추가, 수정, 삭제하고, 그룹을 관리하며, `sudo` 권한을 설정하는 방법을 학습합니다.


### 4.2.1. useradd, usermod, userdel

* **`useradd`**: 새로운 사용자 계정을 생성합니다. 다양한 옵션을 사용하여 사용자의 속성을 설정할 수 있습니다. 일반적으로 `root` 권한이 필요합니다.

    ```bash
    sudo useradd [옵션] <새로운 사용자 이름>
    ```

    주요 옵션:

  * `-c <설명>`: 사용자에 대한 설명을 추가합니다 (GECOS 필드).
  * `-d <홈 디렉토리>`: 사용자의 홈 디렉토리를 지정합니다. 기본값은 `/home/<사용자 이름>`입니다.
  * `-m`: 홈 디렉토리를 생성합니다 (기본적으로 홈 디렉토리는 생성되지 않습니다). `-d` 옵션과 함께 사용되는 경우가 많습니다.
  * `-s <셸>`: 사용자의 로그인 셸을 지정합니다. 기본값은 시스템 설정에 따릅니다 (`/bin/bash` 등).
  * `-g <기본 그룹>`: 사용자가 속할 기본 그룹의 이름 또는 GID를 지정합니다.
  * `-G <보조 그룹 목록>`: 사용자가 속할 보조 그룹 목록을 쉼표로 구분하여 지정합니다.
  * `-u <UID>`: 사용자의 UID를 명시적으로 지정합니다 (일반적으로 시스템에서 자동으로 할당).
  * `-p <암호화된 비밀번호>`: 암호화된 비밀번호를 지정합니다 (보안상 권장되지 않으며, `passwd` 명령어를 사용하여 설정하는 것이 좋습니다).

    예시:

    ```bash
    sudo useradd -m -d /home/testuser -s /bin/zsh testuser  # 홈 디렉토리 생성, 셸을 /bin/zsh로 설정한 testuser 계정 생성
    sudo useradd -c "Web Developer" -g developers newdev     # 설명과 기본 그룹을 설정한 newdev 계정 생성
    sudo useradd -G developers,testers anotherdev           # 보조 그룹을 설정한 anotherdev 계정 생성
    ```

    **주의:** `useradd`만으로는 사용자 계정에 비밀번호가 설정되지 않습니다. `passwd` 명령어를 사용하여 비밀번호를 설정해야 합니다.

    ```bash
    sudo passwd testuser
    ```

* **`usermod`**: 기존 사용자 계정의 속성을 수정합니다. `root` 권한이 필요합니다.

    ```bash
    sudo usermod [옵션] <사용자 이름>
    ```

    주요 옵션 (대부분 `useradd`와 유사):

  * `-c <새로운 설명>`: 사용자 설명을 변경합니다.
  * `-d <새로운 홈 디렉토리>`: 사용자 홈 디렉토리를 변경합니다. `-m` 옵션과 함께 사용하여 기존 홈 디렉토리의 내용을 새로운 위치로 이동할 수 있습니다.
  * `-s <새로운 셸>`: 사용자 로그인 셸을 변경합니다.
  * `-g <새로운 기본 그룹>`: 사용자 기본 그룹을 변경합니다.
  * `-G <새로운 보조 그룹 목록>`: 사용자 보조 그룹 목록을 변경합니다. 기존 보조 그룹을 유지하려면 `-a` 옵션과 함께 사용해야 합니다.
  * `-aG <추가할 보조 그룹 목록>`: 사용자를 지정된 보조 그룹에 추가합니다 (기존 그룹 유지).
  * `-u <새로운 UID>`: 사용자 UID를 변경합니다.
  * `-l <새로운 사용자 이름>`: 사용자 이름을 변경합니다.
  * `-L`: 사용자 계정을 잠급니다 (비밀번호를 통한 로그인 불가).
  * `-U`: 잠긴 사용자 계정을 해제합니다.

    예시:

    ```bash
    sudo usermod -c "Senior Developer" devuser         # devuser의 설명을 변경
    sudo usermod -d /opt/devuser -m devuser             # devuser의 홈 디렉토리를 /opt/devuser로 이동
    sudo usermod -s /bin/bash devuser                  # devuser의 로그인 셸을 /bin/bash로 변경
    sudo usermod -g webadmins devuser                  # devuser의 기본 그룹을 webadmins로 변경
    sudo usermod -aG testers devuser                   # devuser를 testers 보조 그룹에 추가
    sudo usermod -l newdevuser devuser                 # 사용자 이름을 devuser에서 newdevuser로 변경
    sudo usermod -L olduser                           # olduser 계정 잠금
    sudo usermod -U olduser                           # olduser 계정 잠금 해제
    ```

* **`userdel`**: 사용자 계정을 삭제합니다. `-r` 옵션을 사용하여 사용자의 홈 디렉토리 및 관련 파일까지 함께 삭제할 수 있습니다. `root` 권한이 필요합니다.

    ```bash
    sudo userdel <사용자 이름>
    sudo userdel -r <사용자 이름>
    ```

  * `sudo userdel testuser`: `testuser` 계정만 삭제하고, 홈 디렉토리 및 관련 파일은 남겨둡니다.
  * `sudo userdel -r olduser`: `olduser` 계정과 함께 홈 디렉토리(`/home/olduser`) 및 메일 스풀 등을 삭제합니다. **주의해서 사용해야 합니다.**


### 4.2.2. groupadd, groupmod, groupdel

* **`groupadd`**: 새로운 그룹을 생성합니다. `root` 권한이 필요합니다.

    ```bash
    sudo groupadd [옵션] <새로운 그룹 이름>
    ```

    주요 옵션:

  * `-g <GID>`: 그룹의 GID를 명시적으로 지정합니다 (일반적으로 시스템에서 자동으로 할당).
  * `-r`: 시스템 그룹을 생성합니다 (일반적으로 UID/GID가 낮은 값으로 할당됨).

    예시:

    ```bash
    sudo groupadd developers
    sudo groupadd -g 2000 testers
    sudo groupadd -r systemgroup
    ```

* **`groupmod`**: 기존 그룹의 속성을 수정합니다. `root` 권한이 필요합니다.

    ```bash
    sudo groupmod [옵션] <그룹 이름>
    ```

    주요 옵션:

  * `-n <새로운 그룹 이름>`: 그룹 이름을 변경합니다.
  * `-g <새로운 GID>`: 그룹 GID를 변경합니다.

    예시:

    ```bash
    sudo groupmod -n webmasters webadmins  # 그룹 이름을 webadmins에서 webmasters로 변경
    sudo groupmod -g 2001 testers          # testers 그룹의 GID를 2001로 변경
    ```

* **`groupdel`**: 그룹을 삭제합니다. 해당 그룹을 기본 그룹으로 사용하는 사용자가 없어야 삭제할 수 있습니다. `root` 권한이 필요합니다.

    ```bash
    sudo groupdel <삭제할 그룹 이름>
    ```

    예시:

    ```bash
    sudo groupdel oldgroup
    ```


### 4.2.3. sudo 설정 및 사용법

`sudo` (Superuser do)는 일반 사용자가 제한된 범위 내에서 `root` 권한으로 명령어를 실행할 수 있도록 해주는 프로그램입니다. `root` 계정으로 직접 로그인하는 것보다 보안상 더 안전한 방법으로 시스템 관리 작업을 수행할 수 있도록 합니다.

**`sudo` 설정 (`/etc/sudoers` 파일):**

`sudo`의 설정은 `/etc/sudoers` 파일에서 관리합니다. 이 파일은 `visudo` 명령어를 사용하여 안전하게 편집해야 합니다. `visudo`는 파일을 잠그고 문법 오류를 검사하여 시스템 손상을 방지합니다.

```bash
sudo visudo
```

`/etc/sudoers` 파일의 주요 설정 형식:

```
<사용자 또는 그룹> <호스트>=(<실행 권한을 가질 사용자>) <실행 가능한 명령어>
```

* `<사용자 또는 그룹>`: `sudo` 권한을 부여할 사용자 이름 또는 그룹 이름 (`%` 기호로 시작).
* `<호스트>`: `sudo` 명령어를 실행할 수 있는 호스트 (일반적으로 `ALL`).
* `(<실행 권한을 가질 사용자>)`: 명령어를 어떤 사용자의 권한으로 실행할지 지정 (기본값은 `root`).
* `<실행 가능한 명령어>`: `sudo`를 통해 실행할 수 있는 명령어 목록 (`ALL`은 모든 명령어 허용).

예시 설정:

* 특정 사용자에게 모든 명령어에 대한 `sudo` 권한 부여 (비밀번호 필요):

    ```
    username ALL=(ALL) ALL
    ```

* 특정 그룹에게 특정 명령어에 대한 `sudo` 권한 부여 (비밀번호 필요):

    ```
    %groupname ALL=(ALL) /usr/sbin/service, /bin/systemctl
    ```

* 특정 사용자에게 모든 명령어에 대한 `sudo` 권한 부여 (비밀번호 없이):

    ```
    username ALL=(ALL) NOPASSWD: ALL
    ```

**`sudo` 사용법:**

`sudo` 권한이 있는 사용자는 명령어 앞에 `sudo`를 붙여 실행하면 `root` 권한으로 해당 명령어를 실행할 수 있습니다. 처음 `sudo`를 사용하는 경우 또는 일정 시간이 지나면 비밀번호를 입력하라는 메시지가 나타납니다 (설정에 따라 다를 수 있음).

```bash
sudo <실행할 명령어>
```

예시:

```bash
sudo apt update
sudo useradd newuser
sudo systemctl restart apache2
```

`sudo`를 사용하면 일반 사용자 계정으로도 필요한 관리 작업을 수행할 수 있으며, 시스템의 보안을 강화하는 데 기여합니다. 다만, `sudo` 권한은 신중하게 관리해야 합니다.


## 4.3. 권한 관리 심화

이 장에서는 기본적인 읽기, 쓰기, 실행 권한 외에 리눅스에서 제공하는 고급 권한 관리 기법에 대해 설명합니다. 특수 권한 (SetUID, SetGID, Sticky Bit)과 Access Control Lists (ACLs)를 사용하여 더욱 세밀하고 유연하게 파일 및 디렉토리 접근 권한을 제어하는 방법을 학습합니다.


### 4.3.1. 특수 권한 (SetUID, SetGID, Sticky Bit)

일반적인 파일 권한은 파일 소유자, 그룹 소유자, 그리고 그 외 사용자에 대해 적용됩니다. 특수 권한은 이러한 기본적인 권한 체계를 확장하여 특정 상황에서 파일 실행 또는 디렉토리 접근 방식을 변경합니다.

* **SetUID (Set User ID upon execution):** 실행 파일에 SetUID 권한이 설정되어 있으면, 해당 파일을 실행하는 사용자의 실제 사용자 ID가 아닌 파일 소유자의 사용자 ID로 프로세스가 실행됩니다.

  * **표시:** 실행 권한(`x`) 위치에 소유자 권한 부분에 `s` (실행 권한 있음) 또는 `S` (실행 권한 없음)로 표시됩니다.
  * **활용:** `passwd` 명령어와 같이 일반 사용자가 `root` 권한으로 특정 작업을 수행해야 할 때 사용됩니다. `passwd` 실행 파일은 소유자가 `root`이고 SetUID 권한이 설정되어 있어, 일반 사용자가 자신의 비밀번호를 변경할 때 `root` 권한으로 `/etc/shadow` 파일을 수정할 수 있습니다.

    **SetUID 설정/해제:**

    ```bash
    sudo chmod u+s <파일>   # SetUID 설정
    sudo chmod u-s <파일>   # SetUID 해제
    ```

* **SetGID (Set Group ID upon execution / Set Group ID for new files in a directory):**
  * **실행 파일:** 실행 파일에 SetGID 권한이 설정되어 있으면, 해당 파일을 실행하는 사용자의 실제 그룹 ID가 아닌 파일 그룹 소유자의 그룹 ID로 프로세스가 실행됩니다.
  * **디렉토리:** 디렉토리에 SetGID 권한이 설정되어 있으면, 해당 디렉토리 내에 새로 생성되는 파일 및 하위 디렉토리의 그룹 소유자가 해당 디렉토리의 그룹 소유자로 상속됩니다.

  * **표시:** 실행 권한(`x`) 위치에 그룹 권한 부분에 `s` (실행 권한 있음) 또는 `S` (실행 권한 없음)로 표시됩니다.
  * **활용:** 여러 사용자가 특정 그룹의 권한으로 파일을 공유하고 작업해야 하는 환경에서 유용합니다. 예를 들어, 특정 디렉토리에 SetGID를 설정하고 그룹 소유자를 공유 그룹으로 설정하면, 해당 디렉토리에서 생성되는 파일들은 자동으로 공유 그룹의 소유가 됩니다.

    **SetGID 설정/해제:**

    ```bash
    sudo chmod g+s <파일 또는 디렉토리>   # SetGID 설정
    sudo chmod g-s <파일 또는 디렉토리>   # SetGID 해제
    ```

* **Sticky Bit:** 디렉토리에 Sticky Bit 권한이 설정되어 있으면, 해당 디렉토리 내의 파일이나 하위 디렉토리를 삭제할 수 있는 사용자는 다음 중 하나에 해당해야 합니다.
  * 파일/디렉토리의 소유자
  * 디렉토리의 소유자
  * `root` 사용자

    일반적으로 쓰기 권한이 있는 모든 사용자는 해당 디렉토리 내의 파일을 삭제할 수 있지만, Sticky Bit가 설정되면 다른 사용자의 파일을 실수로 삭제하는 것을 방지할 수 있습니다.

  * **표시:** 그 외 사용자 권한 부분의 실행 권한(`x`) 위치에 `t` (실행 권한 있음) 또는 `T` (실행 권한 없음)로 표시됩니다.
  * **활용:** 여러 사용자가 공동으로 사용하는 임시 디렉토리(`/tmp`, `/var/tmp`)에서 주로 사용됩니다.

    **Sticky Bit 설정/해제:**

    ```bash
    sudo chmod +t <디렉토리>   # Sticky Bit 설정
    sudo chmod -t <디렉토리>   # Sticky Bit 해제
    ```

**숫자 모드를 이용한 특수 권한 설정:**

`chmod` 명령어의 숫자 모드를 사용할 때, 특수 권한은 처음 한 자리 숫자로 표현됩니다.

* SetUID: 4
* SetGID: 2
* Sticky Bit: 1

이 숫자를 기존 권한 숫자 앞에 추가하여 특수 권한을 설정할 수 있습니다.

* `chmod 4755 <파일>`: SetUID 설정 (소유자: rws, 그룹: r-x, others: r-x)
* `chmod 2775 <디렉토리>`: SetGID 설정 (소유자: rwx, 그룹: rws, others: r-x)
* `chmod 1777 <디렉토리>`: Sticky Bit 설정 (소유자: rwx, 그룹: rwx, others: rwt)


### 4.3.2. Access Control Lists (ACLs) - getfacl, setfacl

ACL (Access Control List)은 표준 파일 권한 체계를 더욱 확장하여, 특정 사용자나 특정 그룹에 대해 개별적인 접근 권한을 설정할 수 있도록 합니다. ACL을 사용하면 파일이나 디렉토리에 대해 더 세밀한 권한 관리가 가능해집니다.

**ACL 활성화 확인:**

대부분의 현대 리눅스 파일 시스템은 ACL을 지원하지만, 마운트 옵션에 따라 활성화되어 있지 않을 수 있습니다. `/etc/fstab` 파일을 확인하여 해당 파일 시스템의 마운트 옵션에 `acl`이 포함되어 있는지 확인합니다.

**`getfacl` (get file ACL): ACL 정보 확인**

`getfacl` 명령어는 파일 또는 디렉토리에 설정된 ACL 정보를 확인하는 데 사용됩니다.

```bash
getfacl <파일 또는 디렉토리>
```

출력 예시:

```
# file: testfile.txt
# owner: user1
# group: group1
user::rw-
user:user2:r--
group::r--
mask::r--
other::---
```

* `# file`: 파일 이름
* `# owner`: 파일 소유자
* `# group`: 파일 그룹 소유자
* `user::rw-`: 파일 소유자의 권한 (표준 권한)
* `user:user2:r--`: `user2`라는 특정 사용자에 대한 읽기 권한
* `group::r--`: 파일 그룹 소유자의 권한 (표준 권한)
* `mask::r--`: 유효 권한 마스크 (ACL 항목에 부여된 최대 권한을 제한)
* `other::---`: 그 외 사용자의 권한 (표준 권한)

**`setfacl` (set file ACL): ACL 설정 및 수정**

`setfacl` 명령어는 파일 또는 디렉토리에 ACL 항목을 설정하거나 수정하는 데 사용됩니다. `root` 권한이 필요할 수 있습니다.

```bash
sudo setfacl [옵션] <파일 또는 디렉토리>
```

주요 옵션:

* `-m <acl 항목>` (modify): 기존 ACL에 새로운 항목을 추가하거나 기존 항목을 수정합니다.
  * `u:<사용자>:<권한>`: 특정 사용자에 대한 권한 설정 (예: `u:user3:rw-`)
  * `g:<그룹>:<권한>`: 특정 그룹에 대한 권한 설정 (예: `g:group2:r--`)
* `-x <acl 항목>` (remove): 기존 ACL에서 특정 항목을 제거합니다.
  * `u:<사용자>`: 특정 사용자 ACL 항목 제거
  * `g:<그룹>`: 특정 그룹 ACL 항목 제거
* `-b` (remove all): 모든 ACL 항목을 제거하고 표준 권한만 남깁니다.
* `-R` (recursive): 디렉토리에 대해 ACL을 설정할 때, 하위 디렉토리 및 파일에도 재귀적으로 적용합니다. `--default` 옵션과 함께 사용하여 새로 생성되는 항목에 대한 기본 ACL을 설정할 수 있습니다.
* `--default` (set default ACL): 디렉토리에 대해 기본 ACL을 설정합니다. 해당 디렉토리 내에 새로 생성되는 파일 및 하위 디렉토리는 이 기본 ACL을 상속받습니다.

예시:

```bash
sudo setfacl -m u:user3:rw- testfile.txt   # user3에게 testfile.txt에 대한 읽기, 쓰기 권한 부여
sudo setfacl -m g:group2:r-- testfile.txt  # group2에게 testfile.txt에 대한 읽기 권한 부여
sudo setfacl -x u:user2 testfile.txt       # user2에 대한 ACL 항목 제거
sudo setfacl -b testfile.txt               # testfile.txt의 모든 ACL 항목 제거

sudo setfacl -R -m u:user4:r-x shared_dir  # shared_dir 및 그 내용에 user4에게 읽기, 실행 권한 부여
sudo setfacl -d -m g:developers:rw- shared_dir # shared_dir에 새로 생성되는 항목에 대해 developers 그룹에 읽기, 쓰기 권한을 기본 ACL로 설정
```

ACL은 표준 권한보다 훨씬 더 유연한 권한 관리 방법을 제공하지만, 너무 복잡하게 설정하면 관리하기 어려워질 수 있으므로 상황에 맞게 적절히 사용하는 것이 중요합니다.


## 4.4. 프로세스 관리 심화

이 장에서는 기본적인 프로세스 확인 및 종료를 넘어, 프로세스의 우선순위를 제어하고, 특정 조건에 따라 프로세스를 관리하는 등 심화된 프로세스 관리 방법에 대해 설명합니다. `nice`, `renice`, `kill` 명령어를 활용하고, 백그라운드 작업 관리 및 프로세스 모니터링 도구를 사용하는 방법을 학습합니다.


### 4.4.1. nice, renice (프로세스 우선순위 조절)

리눅스 커널은 각 프로세스에 우선순위를 할당하여 CPU 시간을 배분합니다. 우선순위가 높은 프로세스는 더 많은 CPU 시간을 할당받아 더 빠르게 실행될 가능성이 높습니다. `nice`와 `renice` 명령어를 사용하여 프로세스의 우선순위를 조절할 수 있습니다.

* **Nice 값:** 리눅스에서는 프로세스 우선순위를 -20 (가장 높음)부터 19 (가장 낮음)까지의 Nice 값으로 표현합니다. 기본값은 0입니다. Nice 값이 낮을수록 우선순위가 높습니다. 일반 사용자는 Nice 값을 높이는 (우선순위를 낮추는) 것만 가능하며, Nice 값을 낮추려면 (우선순위를 높이려면) `root` 권한이 필요합니다.

* **`nice`**: 새로운 프로세스를 실행할 때 Nice 값을 지정합니다.

    ```bash
    nice -n <Nice 값> <실행할 명령어>
    ```

  * `-n <Nice 값>` 또는 `--adjustment=<Nice 값>` 옵션을 사용하여 Nice 값을 지정합니다. 생략하면 기본값 (0)으로 실행됩니다.

    예시:

    ```bash
    nice -n 10 ./long_running_task  # Nice 값 10으로 long_running_task 실행 (낮은 우선순위)
    sudo nice -n -5 ./important_task # Nice 값 -5로 important_task 실행 (높은 우선순위 - root 권한 필요)
    ```

* **`renice`**: 이미 실행 중인 프로세스의 Nice 값을 변경합니다. 일반 사용자는 자신의 프로세스의 Nice 값만 높일 수 있으며, Nice 값을 낮추려면 `root` 권한이 필요합니다.

    ```bash
    renice <Nice 값> -p <PID> [...]
    renice <Nice 값> -u <사용자> [...]
    renice <Nice 값> -g <그룹> [...]
    ```

  * `<Nice 값>`: 변경할 새로운 Nice 값 (-20 ~ 19).
  * `-p <PID>`: 특정 PID를 가진 프로세스의 Nice 값을 변경합니다.
  * `-u <사용자>`: 특정 사용자가 소유한 모든 프로세스의 Nice 값을 변경합니다.
  * `-g <그룹>`: 특정 그룹이 소유한 모든 프로세스의 Nice 값을 변경합니다.

    예시:

    ```bash
    renice 15 -p 12345  # PID 12345번 프로세스의 Nice 값을 15로 변경 (낮은 우선순위)
    sudo renice -10 -u webserver # webserver 사용자가 소유한 모든 프로세스의 Nice 값을 -10으로 변경 (높은 우선순위 - root 권한 필요)
    ```


### 4.4.2. kill 명령어 심화 (다양한 시그널)

`kill` 명령어는 특정 프로세스에 시그널(signal)을 보내 프로세스의 동작을 제어합니다. 기본적인 사용법은 프로세스를 종료하는 것이지만, 다양한 시그널을 사용하여 프로세스에 다른 종류의 명령을 내릴 수 있습니다.

```bash
kill [옵션 | 시그널] <PID> [...]
```

* **시그널:** 프로세스에 전달되는 메시지로, 특정 이벤트 발생을 알리거나 특정 동작을 요청하는 데 사용됩니다. 각 시그널은 고유한 이름 (예: `SIGTERM`, `SIGKILL`, `SIGHUP`)과 숫자 (예: 15, 9, 1)를 가집니다.

자주 사용되는 시그널:

* **`SIGTERM` (15):** 정상적인 종료를 요청하는 시그널입니다. 대부분의 프로세스는 이 시그널을 받으면 현재 작업을 마무리하고 안전하게 종료하려고 시도합니다. `kill` 명령어에 시그널을 명시하지 않으면 기본적으로 `SIGTERM`이 전송됩니다.
* **`SIGKILL` (9):** 프로세스를 즉시 강제 종료하는 시그널입니다. 프로세스가 `SIGTERM`에 응답하지 않거나 멈춘 경우에 사용합니다. 강제 종료되므로 데이터 손실이 발생할 수 있습니다.
* **`SIGHUP` (1):** 프로세스에 설정 파일의 재로딩 또는 재시작을 요청하는 시그널입니다. 데몬(daemon) 프로세스들이 설정 변경을 적용하기 위해 자주 사용합니다.
* **`SIGINT` (2):** 인터럽트 시그널로, 일반적으로 `Ctrl` + `C` 키를 눌렀을 때 터미널에서 실행 중인 포그라운드 프로세스에 전송됩니다. 프로세스를 종료하도록 요청합니다.
* **`SIGSTOP` (19):** 프로세스를 일시적으로 중지시키는 시그널입니다.
* **`SIGCONT` (18):** 중지된 프로세스를 다시 실행시키는 시그널입니다.

**`kill` 명령어 사용 예시:**

```bash
kill 12345           # PID 12345번 프로세스에 SIGTERM 시그널 전송 (종료 요청)
kill -9 54321        # PID 54321번 프로세스에 SIGKILL 시그널 전송 (강제 종료)
kill -SIGHUP 67890    # PID 67890번 프로세스에 SIGHUP 시그널 전송 (설정 재로딩 요청)
kill -1 9876         # PID 9876번 프로세스에 SIGHUP 시그널 전송 (숫자 사용)
kill -STOP 11122      # PID 11122번 프로세스 중지
kill -CONT 11122      # PID 11122번 프로세스 재시작
```


### 4.4.3. 백그라운드 작업 관리 심화 (nohup, disown)

백그라운드에서 실행 중인 작업을 더욱 효과적으로 관리하기 위한 명령어입니다.

* **`nohup` (no hang up)**: 터미널 연결이 끊어지더라도 백그라운드에서 실행 중인 프로세스가 계속 실행되도록 합니다. `nohup`으로 실행된 프로세스의 표준 출력 및 표준 에러는 기본적으로 `nohup.out` 파일에 저장됩니다.

    ```bash
    nohup <실행할 명령어> [인수 ...] &
    ```

    예시:

    ```bash
    nohup ./long_process.sh &  # long_process.sh를 백그라운드에서 실행하고 터미널 연결이 끊어져도 계속 실행
    nohup tail -f server.log > mylog.txt 2>&1 & # tail 명령의 출력을 mylog.txt에 저장하고 에러도 함께 저장
    ```

* **`disown`**: 현재 셸에서 실행 중인 백그라운드 작업을 셸의 작업 목록에서 제거합니다. 이렇게 하면 셸이 종료되더라도 해당 작업에 `SIGHUP` 시그널이 전송되지 않아 계속 실행될 수 있습니다 (마치 `nohup`으로 실행한 것처럼 동작).

    ```bash
    disown [옵션] [작업 ID ...]
    ```

  * 작업 ID는 `jobs` 명령어로 확인할 수 있습니다. 생략하면 현재 셸의 모든 백그라운드 작업에 적용됩니다.
  * `-h`: 작업을 SIGHUP 시그널로부터 보호합니다 (기본 동작).
  * `-r`: 실행 중인 작업만 남기고 작업 목록에서 제거합니다.
  * `-a`: 모든 작업을 작업 목록에서 제거합니다.

    **사용 시나리오:** 이미 백그라운드로 실행한 작업을 `nohup`처럼 터미널 종료와 무관하게 계속 실행하고 싶을 때 사용합니다.

    1. 작업을 백그라운드로 실행 (`command &`)
    2. `jobs` 명령어로 작업 ID 확인
    3. `disown %<작업 ID>` 명령 실행

    예시:

    ```bash
    ./another_task.sh &
    jobs
    # [1] 1234
    disown %1
    ```


### 4.4.4. 프로세스 모니터링 도구 심화 (ps 옵션 활용)

`ps` 명령어는 실행 중인 프로세스에 대한 다양한 정보를 제공합니다. 옵션을 활용하여 원하는 정보만 필터링하거나 특정 형식으로 출력할 수 있습니다.

자주 사용되는 `ps` 옵션 조합:

* **`ps aux`**: 시스템의 모든 사용자가 실행한 모든 프로세스의 상세 정보를 표시합니다.
  * `a`: 다른 사용자의 프로세스까지 포함하여 모든 프로세스 표시
  * `u`: 프로세스 소유자(사용자 이름) 표시
  * `x`: 제어 터미널이 없는 프로세스 (데몬 등) 포함

* **`ps -ef`**: 시스템의 모든 프로세스를 트리 형태로 표시합니다 (부모-자식 관계).
  * `-e`: 모든 프로세스 표시
  * `-f`: 전체 형식으로 출력 (PPID, UID 등 포함)

* **`ps -u <사용자 이름>`**: 특정 사용자가 실행한 프로세스만 표시합니다.

* **`ps -p <PID>[,PID...]`**: 특정 PID를 가진 프로세스의 정보만 표시합니다.

* **`ps --forest`**: 프로세스를 트리 구조로 시각적으로 표현합니다.

* **출력 필드 사용자 정의 (`-o` 옵션):**

    `-o` 옵션을 사용하면 출력할 필드를 원하는 대로 선택하고 순서를 지정할 수 있습니다.

    ```bash
    ps aux -o pid,user,%cpu,%mem,command
    ps -ef -o pid,ppid,user,command
    ```

    자주 사용되는 필드:

  * `pid`: 프로세스 ID
  * `ppid`: 부모 프로세스 ID
  * `user`: 프로세스 소유자
  * `%cpu`: CPU 사용률
  * `%mem`: 메모리 사용률
  * `vsz`: 가상 메모리 사용량
  * `rss`: 실제 메모리 사용량
  * `stat`: 프로세스 상태 코드
  * `start`: 프로세스 시작 시간
  * `time`: CPU 사용 시간
  * `command`: 실행된 명령어

`ps` 명령어와 다양한 옵션을 조합하여 시스템의 프로세스 상태를 정확하게 파악하고 필요한 정보를 얻을 수 있습니다. 파이프 (`|`)와 `grep`을 함께 사용하여 특정 조건을 만족하는 프로세스만 필터링하는 것도 유용합니다 (예: `ps aux | grep "apache"`).


## 4.5. 네트워크 기초 및 도구

이 장에서는 리눅스 시스템의 기본적인 네트워크 개념을 이해하고, 네트워크 연결 상태를 확인하고 관리하는 데 사용되는 주요 명령어 및 도구들을 학습합니다. IP 주소, 서브넷 마스크, 게이트웨이 등의 기본적인 네트워크 용어와 함께, `ip`, `ifconfig` (deprecated), `ping`, `netstat` (deprecated), `ss`, `traceroute`, `host`, `dig` 등의 네트워크 관련 명령어를 사용하는 방법을 익힙니다.


### 4.5.1. 기본 네트워크 용어 (IP 주소, 서브넷 마스크, 게이트웨이, DNS)

* **IP 주소 (Internet Protocol Address):** 네트워크에 연결된 장치(컴퓨터, 서버, 라우터 등)를 고유하게 식별하는 논리적인 주소입니다. IPv4 (32비트, 점으로 구분된 4개의 10진수)와 IPv6 (128비트, 콜론으로 구분된 16진수) 주소 체계가 있습니다.

* **서브넷 마스크 (Subnet Mask):** IP 주소를 네트워크 부분과 호스트 부분으로 나누는 역할을 합니다. 서브넷 마스크를 통해 네트워크의 범위를 정의하고, 같은 네트워크에 속한 장치들을 식별할 수 있습니다. IPv4의 경우 점으로 구분된 4개의 10진수 형식으로 표현됩니다.

* **게이트웨이 (Gateway):** 다른 네트워크로 통신하기 위해 거쳐야 하는 라우터의 IP 주소입니다. 로컬 네트워크에서 외부 네트워크 (예: 인터넷)로 데이터를 전송할 때 게이트웨이로 패킷을 보냅니다.

* **DNS (Domain Name System) 서버:** 사람이 이해하기 쉬운 도메인 이름 (예: google.com)을 컴퓨터가 이해할 수 있는 IP 주소로 변환해주는 서버입니다. 웹사이트에 접속할 때 DNS 서버에 도메인 이름에 해당하는 IP 주소를 요청합니다.


### 4.5.2. 네트워크 인터페이스 확인 및 설정 (ip, ifconfig)

네트워크 인터페이스는 컴퓨터가 네트워크에 연결되는 물리적 또는 논리적인 지점입니다 (예: 이더넷 카드, Wi-Fi 어댑터).

* **`ip` 명령어:** 현대 리눅스 시스템에서 네트워크 인터페이스 및 설정을 관리하는 데 사용되는 강력한 명령어입니다. `ifconfig`를 대체하는 추세입니다.

    ```bash
    ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]
    ```

    자주 사용되는 객체(OBJECT)와 명령어(COMMAND):

  * **`addr` (address):** IP 주소 정보 관리

        ```bash
        ip addr show [dev <인터페이스>]  # 특정 또는 모든 인터페이스의 IP 주소 정보 확인
        sudo ip addr add <IP 주소>/<CIDR> dev <인터페이스> # 인터페이스에 IP 주소 할당
        sudo ip addr del <IP 주소>/<CIDR> dev <인터페이스> # 인터페이스에서 IP 주소 제거
        ```

  * **`link`:** 네트워크 인터페이스의 물리적 속성 관리 (활성화/비활성화 등)

        ```bash
        ip link show [dev <인터페이스>]  # 특정 또는 모든 인터페이스의 링크 상태 확인
        sudo ip link set dev <인터페이스> up   # 인터페이스 활성화
        sudo ip link set dev <인터페이스> down # 인터페이스 비활성화
        ```

  * **`route`:** 라우팅 테이블 관리 (데이터 패킷이 목적지까지 이동하는 경로 설정)

        ```bash
        ip route show                # 현재 라우팅 테이블 확인
        sudo ip route add default via <게이트웨이 IP> # 기본 게이트웨이 설정
        ```

* **`ifconfig` (interface configuration):** 오래된 명령어이지만, 여전히 많은 시스템에서 사용 가능합니다. 네트워크 인터페이스의 IP 주소, 서브넷 마스크 등을 확인하고 설정하는 데 사용됩니다.

    ```bash
    ifconfig [인터페이스]
    sudo ifconfig <인터페이스> <IP 주소> netmask <서브넷 마스크> [up|down]
    sudo ifconfig <인터페이스> gateway <게이트웨이 IP> # 더 이상 권장되지 않음, ip route 사용
    ```

    예시:

    ```bash
    ip addr show eth0      # eth0 인터페이스의 IP 주소 정보 확인
    ip link show wlan0      # wlan0 인터페이스의 링크 상태 확인
    sudo ip link set dev eth0 up
    sudo ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up
    ```


### 4.5.3. 네트워크 연결 테스트 (ping, traceroute)

* **`ping` (Packet InterNet Groper):** 특정 호스트가 네트워크를 통해 연결 가능한지 확인하고, 응답 시간(latency)을 측정하는 데 사용됩니다. ICMP (Internet Control Message Protocol) 에코 요청 패킷을 대상 호스트로 보내고, 응답을 기다립니다.

    ```bash
    ping <호스트 이름 또는 IP 주소>
    ```

    자주 사용되는 옵션:

  * `-c <횟수>`: 보낼 핑 패킷의 횟수를 지정합니다.
  * `-i <시간 간격>`: 핑 패킷을 보내는 간격을 초 단위로 지정합니다.
  * `-s <패킷 크기>`: 보낼 핑 패킷의 크기를 바이트 단위로 지정합니다.

    예시:

    ```bash
    ping google.com
    ping -c 5 192.168.1.1
    ```

    `Ctrl` + `C`를 눌러 `ping` 명령을 중단하고 통계 결과를 확인할 수 있습니다.

* **`traceroute` (또는 `tracepath`):** 로컬 시스템에서 목적지 호스트까지의 네트워크 경로를 추적하고, 각 경유지(라우터)에서의 응답 시간을 표시합니다. 네트워크 연결 문제 발생 시 경로상의 어느 지점에서 문제가 발생하는지 파악하는 데 유용합니다.

    ```bash
    traceroute <호스트 이름 또는 IP 주소>
    tracepath <호스트 이름 또는 IP 주소>
    ```

    예시:

    ```bash
    traceroute google.com
    tracepath 8.8.8.8
    ```

    각 줄은 경로상의 라우터를 나타내며, 해당 라우터까지의 왕복 시간(RTT)이 표시됩니다. `*` 표시는 해당 홉에서 응답이 없음을 의미할 수 있습니다.


### 4.5.4. 네트워크 상태 확인 (netstat, ss)

* **`netstat` (network statistics):** 네트워크 연결, 라우팅 테이블, 인터페이스 통계 등 다양한 네트워크 관련 정보를 표시하는 오래된 명령어입니다. `ss`로 대체되는 추세입니다.

    ```bash
    netstat [옵션]
    ```

    자주 사용되는 옵션:

  * `-a`: 모든 소켓 (listening, established, non-connected) 표시
  * `-t`: TCP 연결만 표시
  * `-u`: UDP 연결만 표시
  * `-l`: Listening 상태의 소켓만 표시
  * `-n`: 주소와 포트 번호를 이름 대신 숫자로 표시
  * `-p`: 소켓과 관련된 프로세스 정보 표시 (root 권한 필요)
  * `-r`: 라우팅 테이블 표시
  * `-i`: 네트워크 인터페이스 통계 표시

    예시:

    ```bash
    netstat -ant
    sudo netstat -tulnp
    netstat -r
    netstat -i
    ```

* **`ss` (socket statistics):** `netstat`을 대체하는 새로운 명령어입니다. 더 빠르고 효율적이며, 더 많은 정보를 제공합니다.

    ```bash
    ss [옵션]
    ```

    자주 사용되는 옵션:

  * `-a`: 모든 소켓 표시
  * `-t`: TCP 소켓만 표시
  * `-u`: UDP 소켓만 표시
  * `-l`: Listening 소켓만 표시
  * `-n`: 주소와 포트 번호를 숫자로 표시
  * `-p`: 소켓과 관련된 프로세스 정보 표시 (root 권한 필요)
  * `-r`: Resolved 된 호스트 이름 대신 숫자 주소 표시
  * `-i`: 내부 TCP 정보를 표시

    예시:

    ```bash
    ss -ant
    sudo ss -tulnp
    ss -r
    ss -i
    ```


### 4.5.5. DNS 관련 도구 (host, dig)

* **`host`**: 도메인 이름과 IP 주소 간의 변환을 수행하는 간단한 유틸리티입니다.

    ```bash
    host <호스트 이름 또는 IP 주소> [DNS 서버]
    ```

    예시:

    ```bash
    host google.com
    host 8.8.8.8
    host -t MX google.com # MX 레코드 조회
    host -t NS google.com # NS 레코드 조회
    host google.com 8.8.8.8 # 특정 DNS 서버에 질의
    ```

* **`dig` (domain information groper)**: DNS 쿼리를 보내고 응답을 표시하는 더 강력하고 유연한 도구입니다. 다양한 레코드 유형을 조회하고, DNS 서버를 지정하며, 쿼리 옵션을 세밀하게 제어할 수 있습니다.

    ```bash
    dig [옵션] <이름> [유형] [@서버]
    ```

    자주 사용되는 옵션 및 인수:

  * `<이름>`: 조회할 도메인 이름 또는 IP 주소
  * `<유형>`: 조회할 레코드 유형 (A, MX, NS, CNAME 등). 생략하면 A 레코드를 조회합니다.
  * `@<서버>`: 사용할 DNS 서버 IP 주소 또는 호스트 이름
  * `+trace`: DNS 쿼리 과정을 추적합니다.
  * `+short`: 간결한 응답만 표시합니다.

    예시:

    ```bash
    dig google.com
    dig MX google.com
    dig @8.8.8.8 example.com
    dig +trace naver.com
    dig +short www.daum.net
    ```

이러한 네트워크 관련 명령어 및 도구들을 숙지하면 리눅스 시스템의 네트워크 연결 상태를 확인하고 문제를 진단하며, DNS 관련 정보를 조회하는 등 다양한 네트워크 관련 작업을 수행할 수 있습니다.


## 4.6. 셸 스크립팅 기초

셸 스크립트는 셸 명령어를 순차적으로 실행하는 텍스트 파일입니다. 반복적인 작업을 자동화하거나, 복잡한 작업을 일련의 명령어로 묶어 실행하는 데 유용합니다. 이 장에서는 기본적인 셸 스크립트 작성 방법, 변수 사용법, 조건문, 반복문, 그리고 간단한 스크립트 예제를 통해 셸 스크립팅의 기초를 학습합니다.


### 4.6.1. 셸 스크립트 작성 및 실행

**스크립트 파일 생성:**

일반적인 텍스트 편집기 (`nano`, `vim` 등)를 사용하여 `.sh` 확장자를 가진 텍스트 파일을 생성합니다.

```bash
nano my_script.sh
```

**Shebang 라인:**

스크립트 파일의 첫 번째 줄에는 어떤 셸을 사용하여 스크립트를 실행할지 명시하는 Shebang 라인을 작성하는 것이 관례입니다. 일반적으로 Bash 셸을 사용하므로 다음과 같이 작성합니다.

```bash
#!/bin/bash
```

**명령어 작성:**

Shebang 라인 아래에는 실행할 셸 명령어를 한 줄에 하나씩 작성합니다. 주석은 `#` 기호로 시작합니다.

```bash
#!/bin/bash

# 간단한 셸 스크립트 예제
echo "현재 디렉토리:"
pwd

echo "파일 목록:"
ls -l

echo "스크립트 종료"
```

**실행 권한 부여:**

스크립트 파일을 실행하기 전에 실행 권한을 부여해야 합니다.

```bash
chmod +x my_script.sh
```

**스크립트 실행:**

다음과 같은 방법으로 스크립트를 실행합니다.

* **현재 디렉토리에서 실행:**

    ```bash
    ./my_script.sh
    ```

* **`bash` 명령어로 실행:**

    ```bash
    bash my_script.sh
    ```

    이 방법은 실행 권한이 없어도 스크립트를 실행할 수 있습니다.


### 4.6.2. 변수 사용법

셸 스크립트에서 변수를 사용하여 값을 저장하고 참조할 수 있습니다.

**변수 할당:**

변수에 값을 할당할 때는 `=` 기호를 사용하며, 변수 이름과 값 사이에 공백이 없어야 합니다.

```bash
MY_VARIABLE="Hello, world!"
COUNT=10
```

**변수 참조:**

변수에 저장된 값을 참조하려면 변수 이름 앞에 `$` 기호를 붙이거나, `{}`로 감싸서 사용합니다. `{}`는 변수 이름과 뒤따르는 문자열을 명확하게 구분할 때 유용합니다.

```bash
echo $MY_VARIABLE
echo ${COUNT}
echo "현재 카운트: ${COUNT}개"
```

**환경 변수:**

리눅스 시스템에는 미리 정의된 환경 변수들이 있습니다. 예를 들어, `USER` (현재 사용자 이름), `HOME` (현재 사용자 홈 디렉토리), `PATH` (실행 파일 검색 경로) 등이 있습니다. 환경 변수도 `$` 기호를 사용하여 참조할 수 있습니다.

```bash
echo "현재 사용자: $USER"
echo "홈 디렉토리: $HOME"
echo "PATH 환경 변수: $PATH"
```


### 4.6.3. 조건문 (if, then, else, elif, fi)

조건문을 사용하여 특정 조건이 참인지 거짓인지에 따라 다른 명령어를 실행할 수 있습니다.

```bash
if [ 조건 ]; then
  # 조건이 참일 때 실행할 명령어
elif [ 다른 조건 ]; then
  # 다른 조건이 참일 때 실행할 명령어
else
  # 모든 조건이 거짓일 때 실행할 명령어
fi
```

* `if`, `then`, `else`, `elif`, `fi`는 예약어입니다.
* `[ 조건 ]` 부분에는 조건을 검사하는 명령어나 표현식을 사용합니다. `[`와 `]` 사이에는 공백이 있어야 합니다.
* 조건을 검사하는 데 자주 사용되는 명령어:
  * `test <표현식>` 또는 `[ <표현식> ]`: 다양한 파일 속성, 문자열 비교, 숫자 비교 등을 수행합니다.
  * 파일 관련 조건: `-f` (정규 파일), `-d` (디렉토리), `-e` (존재 여부), `-r` (읽기 가능), `-w` (쓰기 가능), `-x` (실행 가능) 등
  * 문자열 비교: `=` (같음), `!=` (다름), `-z` (길이 0), `-n` (길이 0 아님) 등
  * 숫자 비교: `-eq` (같음), `-ne` (다름), `-gt` (큼), `-ge` (크거나 같음), `-lt` (작음), `-le` (작거나 같음) 등

예시:

```bash
#!/bin/bash

FILE="my_file.txt"

if [ -f "$FILE" ]; then
  echo "$FILE 파일이 존재합니다."
else
  echo "$FILE 파일이 존재하지 않습니다."
fi

COUNT=5

if [ "$COUNT" -gt 10 ]; then
  echo "카운트가 10보다 큽니다."
elif [ "$COUNT" -eq 5 ]; then
  echo "카운트는 5입니다."
else
  echo "카운트는 10보다 작고 5도 아닙니다."
fi

NAME="John"

if [ "$NAME" = "John" ]; then
  echo "이름은 John입니다."
fi
```


### 4.6.4. 반복문 (for, while, until)

반복문을 사용하여 특정 명령어 블록을 여러 번 반복해서 실행할 수 있습니다.

* **`for` 반복문:** 리스트의 각 항목에 대해 명령어 블록을 실행합니다.

    ```bash
    for 변수 in 리스트; do
      # 실행할 명령어
    done
    ```

    리스트는 공백으로 구분된 문자열, 파일 목록 (`ls *`), 숫자 시퀀스 (`{1..5}`) 등이 될 수 있습니다.

    예시:

    ```bash
    #!/bin/bash

    for fruit in apple banana cherry; do
      echo "오늘의 과일: $fruit"
    done

    for i in {1..3}; do
      echo "숫자: $i"
    done

    for file in *.txt; do
      echo "텍스트 파일: $file"
    done
    ```

* **`while` 반복문:** 주어진 조건이 참인 동안 명령어 블록을 반복해서 실행합니다.

    ```bash
    while [ 조건 ]; do
      # 실행할 명령어
    done
    ```

    예시:

    ```bash
    #!/bin/bash

    COUNT=0
    while [ "$COUNT" -lt 3 ]; do
      echo "현재 카운트: $COUNT"
      COUNT=$((COUNT + 1))
    done
    ```

* **`until` 반복문:** 주어진 조건이 거짓인 동안 명령어 블록을 반복해서 실행합니다. 조건이 참이 되면 반복문이 종료됩니다.

    ```bash
    until [ 조건 ]; do
      # 실행할 명령어
    done
    ```

    예시:

    ```bash
    #!/bin/bash

    ANSWER=""
    until [ "$ANSWER" = "yes" ]; do
      read -p "종료하시겠습니까? (yes/no): " ANSWER
    done
    echo "종료합니다."
    ```


### 4.6.5. 간단한 스크립트 예제

다음은 기본적인 셸 스크립트 예제입니다.

**예제 1: 현재 날짜와 시간을 파일에 기록하는 스크립트**

```bash
#!/bin/bash

DATE=$(date)
LOG_FILE="system_log.txt"

echo "현재 날짜 및 시간: $DATE" >> "$LOG_FILE"
echo "기록 완료: $LOG_FILE"
```

**예제 2: 사용자에게 이름을 입력받아 인사하는 스크립트**

```bash
#!/bin/bash

read -p "이름을 입력하세요: " NAME

if [ -n "$NAME" ]; then
  echo "안녕하세요, $NAME님!"
else
  echo "이름이 입력되지 않았습니다."
fi
```

셸 스크립팅은 시스템 관리 작업을 자동화하고 효율성을 높이는 데 매우 강력한 도구입니다. 기본적인 문법과 명령어를 익히고, 다양한 스크립트 작성 경험을 통해 활용 능력을 향상시킬 수 있습니다.
