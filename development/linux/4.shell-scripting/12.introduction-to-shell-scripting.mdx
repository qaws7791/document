---
title: "12. 쉘 스크립트 프로그래밍 입문"
---

이전 Chapter 11까지 우리는 리눅스 쉘(Bash)의 강력한 기능들 - 리다이렉션, 파이프라인, 명령어 치환, 변수, 앨리어스, 히스토리 등 - 을 익히며 쉘 환경 자체에 더욱 능숙해졌습니다. 이러한 기능들을 활용하면 터미널에서 매우 효율적으로 작업할 수 있죠.

하지만 만약 매일 반복해야 하는 일련의 명령어들이 있다면 어떨까요? 예를 들어, 특정 디렉토리의 파일들을 백업하고, 오래된 로그 파일을 삭제한 후, 시스템 상태 보고서를 생성하는 작업을 매일 해야 한다고 가정해 봅시다. 이 명령어들을 매번 터미널에 직접 입력하는 것은 번거롭고 실수가 발생하기 쉽습니다.

바로 이럴 때 **쉘 스크립트(Shell Script)** 가 강력한 힘을 발휘합니다. 쉘 스크립트는 우리가 터미널에서 사용하는 명령어들을 **하나의 텍스트 파일에 순서대로 작성**해 놓고, 필요할 때 그 파일을 실행하여 **작업을 자동화**하는 프로그래밍 방식입니다.

이번 Chapter 12에서는 쉘 스크립트가 무엇인지, 왜 유용한지 알아보고, 아주 간단한 첫 쉘 스크립트를 직접 작성하고 실행하는 방법을 배웁니다. 또한 스크립트의 기본 구성 요소인 주석, 변수 사용법, 사용자로부터 입력을 받는 방법(`read`), 스크립트 실행 시 인자를 전달하고 처리하는 방법(위치 매개변수), 명령어의 성공/실패 여부를 확인하는 종료 상태 코드(`$?`)와 스크립트를 제어하는 `exit` 명령어, 그리고 기본적인 산술 연산 방법까지 쉘 스크립트 프로그래밍의 가장 기초적인 내용들을 다룹니다. 이제 리눅스 자동화의 첫걸음을 함께 내딛어 봅시다!


## 12.1 쉘 스크립트란? (반복 작업을 위한 레시피) (What is a Shell Script? A Recipe for Repetitive Tasks)

**쉘 스크립트(Shell Script)** 란, 간단히 말해 **쉘(Shell, 예: Bash)이 해석하고 실행할 수 있는 명령어들의 목록을 담고 있는 일반 텍스트 파일**입니다. 우리가 터미널에서 한 줄씩 입력하던 명령어들을 하나의 파일에 모아놓은 것이라고 생각할 수 있습니다.

**왜 쉘 스크립트를 사용할까요?**

* **자동화 (Automation):** 매번 반복적으로 수행해야 하는 일련의 작업들을 스크립트로 만들어두면, 단 한 번의 실행으로 모든 작업을 자동으로 처리할 수 있습니다. 이는 시간을 절약하고 사람의 실수를 줄여줍니다.
* **단순화 (Simplification):** 여러 단계로 이루어진 복잡한 작업을 하나의 스크립트로 묶어 단순화할 수 있습니다. 사용자는 스크립트 내부의 복잡한 과정을 알 필요 없이 스크립트만 실행하면 됩니다.
* **맞춤화 (Customization):** 기존 명령어들을 조합하고 프로그래밍적인 요소를 추가하여(다음 챕터에서 배울 조건문, 반복문 등), 특정 요구사항에 맞는 맞춤형 도구를 만들 수 있습니다.
* **시스템 관리:** 시스템 백업, 로그 파일 분석, 사용자 계정 생성, 서비스 모니터링 등 다양한 시스템 관리 작업을 자동화하는 데 널리 사용됩니다.

우리가 이전 챕터들에서 배운 `ls`, `cp`, `mv`, `grep`, `find` 같은 명령어들이 바로 쉘 스크립트를 구성하는 재료들입니다. 쉘 스크립트는 이 재료들을 어떻게 순서대로 조합하고 제어할지 알려주는 **레시피**와 같습니다.


## 12.2 첫 쉘 스크립트 작성 및 실행 (Writing and Running Your First Shell Script)

이제 아주 간단한 쉘 스크립트를 직접 만들어보고 실행해 봅시다.

**1단계: 스크립트 파일 생성**

먼저, 텍스트 편집기(Chapter 5에서 배운 `vim` 또는 `nano`)를 사용하여 스크립트 내용을 담을 새 파일을 생성합니다. 파일 이름은 보통 `.sh` 확장자를 붙이지만, 리눅스에서는 필수는 아닙니다.

```bash
nano hello_script.sh
# 또는
vim hello_script.sh
```

**2단계: 스크립트 내용 작성**

편집기가 열리면 다음 내용을 입력합니다.

```bash
#!/bin/bash

# 이것은 나의 첫 번째 쉘 스크립트입니다!
# 환영 메시지를 출력할 것입니다.

echo "Hello, Linux World!"
echo "Today's date is: $(date)"
```

**3단계: 파일 저장**

Vim에서는 `Esc` 키를 누른 후 `:wq` 입력 후 Enter, Nano에서는 `Ctrl + O` 누르고 Enter, 그 다음 `Ctrl + X` 를 눌러 편집기를 종료하고 파일을 저장합니다.

이제 각 부분의 의미를 자세히 알아봅시다.


### 12.2.1 Shebang (`#!/bin/bash`)의 의미 (The Meaning of Shebang)

스크립트 파일의 **가장 첫 번째 줄**에 위치하는 `#!/bin/bash` 를 **쉬뱅(Shebang)** 또는 해시뱅(Hashbang)이라고 부릅니다.

* `#!`: 이것이 스크립트 파일임을 운영체제에 알려주는 특별한 표시입니다.
* `/bin/bash`: 이 스크립트를 **해석하고 실행할 인터프리터(Interpreter) 프로그램의 경로**를 지정합니다. 즉, 이 파일 안의 명령어들은 `/bin/bash` (Bash 쉘)를 통해 실행하라는 의미입니다.
* 다른 인터프리터를 사용할 수도 있습니다. 예를 들어 Python 스크립트라면 `#!/usr/bin/python3`, Perl 스크립트라면 `#!/usr/bin/perl` 처럼 시작할 수 있습니다.
* 만약 스크립트를 항상 `bash hello_script.sh` 처럼 인터프리터를 명시하여 실행한다면 Shebang이 없어도 작동하지만, 스크립트 파일을 직접 실행 파일처럼(`./hello_script.sh`) 실행하려면 **반드시 Shebang이 필요하며, 올바른 인터프리터 경로를 지정**해야 합니다. 또한, 어떤 쉘 기반의 스크립트인지 명시하는 좋은 관례이므로 항상 포함하는 것이 좋습니다.


### 12.2.2 주석 사용하기 (`#`) (Using Comments)

스크립트 내용 중 `#` 기호로 시작하는 줄은 **주석(Comment)** 입니다.

* 주석은 쉘이 해석하지 않고 무시하는 부분입니다.
* 스크립트를 작성한 사람이나 다른 사람이 나중에 코드를 봤을 때, **스크립트의 목적이나 특정 코드 라인의 역할 등을 쉽게 이해할 수 있도록 설명**을 덧붙이는 용도로 사용됩니다.
* 복잡하거나 명확하지 않은 로직에는 주석을 다는 습관을 들이는 것이 좋습니다.
* Shebang 라인(`#!/bin/bash`)은 예외적으로 `#`으로 시작하지만 주석이 아닌 특별한 의미를 가집니다.


### 12.2.3 스크립트 실행 권한 부여 및 실행 (Granting Execute Permission and Running the Script)

텍스트 편집기로 만든 파일은 기본적으로 실행 권한(`x`)이 없습니다. 스크립트를 직접 실행 파일처럼 실행하려면 먼저 실행 권한을 부여해야 합니다.

* **실행 권한 부여 (`chmod`):** Chapter 7에서 배운 `chmod` 명령어를 사용합니다. 보통 소유자(user)에게 실행 권한을 추가합니다.

    ```bash
    chmod u+x hello_script.sh
    # 또는 숫자 모드로: chmod 755 hello_script.sh (소유자 rwx, 그룹/기타 rx)
    ```

* **스크립트 실행:** 두 가지 주요 방법이 있습니다.
    1. **인터프리터 지정 실행:** `bash` 명령어 뒤에 스크립트 파일 이름을 적어 실행합니다. 이 방법은 스크립트 파일에 실행 권한이 없어도 되고, Shebang 라인이 없어도 작동합니다.

        ```bash
        bash hello_script.sh
        ```

    2. **직접 실행 (실행 권한 필요):** 스크립트 파일의 경로를 직접 입력하여 실행합니다. **실행 권한(`x`)과 올바른 Shebang 라인이 반드시 필요**합니다.
        만약 현재 디렉토리(`.` )가 `PATH` 환경 변수에 포함되어 있지 않다면 (보안상 이유로 보통 포함하지 않음), 스크립트 이름 앞에 `./` 를 붙여 현재 디렉토리에 있는 파일임을 명시해야 합니다.

        ```bash
        ./hello_script.sh
        ```

* **실행 결과 확인:** 위 예제 스크립트를 실행하면 다음과 같은 출력을 볼 수 있습니다. (날짜는 실행 시점에 따라 다름)

    ```
    Hello, Linux World!
    Today's date is: Wed Apr  9 16:28:00 KST 2025
    ```


## 12.3 변수 사용하기 (선언, 할당, 활용) (Using Variables: Declaration, Assignment, Usage)

Chapter 11에서 배운 쉘 변수는 스크립트 내에서도 동일하게 사용됩니다. 변수를 사용하면 값을 저장해두고 필요할 때 재사용하거나, 스크립트의 동작을 유연하게 만들 수 있습니다.

* **선언 및 할당:** `변수명=값` 형태로 할당합니다. **등호(`=`) 앞뒤에 공백이 없어야 합니다.** 값에 공백이나 특수문자가 포함되면 따옴표(`"` 또는 `'`)로 감싸줍니다.
  * 큰따옴표 (`"`): 변수(`$var`)나 명령어 치환(`$(...)`)이 **해석(확장)** 됩니다.
  * 작은따옴표 (`'`): 모든 내용을 **문자 그대로** 취급합니다. 해석되지 않습니다.
* **사용(참조):** `$변수명` 또는 `${변수명}` 형태로 값을 불러옵니다.

```bash
#!/bin/bash

# 변수 할당
FILENAME="report.txt"
EDITOR_APP="vim"
USER_NAME=$(whoami) # 명령어 치환 결과를 변수에 저장
MESSAGE="Processing file: $FILENAME" # 변수 값을 포함하여 할당 (큰따옴표)

# 변수 사용
echo "Welcome, $USER_NAME!"
echo $MESSAGE
echo 'This uses single quotes: $FILENAME' # 작은따옴표 안에서는 변수가 확장되지 않음

# 변수를 명령어의 인자로 사용
echo "Opening $FILENAME with $EDITOR_APP..."
# $EDITOR_APP $FILENAME # 실제 편집기를 실행하는 부분 (주석 처리)
```

스크립트 내에서 변수를 활용하면 반복되는 값을 쉽게 관리하고 스크립트를 수정하기 용이하게 만들 수 있습니다.


## 12.4 사용자 입력 받기 (`read`) (Getting User Input)

스크립트 실행 중에 사용자로부터 직접 값을 입력받아 처리해야 할 경우가 있습니다. 이때 `read` 명령어를 사용합니다.

* **기본 사용:** `read 변수명`
  * 스크립트 실행이 잠시 멈추고 사용자의 키보드 입력을 기다립니다. 사용자가 입력하고 Enter 키를 누르면 입력된 내용이 `변수명`에 저장됩니다.
* **프롬프트와 함께 사용:** `read -p "프롬프트 메시지 " 변수명`
  * `-p` 옵션은 사용자에게 입력을 요청하는 안내 메시지(프롬프트)를 보여줍니다.
* **여러 변수에 입력받기:** `read 변수명1 변수명2 ...`
  * 사용자가 입력한 내용을 공백 기준으로 나누어 각 변수에 순서대로 저장합니다.

**예제 스크립트 (`user_info.sh`):**

```bash
#!/bin/bash

echo "--- User Information ---"

read -p "Enter your full name: " full_name
read -p "Enter your city: " city
read -p "Enter your age: " age

echo "" # 빈 줄 출력
echo "--- Summary ---"
echo "Name: $full_name"
echo "City: $city"
echo "Age: $age"
echo "---------------"
```

**실행:**

```bash
chmod u+x user_info.sh
./user_info.sh
# --- User Information ---
# Enter your full name: Hong Gildong  <-- 사용자 입력
# Enter your city: Changwon          <-- 사용자 입력
# Enter your age: 30                <-- 사용자 입력
#
# --- Summary ---
# Name: Hong Gildong
# City: Changwon
# Age: 30
# ---------------
```


## 12.5 스크립트 인자 처리 (Handling Script Arguments)

스크립트를 실행할 때 명령어 뒤에 추가적인 정보(값)를 전달하여 스크립트의 동작을 다르게 할 수 있습니다. 이를 **명령줄 인자(Command-line Arguments)** 또는 **위치 매개변수(Positional Parameters)** 라고 합니다.

쉘은 스크립트 실행 시 전달된 인자들을 특별한 변수에 자동으로 저장합니다.

* **`$0`**: 실행된 **스크립트의 이름** 자체.
* **`$1`**: 스크립트에 전달된 **첫 번째 인자**.
* **`$2`**: 스크립트에 전달된 **두 번째 인자**.
* **`$3` ... `$9`**: 세 번째부터 아홉 번째 인자.
* **`${10}`, `${11}`, ...**: 열 번째 이상의 인자 (중괄호 필요).
* **`$#`**: 스크립트에 전달된 **총 인자의 개수** (`$0` 제외).
* **`$*`**: 전달된 **모든 인자들을 하나의 문자열**로 합쳐서 나타냅니다. (각 인자는 공백으로 구분됨. 큰따옴표로 묶으면 `"$1 $2 $3 ..."` 처럼 하나의 단어로 취급).
* **`$@`**: 전달된 **모든 인자들을 각각 별개의 문자열**로 취급합니다. (큰따옴표로 묶으면 `"$1" "$2" "$3" ...` 처럼 각 인자가 개별 단어로 유지됨). **일반적으로 인자 목록을 반복 처리하거나 다른 명령어에 전달할 때 `$*` 보다 `"$@"` 를 사용하는 것이 더 안전하고 정확합니다.**

**예제 스크립트 (`arguments.sh`):**

```bash
#!/bin/bash

echo "Script Name: $0"
echo "Number of arguments: $#"
echo "First argument: $1"
echo "Second argument: $2"
echo "All arguments as single string (\$*): $*"
echo "All arguments as separate strings (\$@): $@"

echo ""
echo "Looping through arguments using \"\$@\":"
count=1
for arg in "$@"  # "$@" 를 사용하는 것이 중요!
do
  echo "  Argument $count: $arg"
  count=$((count + 1))
done
```

**실행:**

```bash
chmod u+x arguments.sh
./arguments.sh apple "banana tree" orange
# Script Name: ./arguments.sh
# Number of arguments: 3
# First argument: apple
# Second argument: banana tree
# All arguments as single string ($*): apple banana tree orange
# All arguments as separate strings ($@): apple banana tree orange
#
# Looping through arguments using "$@":
#   Argument 1: apple
#   Argument 2: banana tree
#   Argument 3: orange
```

(큰따옴표로 묶인 "banana tree"가 하나의 인자로 제대로 처리되는 것을 확인하세요.)


## 12.6 종료 상태 코드 (`$?`)와 `exit` 명령어 (Exit Status Code and the `exit` Command)

리눅스에서 모든 명령어는 실행 완료 후 **종료 상태 코드(Exit Status Code)** 라는 정수 값을 반환하여, 성공적으로 실행되었는지 아니면 오류가 발생했는지를 알립니다.

* **종료 상태 코드 규칙 (관례):**
  * **`0`**: 명령어 **성공**적으로 실행 완료.
  * **`0` 이 아닌 값 (보통 1 ~ 255):** 명령어 실행 중 **오류 발생** 또는 실패. 값에 따라 오류의 종류를 구분하기도 합니다.

* **`$?` 특수 변수:** **바로 이전에 실행된 명령어**의 종료 상태 코드를 담고 있는 특별한 쉘 변수입니다. 스크립트 내에서 특정 명령어의 성공 여부를 확인하는 데 매우 중요합니다.

* **`exit` 명령어:** 현재 실행 중인 **쉘 스크립트를 즉시 종료**시키고, 해당 스크립트의 종료 상태 코드를 지정합니다.
  * `exit 0`: 스크립트가 **성공적으로 종료**되었음을 알립니다. (상태 코드 0)
  * `exit 1`: 스크립트 실행 중 **오류가 발생**했음을 알립니다. (일반적인 오류 상태 코드 1)
  * `exit <숫자>`: 0~255 사이의 특정 숫자를 지정하여 종료 상태 코드를 설정합니다.
  * `exit` 명령어 뒤에 숫자를 생략하면, `exit` 직전에 마지막으로 실행된 명령어의 종료 상태 코드를 그대로 반환하며 종료합니다.

**예제 스크립트 (`check_file.sh`):**

```bash
#!/bin/bash

FILENAME=$1 # 첫 번째 인자를 파일 이름으로 사용

# 파일이 존재하는지 확인 (-e 옵션)
ls "$FILENAME" > /dev/null 2>&1 # ls 명령어의 출력은 버림
status=$? # ls 명령어의 종료 상태 코드를 status 변수에 저장

# 종료 상태 코드 확인 (if 문은 다음 챕터에서 자세히 배웁니다)
if [ $status -eq 0 ]; then
  echo "File '$FILENAME' exists."
  exit 0 # 성공 종료
else
  echo "Error: File '$FILENAME' not found."
  exit 1 # 오류 종료
fi
```

**실행:**

```bash
# 존재하는 파일 확인
touch existing_file.txt
./check_file.sh existing_file.txt
# File 'existing_file.txt' exists.
echo $? # 스크립트의 종료 코드 확인 -> 0 출력

# 존재하지 않는 파일 확인
./check_file.sh non_existent_file.txt
# Error: File 'non_existent_file.txt' not found.
echo $? # 스크립트의 종료 코드 확인 -> 1 출력
```


## 12.7 산술 연산 (Arithmetic Operations)

쉘 스크립트 내에서 기본적인 정수(Integer) 산술 연산을 수행할 수 있습니다.

* **`expr` 명령어:** 오래된 방식이며, 연산자 앞뒤에 공백이 필요하고 일부 연산자(`*` 등)는 쉘에 의해 다른 의미로 해석되지 않도록 이스케이프(`\`)해야 하는 등 다소 불편합니다.

    ```bash
    sum=$(expr 10 + 5)
    product=$(expr $num1 \* $num2) # 곱셈 기호(*) 이스케이프 필요
    echo $sum
    ```

* **`$((...))` 산술 확장 (Arithmetic Expansion) - 권장 방식:** Bash 쉘에서 제공하는 더 현대적이고 편리하며 효율적인 방식입니다. C 언어와 유사한 연산자를 `$(())` 안에 직접 사용할 수 있습니다. 변수명 앞에 `$`를 붙이지 않아도 됩니다.
  * 지원 연산자: `+` (덧셈), `-` (뺄셈), `*` (곱셈), `/` (나눗셈 - 정수 나눗셈), `%` (나머지), `**` (거듭제곱) 등

    ```bash
    num1=15
    num2=4

    echo "덧셈: $((num1 + num2))"       # 출력: 19
    echo "뺄셈: $((num1 - num2))"       # 출력: 11
    echo "곱셈: $((num1 * num2))"       # 출력: 60
    echo "나눗셈 (정수): $((num1 / num2))" # 출력: 3
    echo "나머지: $((num1 % num2))"     # 출력: 3
    echo "거듭제곱: $((num2 ** 3))"    # 출력: 64 (4의 3제곱)

    # 변수 값 증가 예시
    count=0
    count=$((count + 1)) # 또는 count=$((++count)) 또는 ((count++))
    echo "카운터: $count"         # 출력: 1
    ```


## 결론

이번 챕터에서는 쉘 스크립트의 기본적인 개념과 작성 및 실행 방법을 배웠습니다. 스크립트 자동화의 첫걸음으로, Shebang(`#!/bin/bash`), 주석(`#`), 실행 권한(`chmod +x`)의 중요성을 이해했습니다.

또한 스크립트의 핵심 요소인 변수 선언 및 활용, `read` 명령어를 통한 사용자 입력 처리, `$1`, `$@`, `$#` 등을 이용한 명령줄 인자 처리 방법을 익혔습니다. 명령어의 성공/실패를 판단하는 기준인 종료 상태 코드(`$?`)와 스크립트 흐름을 제어하는 `exit` 명령어, 그리고 `$((...))` 를 이용한 기본적인 산술 연산 방법까지 살펴보았습니다.

여기서 배운 내용들은 앞으로 더 복잡하고 유용한 쉘 스크립트를 작성하기 위한 필수적인 기초입니다. 간단하더라도 이전 챕터들에서 배운 명령어들을 조합하여 자신만의 스크립트를 만들어보는 연습을 해보시길 바랍니다. 예를 들어, 특정 디렉토리의 파일 개수를 세는 스크립트, 사용자 이름을 입력받아 환영 메시지를 출력하는 스크립트 등을 만들어 볼 수 있겠죠.

다음 Chapter 13에서는 쉘 스크립트를 진정한 '프로그래밍'으로 만들어주는 핵심 요소인 **흐름 제어(Control Flow)**, 즉 조건에 따라 다른 명령을 실행하는 **조건문(`if`, `case`)** 과 특정 작업을 반복 수행하는 **반복문(`for`, `while`)** 에 대해 배우게 됩니다.
