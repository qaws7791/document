---
title: "16. 원격 접속과 파일 전송"
---

이전 Chapter 15에서는 리눅스 시스템의 네트워크 설정을 확인하고 구성하는 기초적인 방법을 배웠습니다. 네트워크를 통해 리눅스 시스템이 외부와 통신할 준비가 되었다면, 이제 다른 컴퓨터에서 이 리눅스 시스템에 **원격으로 접속**하여 관리하거나, 시스템 간에 **파일을 안전하게 주고받는** 방법이 필요합니다.

과거에는 `telnet` 이나 `ftp` 같은 프로토콜이 원격 접속 및 파일 전송에 사용되었지만, 이들은 데이터를 암호화하지 않고 평문으로 전송하기 때문에 보안에 매우 취약합니다. 오늘날에는 **SSH(Secure Shell)** 프로토콜을 기반으로 한 안전한 방법들이 표준으로 사용됩니다.

이번 Chapter 16에서는 리눅스 원격 관리의 핵심인 **SSH**를 사용하여 안전하게 원격 시스템에 접속하는 방법(비밀번호 및 키 기반 인증), 기본적인 SSH 서버 설정 및 보안 강화 팁을 알아봅니다. 또한, SSH를 기반으로 안전하게 파일을 전송하는 주요 도구인 **`scp`**, **`sftp`**, **`rsync`** 의 사용법을 익히고, 각 도구의 특징과 적합한 사용 사례를 비교해 봅니다. 마지막으로 보안상 취약한 `telnet` 과 원격 데스크톱 접속 방식인 VNC에 대해서도 간략히 참고 삼아 소개합니다.


## 16.1 안전한 원격 접속: SSH (Secure Shell)

**SSH(Secure Shell)** 는 안전하지 않은 네트워크(예: 인터넷)를 통해 다른 컴퓨터에 **안전하게 로그인하고 명령어를 실행**할 수 있도록 해주는 암호화된 네트워크 프로토콜 및 관련 도구 모음입니다. 원격 리눅스 서버를 관리하는 데 있어 사실상 표준적인 방법입니다.

* **주요 특징:**
  * **암호화 (Encryption):** 클라이언트와 서버 간의 모든 통신 내용(아이디, 비밀번호, 명령어, 출력 결과 등)을 암호화하여 중간에서 데이터를 가로채더라도 내용을 알 수 없도록 보호합니다.
  * **인증 (Authentication):** 접속하려는 사용자가 정말 본인이 맞는지(사용자 인증), 그리고 접속하려는 서버가 정말 그 서버가 맞는지(호스트 인증) 확인합니다.
  * **무결성 (Integrity):** 전송 중 데이터가 위변조되지 않았음을 보장합니다.

* **클라이언트-서버 모델:** SSH는 클라이언트-서버 구조로 작동합니다.
  * **SSH 서버:** 원격 접속을 허용하려는 리눅스 시스템에서 실행되는 데몬(daemon) 프로그램입니다 (보통 `sshd`). 기본적으로 TCP 포트 22번에서 클라이언트의 접속을 기다립니다.
  * **SSH 클라이언트:** 사용자가 원격 서버에 접속하기 위해 사용하는 프로그램입니다.


### 16.1.1 SSH 클라이언트 사용법 (Using the SSH Client)

SSH 클라이언트를 사용하여 원격 서버에 접속하는 방법입니다.

* **기본 접속 명령어:**

    ```bash
    ssh <사용자명>@<호스트명 또는 IP주소>
    ```

    예: `ssh alice@192.168.1.100` 또는 `ssh bob@example.server.com`

* **최초 접속 시 호스트 키 확인:** 특정 서버에 **처음으로 SSH 접속**을 시도하면, 다음과 유사한 메시지가 나타나며 서버의 공개키 지문(fingerprint)을 신뢰할 것인지 묻습니다.

    ```
    The authenticity of host 'example.server.com (192.168.1.100)' can't be established.
    ED25519 key fingerprint is SHA256:AbCdEfGhIjKlMnOpQrStUvWxYz0123456789abcDEFghi.
    Are you sure you want to continue connecting (yes/no/[fingerprint])?
    ```

  * 이는 중간자 공격(Man-in-the-middle attack)을 방지하기 위한 과정입니다. 접속하려는 서버가 정말 맞는지 확인하고 `yes`를 입력하면, 서버의 공개키가 클라이언트의 `~/.ssh/known_hosts` 파일에 저장됩니다.
  * 이후 동일 서버에 접속할 때는 이 메시지가 나타나지 않습니다. 만약 **저장된 키와 다른 키를 서버가 제시하면 경고 메시지**가 뜨는데, 이는 서버가 재설치되었거나 중간자 공격의 가능성이 있음을 의미하므로 원인을 확인해야 합니다.

* **비밀번호 인증:** 호스트 키 확인 후, 기본적으로 원격 서버의 해당 사용자 계정 **비밀번호**를 입력하라는 메시지가 나타납니다.

* **포트 번호 지정 (`-p`):** SSH 서버가 기본 포트(22)가 아닌 다른 포트에서 실행 중일 경우 `-p` 옵션으로 포트 번호를 지정합니다.

    ```bash
    ssh -p 2222 alice@example.server.com
    ```

* **단일 명령어 실행:** 로그인 세션을 유지하지 않고 원격 서버에서 특정 명령어만 실행하고 결과를 받아보려면 명령어 문자열을 뒤에 붙입니다.

    ```bash
    ssh bob@server1 "uptime"
    ssh charlie@server2 "df -h /data"
    ```

* **클라이언트 프로그램:**
  * **Linux/macOS:** 대부분 `OpenSSH` 클라이언트(`ssh` 명령어)가 기본적으로 설치되어 있어 터미널에서 바로 사용 가능합니다.
  * **Windows:**
    * 최신 Windows 10/11: `OpenSSH` 클라이언트가 내장되어 있거나 '선택적 기능'으로 설치 가능합니다. 명령 프롬프트(cmd)나 PowerShell에서 `ssh` 명령어를 사용할 수 있습니다.
    * **PuTTY:** 오랫동안 널리 사용된 무료 오픈소스 그래픽 SSH 클라이언트입니다. GUI 환경에서 호스트 주소, 포트 등을 입력하여 접속하며, 키 관리 방식이 OpenSSH와 약간 다릅니다 (`.ppk` 파일 사용).
    * Windows Terminal / WSL: WSL 환경 내에서는 리눅스와 동일하게 `ssh` 명령어를 사용할 수 있습니다.


### 16.1.2 SSH 서버 설정 (`/etc/ssh/sshd_config` 주요 옵션) (SSH Server Configuration)

원격 접속을 받아들이는 SSH 서버(`sshd` 데몬)의 동작은 `/etc/ssh/sshd_config` 설정 파일을 통해 제어할 수 있습니다. 이 파일을 수정하려면 `sudo` 권한이 필요하며, **수정 후에는 반드시 `sshd` 서비스를 재시작하거나 설정을 다시 불러와야 적용됩니다.** (`sudo systemctl restart sshd` 또는 `sudo systemctl reload sshd`)

**!!! 경고: 이 파일을 잘못 수정하면 원격 접속이 불가능해질 수 있습니다! 항상 신중하게 수정하고, 가능하면 수정 전 백업을 권장합니다. !!!**

* **주요 설정 항목:**
  * `Port 22`: `sshd`가 접속을 기다리는 포트 번호입니다. 기본값은 22입니다. 보안 강화를 위해 다른 포트(예: `Port 2200`)로 변경하기도 하지만, 이는 단지 공격 대상이 되는 것을 약간 어렵게 할 뿐 근본적인 보안 대책은 아닙니다. 포트를 변경했다면 클라이언트에서도 `-p` 옵션으로 해당 포트를 지정해야 합니다.
  * `PermitRootLogin yes | prohibit-password | no`: `root` 사용자의 SSH 로그인을 허용할지 제어합니다.
    * `yes`: `root` 로그인 허용 (비밀번호 또는 키) - **보안상 매우 위험, 권장하지 않음!**
    * `prohibit-password`: 키 기반 인증으로는 `root` 로그인을 허용하지만, 비밀번호 기반 로그인은 금지합니다. (여전히 위험)
    * `no`: `root` 사용자의 SSH 로그인을 **완전히 금지**합니다. **가장 안전한 설정**입니다. 일반 사용자로 로그인한 후 `sudo`를 사용하는 것이 좋습니다.
  * `PasswordAuthentication yes | no`: 비밀번호 기반 로그인을 허용할지 여부입니다. **키 기반 인증(아래 설명)을 설정했다면 보안 강화를 위해 `no`로 설정하는 것을 강력히 권장**합니다.
  * `PubkeyAuthentication yes | no`: 공개키 기반 인증을 허용할지 여부입니다. (보통 기본값은 `yes`)
  * `AllowUsers 사용자1 사용자2@호스트`: 지정된 사용자(또는 특정 호스트에서 접속하는 사용자)만 로그인을 허용합니다.
  * `AllowGroups 그룹1 그룹2`: 지정된 그룹에 속한 사용자만 로그인을 허용합니다.
  * `PermitEmptyPasswords no`: 빈 비밀번호를 가진 계정의 로그인을 금지합니다. (반드시 `no`여야 함)
  * `ChallengeResponseAuthentication yes | no`: PAM 등 다른 인증 방식을 사용할지 여부 (비밀번호 인증과 연관될 수 있음). 키 기반 인증만 사용할 경우 `no`로 설정하기도 합니다.
  * `UsePAM yes`: PAM(Pluggable Authentication Modules)을 사용하여 리눅스 시스템 계정 인증과 연동합니다. (보통 `yes`)


### 16.1.3 키 기반 인증 설정 (Setting Up Key-Based Authentication)

비밀번호 대신 **암호화 키 쌍(Key Pair)** 을 이용하여 SSH 접속을 인증하는 방식입니다. 비밀번호 방식보다 훨씬 안전하며, 비밀번호를 입력할 필요가 없어 편리하기까지 합니다.

* **원리:** 사용자는 자신의 컴퓨터(클라이언트)에 **비밀 키(Private Key)** 를 안전하게 보관하고, 접속하려는 서버에는 해당 비밀 키와 쌍을 이루는 **공개 키(Public Key)** 를 미리 등록해 놓습니다. 접속 시 서버는 클라이언트에게 특정 요청을 보내고, 클라이언트는 자신의 비밀 키를 이용해서만 올바르게 응답할 수 있습니다. 서버는 등록된 공개 키를 통해 클라이언트의 응답을 검증하여 인증합니다. 비밀 키는 절대로 네트워크를 통해 전송되지 않습니다.

* **설정 단계:**
    1. **키 쌍 생성 (클라이언트에서):** `ssh-keygen` 명령어를 사용하여 공개키/비밀키 쌍을 생성합니다.

        ```bash
        # RSA 방식 (전통적, 4096비트 권장)
        ssh-keygen -t rsa -b 4096

        # Ed25519 방식 (최신, 더 안전하고 빠름 - 권장)
        ssh-keygen -t ed25519
        ```

        * 키 저장 위치 질문: 기본값(`~/.ssh/id_ed25519` 또는 `~/.ssh/id_rsa`)을 사용하려면 그냥 Enter.
        * **암호(Passphrase) 입력 질문:** (선택 사항) 비밀 키 파일을 암호로 한번 더 보호합니다. 암호를 설정하면 SSH 접속 시 이 암호를 입력해야 합니다. 설정하지 않으려면 그냥 Enter. **설정하는 것이 더 안전합니다.**
        * 생성 결과: 홈 디렉토리 아래 `.ssh` 디렉토리에 `id_ed25519` (비밀 키 - **절대 외부에 노출 금지!**)와 `id_ed25519.pub` (공개 키) 파일이 생성됩니다. (RSA의 경우 `id_rsa`, `id_rsa.pub`)

    2. **공개 키를 서버에 복사:** 생성된 **공개 키(`~/.ssh/id_ed25519.pub` 파일의 내용)** 를 접속하려는 **서버**의 해당 사용자 홈 디렉토리 아래 `.ssh/authorized_keys` 파일에 추가해야 합니다.
        * **방법 A (권장 - `ssh-copy-id` 사용):** 클라이언트에 `ssh-copy-id` 명령어가 있다면 가장 쉽고 안전합니다. 알아서 서버에 접속하여 키를 복사하고 적절한 권한까지 설정해줍니다.

            ```bash
            ssh-copy-id <사용자명>@<호스트명 또는 IP주소>
            # 서버의 사용자 비밀번호를 한 번 입력해야 함
            ```

        * **방법 B (수동 복사):**

            ```bash
            # 1. 클라이언트에서 공개키 내용 확인 및 복사
            cat ~/.ssh/id_ed25519.pub

            # 2. 서버에 (비밀번호로) 로그인하여 작업 수행
            #    .ssh 디렉토리가 없으면 생성하고 권한 설정 (매우 중요!)
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh

            #    authorized_keys 파일에 복사한 공개키 내용 붙여넣기 (편집기 사용)
            nano ~/.ssh/authorized_keys

            #    authorized_keys 파일 권한 설정 (매우 중요!)
            chmod 600 ~/.ssh/authorized_keys
            ```

            (주의: `.ssh` 디렉토리는 `700`, `authorized_keys` 파일은 `600` 권한이어야 제대로 작동합니다.)

    3. **접속 테스트:** 다시 `ssh <사용자명>@<호스트명 또는 IP주소>` 로 접속을 시도합니다. 키 생성 시 암호를 설정했다면 암호를 물어볼 것이고, 설정하지 않았다면 비밀번호 입력 없이 바로 로그인되어야 합니다.

    4. **(선택 사항 - 강력 권장) 비밀번호 인증 비활성화:** 키 기반 로그인이 성공적으로 작동하는 것을 확인했다면, 서버의 `/etc/ssh/sshd_config` 파일에서 `PasswordAuthentication no` 로 설정하고 `sshd` 서비스를 재시작하여 보안을 더욱 강화합니다.


### 16.1.4 SSH 보안 강화 팁 (SSH Security Hardening Tips)

SSH 서버를 안전하게 운영하기 위한 몇 가지 권장 사항입니다.

* **키 기반 인증 사용, 비밀번호 인증 비활성화.** (가장 중요!)
* 비밀 키에 강력한 암호(Passphrase) 설정.
* 루트 로그인 금지 (`PermitRootLogin no`).
* 기본 포트(22) 변경 (약간의 보안 향상).
* 방화벽(Chapter 15)을 사용하여 SSH 접속 허용 IP 제한.
* SSH 클라이언트 및 서버 소프트웨어 최신 상태 유지.
* `fail2ban` 같은 도구를 사용하여 반복적인 로그인 실패 시도를 하는 IP 자동 차단.
* `AllowUsers` 또는 `AllowGroups` 지시어를 사용하여 접속 가능한 사용자/그룹 제한.


## 16.2 원격 파일 전송 (`scp`, `sftp`, `rsync`) (Remote File Transfer)

SSH는 안전한 원격 접속뿐만 아니라, 파일을 안전하게 전송하는 기반을 제공합니다. 주로 다음 세 가지 명령어가 사용됩니다.


### 16.2.1 `scp` (Secure Copy)

SSH 프로토콜을 사용하여 로컬 호스트와 원격 호스트 간에 파일을 **안전하게 복사**하는 명령줄 유틸리티입니다. 사용법이 로컬 `cp` 명령어와 매우 유사합니다.

* **기본 형식:**
  * 로컬 -> 원격: `scp [옵션] <로컬 파일 경로> <사용자명>@<호스트명>:<원격 디렉토리 경로>`
  * 원격 -> 로컬: `scp [옵션] <사용자명>@<호스트명>:<원격 파일 경로> <로컬 디렉토리 경로>`
* **주요 옵션:**
  * `-r`: 디렉토리를 **재귀적(Recursive)** 으로 복사합니다.
  * `-P <포트번호>`: SSH 포트 번호가 22가 아닐 경우 지정합니다. (**주의: `ssh` 는 `-p` 이지만 `scp` 는 대문자 `-P` 입니다!**)
  * `-v`: 상세한 진행 과정(Verbose)을 보여줍니다.

* **예시:**

    ```bash
    # 로컬의 backup.tar.gz 파일을 server1 의 alice 홈 디렉토리로 복사
    scp backup.tar.gz alice@server1:~/

    # server1 의 /etc/nginx/nginx.conf 파일을 현재 로컬 디렉토리(.)로 복사
    scp alice@server1:/etc/nginx/nginx.conf .

    # 로컬의 web_files 디렉토리 전체를 server2 의 /var/www/html/ 디렉토리 아래로 복사
    scp -r web_files bob@server2:/var/www/html/

    # 포트 2222를 사용하는 server3 에서 파일 다운로드
    scp -P 2222 charlie@server3:/logs/app.log ~/logs/
    ```

`scp`는 간단한 파일을 한두 개 빠르게 복사할 때 편리합니다. 인증 방식은 SSH와 동일합니다(비밀번호 또는 키).


### 16.2.2 `sftp` (SSH File Transfer Protocol)

SSH 연결 위에서 동작하는 **안전한 FTP(File Transfer Protocol)와 유사한 대화형 파일 전송** 프로토콜 및 클라이언트입니다. 원격 서버의 파일 시스템을 탐색하고, 여러 파일을 올리고 내리는 등의 작업을 대화형 인터페이스를 통해 수행할 수 있습니다.

* **접속:** `sftp <사용자명>@<호스트명 또는 IP주소>`
* **`sftp>` 프롬프트에서 사용하는 주요 명령어:**
  * `ls`, `pwd`, `cd <디렉토리>`: **원격(Remote)** 서버의 파일 목록 보기, 현재 경로 확인, 디렉토리 이동
  * `lls`, `lpwd`, `lcd <디렉토리>`: **로컬(Local)** 컴퓨터의 파일 목록 보기, 현재 경로 확인, 디렉토리 이동
  * `get <원격 파일> [로컬 파일]` : 원격 파일을 로컬로 다운로드
  * `put <로컬 파일> [원격 파일]` : 로컬 파일을 원격으로 업로드
  * `mget <원격 파일 패턴>`: 여러 원격 파일 다운로드 (와일드카드 `*` 등 사용 가능)
  * `mput <로컬 파일 패턴>`: 여러 로컬 파일 업로드
  * `mkdir <디렉토리명>`, `rmdir <디렉토리명>`, `rm <파일명>`: 원격 서버에서 디렉토리/파일 관리
  * `help` 또는 `?`: 사용 가능한 명령어 도움말 보기
  * `quit` 또는 `bye`: `sftp` 종료

`sftp`는 원격 디렉토리 구조를 확인하면서 여러 파일을 전송하거나 관리해야 할 때 유용합니다.


### 16.2.3 `rsync` (Remote Sync)

로컬 또는 원격 호스트 간에 **파일과 디렉토리를 효율적으로 동기화**하는 매우 강력하고 유연한 유틸리티입니다. SSH를 전송 프로토콜로 사용할 수 있습니다. `rsync`의 가장 큰 특징은 파일 전체를 무조건 복사하는 대신, **변경된 부분만 전송하는 델타 전송(delta transfer) 알고리즘**을 사용하여 매우 빠르고 효율적이라는 점입니다. 특히 **백업 및 디렉토리 미러링** 작업에 탁월합니다.

* **기본 형식:**
  * 로컬 동기화: `rsync [옵션] <원본 디렉토리/> <대상 디렉토리>`
  * 원격 동기화 (로컬 -> 원격): `rsync [옵션] <로컬 디렉토리/> <사용자명>@<호스트명>:<원격 디렉토리>`
  * 원격 동기화 (원격 -> 로컬): `rsync [옵션] <사용자명>@<호스트명>:<원격 디렉토리/> <로컬 디렉토리>`
  * **주의:** 원본 경로 끝에 슬래시(`/`)를 붙이면 디렉토리 '내용물'을 복사하고, 붙이지 않으면 디렉토리 '자체'를 대상 디렉토리 아래에 생성하며 복사하는 경향이 있습니다. 동작 방식이 중요하므로 테스트가 필요합니다.

* **자주 사용하는 유용한 옵션:**
  * `-a` (archive): 아카이브 모드. `-rlptgoD` 옵션들을 합친 것과 유사하며, **디렉토리 재귀 복사, 심볼릭 링크 보존, 권한 보존, 타임스탬프 보존, 소유자/그룹 보존** 등을 포함하여 백업 및 동기화에 매우 유용합니다. **가장 일반적으로 사용되는 옵션입니다.**
  * `-v` (verbose): 자세한 진행 상황을 보여줍니다.
  * `-z` (compress): 전송 중 데이터를 압축합니다. 네트워크 대역폭이 좁을 때 유리합니다.
  * `-h` (human-readable): 파일 크기 등을 사람이 읽기 쉬운 단위로 보여줍니다 (요약 정보 등에서).
  * `--progress`: 파일 전송 진행 상태를 보여줍니다 (대용량 파일 전송 시 유용).
  * `--delete`: **원본에 없는 파일은 대상에서 삭제**합니다. 미러링(완전히 동일하게 만들기) 시 사용하지만, **대상 디렉토리의 파일이 삭제될 수 있으므로 매우 주의**해야 합니다.
  * `--exclude=<패턴>`: 지정한 패턴과 일치하는 파일/디렉토리는 동기화에서 제외합니다.
  * `-e ssh`: 원격 전송 시 SSH를 사용하도록 명시합니다. (보통 기본값) SSH 옵션(예: 포트 변경)을 지정할 수도 있습니다: `-e 'ssh -p <포트번호>'`

* **예시:**

    ```bash
    # 로컬의 my_docs 디렉토리 내용을 원격 서버 alice 홈의 backups 디렉토리로 동기화 (압축, 진행상황 표시)
    rsync -avz --progress my_docs/ alice@server1:~/backups/

    # 원격 서버 bob의 /var/log 디렉토리를 로컬의 server_logs 로 가져오기 (삭제 옵션 주의!)
    rsync -avz --delete bob@server2:/var/log/ ~/server_logs/

    # 특정 포트(2222)를 사용하는 서버와 동기화
    rsync -avz -e 'ssh -p 2222' my_data/ charlie@server3:/data/
    ```

`rsync`는 기능이 매우 풍부하며, 백업, 서버 간 데이터 동기화, 웹사이트 배포 등 다양한 용도로 활용되는 필수적인 도구입니다.


## 16.3 [참고] 텔넷(Telnet)과 VNC (개념 및 보안 이슈) (Reference: Telnet and VNC - Concepts and Security Issues)

* **텔넷 (Telnet):**
  * 원격 호스트에 접속하여 명령줄 인터페이스를 사용할 수 있게 해주는 **오래된** 프로토콜입니다.
  * **가장 큰 문제점:** 아이디, 비밀번호를 포함한 **모든 통신 내용이 암호화되지 않은 평문**으로 전송됩니다. 네트워크 상에서 스니핑(도청)에 매우 취약합니다.
  * 현재는 **보안상의 이유로 원격 로그인 용도로는 거의 사용되지 않으며 SSH로 완전히 대체**되었습니다.
  * 아주 오래된 네트워크 장비 설정이나 특정 서비스 포트의 응답 확인 등 로컬 네트워크 내 제한적인 디버깅 용도로만 가끔 사용될 수 있습니다. (명령어: `telnet <호스트명> [포트]`)

* **VNC (Virtual Network Computing):**
  * **그래픽 데스크톱 환경**을 원격으로 제어할 수 있게 해주는 시스템입니다. 원격 컴퓨터의 화면이 내 컴퓨터 화면에 나타나고, 내 마우스와 키보드로 원격 컴퓨터를 조작할 수 있습니다.
  * VNC 프로토콜 자체는 **기본적으로 강력한 암호화를 제공하지 않는 경우가 많습니다.** (일부 구현은 자체 암호화나 TLS 지원). 따라서 중요한 작업이나 신뢰할 수 없는 네트워크에서는 **SSH 터널링**을 통해 VNC 연결을 암호화하는 것이 안전합니다.
  * 네트워크 대역폭과 CPU 자원을 비교적 많이 사용할 수 있습니다.
  * 원격지의 GUI 애플리케이션을 사용하거나 그래픽 기반의 시스템 관리가 필요할 때 유용합니다. (TigerVNC, TightVNC, RealVNC 등 다양한 서버/클라이언트 구현 존재)
  * (참고: Microsoft의 RDP, SSH 기반의 X2Go 등 다른 원격 데스크톱 기술도 있습니다.)

**결론:** 명령줄 원격 접속에는 **반드시 SSH를 사용**하고, VNC 등 그래픽 원격 접속 시에는 보안(암호화)에 유의해야 합니다.


## 결론

이번 챕터에서는 네트워크로 연결된 다른 리눅스 시스템과 안전하게 소통하는 방법을 배웠습니다. 원격 명령줄 접속의 표준인 **SSH**의 클라이언트 사용법, 서버 설정 기초, 그리고 비밀번호보다 훨씬 안전하고 편리한 **키 기반 인증** 설정 방법을 익혔습니다. 또한 SSH 서버 보안을 강화하기 위한 중요한 팁들도 살펴보았습니다.

파일 전송에 있어서는, 간단한 복사를 위한 **`scp`**, 대화형 인터페이스를 제공하는 **`sftp`**, 그리고 효율적인 동기화 및 백업에 최적인 **`rsync`** 의 사용법과 특징을 배웠습니다. 이들은 모두 SSH 기반으로 작동하여 안전한 파일 전송을 보장합니다. 마지막으로 보안에 취약한 `telnet` 과 그래픽 원격 제어 방식인 `VNC` 에 대해서도 간략히 알아보았습니다.

원격 시스템 관리는 현대 IT 환경에서 필수적인 기술이며, 이때 **보안은 가장 최우선적으로 고려**되어야 합니다. 항상 SSH와 같은 안전한 프로토콜과 도구를 사용하고, 특히 키 기반 인증과 같은 보안 강화 기법을 적극적으로 활용하는 습관을 들이는 것이 중요합니다.

다음 Chapter 17에서는 리눅스를 활용하여 실제로 네트워크 서비스를 구축하고 운영하는 방법, 예를 들어 웹 서버(Apache, Nginx), 데이터베이스 서버(MySQL/MariaDB, PostgreSQL), 파일 공유 서버(Samba, NFS) 등을 다루게 됩니다.
