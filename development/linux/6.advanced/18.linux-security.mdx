---
title: "18. 리눅스 보안"
---

지금까지 우리는 리눅스 시스템의 기본적인 사용법부터 시작하여 시스템 관리, 네트워크 설정, 그리고 주요 서비스 구축까지 폭넓은 여정을 함께했습니다. 서비스를 구축하고 운영하는 것도 중요하지만, 그 서비스와 기반 시스템을 **안전하게 보호**하는 것은 그 무엇보다 중요합니다. 아무리 기능이 뛰어난 시스템이라도 보안이 취약하다면 데이터 유출, 서비스 중단, 시스템 완전 장악 등 심각한 문제에 직면할 수 있습니다.

이제부터 시작되는 **Part 6: 고급 시스템 관리 및 최신 기술 동향** 에서는 리눅스 시스템을 좀 더 깊이 있게 다루는 주제들을 살펴볼 것이며, 그 첫 번째 주제는 바로 **리눅스 보안**입니다.

정보 보안의 기본적인 목표는 크게 세 가지로 요약됩니다(CIA Triad).

* **기밀성 (Confidentiality):** 허가된 사용자만 정보에 접근할 수 있도록 보장하는 것.
* **무결성 (Integrity):** 정보가 위변조되지 않고 정확성과 완전성을 유지하도록 보장하는 것.
* **가용성 (Availability):** 허가된 사용자가 필요할 때 정보와 서비스에 접근할 수 있도록 보장하는 것.

리눅스 시스템의 보안은 여러 계층에서 이루어집니다. 물리적인 서버 접근 통제부터 시작해서, 커널 자체의 보안 기능, 우리가 이전에 배운 사용자 계정 및 권한 관리(Chapter 6, 7), 네트워크 레벨의 접근 제어(Chapter 15), 그리고 애플리케이션 자체의 보안 설정까지 모두 중요합니다.

이번 Chapter 18에서는 리눅스 시스템의 보안을 강화(Hardening)하기 위한 핵심적인 실천 방법들을 다룹니다. 시스템 활동을 기록하고 분석하는 **로그 관리**, 네트워크 접근을 통제하는 **방화벽 설정 심화**, 잠재적인 위협을 탐지하고 방어하는 **침입 탐지 및 방지 시스템** 개념, 시스템의 약점을 찾아 보완하는 **보안 감사 및 취약점 스캐닝**, 그리고 기본적인 권한 관리 모델을 넘어선 강력한 접근 통제 시스템인 **SELinux와 AppArmor**에 대해 알아보겠습니다.


## 18.2 시스템 로그 분석 및 관리 (System Log Analysis and Management)

**시스템 로그(Log)** 는 리눅스 시스템 운영 중에 발생하는 다양한 이벤트(사용자 로그인, 서비스 시작/종료, 프로그램 오류, 커널 메시지, 보안 관련 활동 등)를 시간 순서대로 기록한 파일입니다. 로그는 다음과 같은 이유로 매우 중요합니다.

* **문제 해결 (Troubleshooting):** 시스템이나 응용 프로그램에 문제가 발생했을 때, 로그를 분석하여 원인을 파악하는 핵심 단서가 됩니다.
* **성능 모니터링 (Monitoring):** 시스템 부하, 서비스 응답 시간 등 성능 관련 지표를 기록하고 분석하는 데 활용될 수 있습니다.
* **보안 감사 (Security Auditing):** 비정상적인 로그인 시도, 권한 변경, 중요한 파일 접근 등 보안 관련 이벤트를 추적하여 침입 시도나 내부자 위협을 탐지할 수 있습니다.
* **사후 분석 (Forensics):** 보안 사고 발생 후, 로그를 분석하여 침입 경로, 피해 범위 등을 파악하는 데 결정적인 증거 자료가 됩니다.

리눅스 로깅 시스템은 크게 전통적인 `syslog` 방식과 최신 `systemd` 환경의 `journald` 방식으로 나눌 수 있습니다.


### 전통적인 `syslog` / `rsyslog`

* `syslog`는 오랫동안 유닉스 계열 시스템에서 표준적으로 사용되어 온 로깅 프로토콜 및 방식입니다. 대부분의 최신 리눅스 배포판에서는 `syslog`의 확장된 버전인 **`rsyslog`** 데몬(`rsyslogd`)이 기본 로거로 사용됩니다.
* **설정:** `/etc/rsyslog.conf` 파일과 `/etc/rsyslog.d/` 디렉토리 안의 설정 파일들을 통해 로그 기록 방식을 제어합니다. 설정 규칙은 보통 `어떤 종류(facility)와 어떤 심각도(priority)의 메시지를 어디(action)에 기록할지` 형식으로 정의됩니다.
* **주요 로그 파일 위치 (`/var/log/` 디렉토리 아래 - 배포판별로 약간 다를 수 있음):**
  * `syslog` 또는 `messages`: 시스템 전반의 일반적인 메시지 (가장 기본적이고 포괄적).
  * **`auth.log` (Debian/Ubuntu) 또는 `secure` (RHEL/CentOS):** **사용자 인증 및 권한 부여 관련 로그** (로그인 성공/실패, `sudo` 사용 기록, SSH 접속 시도 등). **보안상 매우 중요한 로그 파일**입니다.
  * `kern.log`: 커널(OS 핵심) 관련 메시지.
  * `dmesg`: 시스템 부팅 시 출력되는 커널 메시지 (로그 파일 또는 `dmesg` 명령어로 확인 가능).
  * 각종 애플리케이션 로그: 웹 서버(`apache2/`, `nginx/`), 데이터베이스(`mysql/`, `postgresql/`), `cron` 작업 로그 등 해당 애플리케이션별 로그 파일이 별도로 생성됩니다.


### `systemd-journald`

* `systemd`를 사용하는 최신 리눅스 시스템의 **표준 로깅 시스템**입니다. `journald` 데몬은 시스템 부팅 초기부터 커널, 서비스, 애플리케이션 등 시스템의 거의 모든 로그를 **구조화된 바이너리 형식**으로 수집하고 관리합니다. (보통 `/var/log/journal/` 또는 `/run/log/journal/` 아래 저장)
* **`journalctl` 명령어:** `journald`가 수집한 로그를 조회하고 필터링하는 강력한 명령줄 도구입니다.
  * `journalctl`: 모든 로그 보기 (페이지 단위, 오래된 순서)
  * `journalctl -f`: 새로운 로그 실시간으로 보기 (`tail -f` 와 유사)
  * `journalctl -b`: 이번 부팅 이후의 로그 보기 (`-b -1`: 이전 부팅 로그)
  * `journalctl -u <서비스명.service>`: 특정 systemd 유닛(서비스)의 로그만 보기 (예: `journalctl -u sshd`)
  * `journalctl --since "YYYY-MM-DD HH:MM:SS"` 또는 `--until ...`: 특정 시간 범위의 로그 필터링
  * `journalctl -p <우선순위>`: 특정 심각도(priority) 이상의 로그만 필터링 (예: `err`(3), `warning`(4), `notice`(5), `info`(6), `debug`(7) - 숫자가 낮을수록 심각)

        ```bash
        journalctl -p err # 에러(err) 등급 이상(crit, alert, emerg 포함)의 로그 보기
        journalctl -p 3   # 위와 동일
        ```

  * `journalctl _PID=<PID>` 또는 `_UID=<UID>`: 특정 PID 또는 UID 관련 로그 필터링
  * `journalctl -k`: 커널 메시지만 보기 (`dmesg` 와 유사)
* **로그 저장 방식:** `journald`는 설정을 통해 로그를 디스크에 영구적으로 저장하거나(`persistent`, `/var/log/journal`), 메모리에만 임시로 저장하고 재부팅 시 삭제(`volatile`, `/run/log/journal`)하도록 할 수 있습니다. (`/etc/systemd/journald.conf` 파일에서 설정)


### 로그 로테이션 (`logrotate`)

로그 파일은 시간이 지남에 따라 계속 커지므로 디스크 공간을 모두 차지하지 않도록 주기적으로 관리해야 합니다. **`logrotate`** 유틸리티는 오래된 로그 파일을 자동으로 압축, 백업, 삭제하는 역할을 합니다.

* 설정: `/etc/logrotate.conf` (전역 설정) 및 `/etc/logrotate.d/` 디렉토리 안의 개별 서비스 설정 파일들.
* 동작: 보통 `cron`을 통해 매일 실행되며, 설정 파일의 규칙(파일 크기 기준, 기간 기준 등)에 따라 로그 파일을 로테이션(순환)시킵니다. (예: `messages` -> `messages.1` -> `messages.2.gz` -> ... -> 삭제)

**로그 모니터링의 중요성:** 특히 `auth.log`나 `secure` 같은 인증 로그는 주기적으로 확인하여 비정상적인 로그인 시도나 `sudo` 사용 내역이 있는지 살펴보는 것이 중요합니다. 로그와치(Logwatch) 같은 요약 도구나 ELK 스택, Graylog 같은 중앙 집중식 로깅 시스템을 활용하여 로그를 효율적으로 관리하고 분석할 수도 있습니다.


## 18.3 방화벽 설정 및 관리 (Firewall Configuration and Management)

Chapter 15에서 방화벽의 기본 개념과 주요 도구(`firewalld`, `ufw`, `iptables`)를 소개했습니다. 여기서는 보안 관점에서 방화벽 설정의 중요성과 핵심 원칙을 다시 강조합니다. 방화벽은 네트워크를 통해 시스템에 접근하는 첫 번째 방어선입니다.

* **기본 정책 (Default Policy) 설정의 중요성:** 가장 중요한 원칙은 **"기본적으로 모든 것을 차단하고(Default Deny), 필요한 것만 명시적으로 허용한다"** 는 것입니다. 예를 들어 들어오는(INPUT) 연결은 기본적으로 모두 차단하고, 웹 서비스(80, 443 포트)나 SSH(22 포트)처럼 외부에서 접속해야 하는 서비스 포트만 명시적으로 열어주는 방식입니다.
* **`firewalld` 활용 심화 (RHEL/Fedora 계열):**
  * **존(Zone) 관리:** 시스템의 네트워크 환경(예: 외부 인터넷에 직접 연결된 `public` 존, 내부 네트워크에 연결된 `internal` 존)에 따라 다른 보안 규칙 세트를 적용합니다. 인터페이스별로 적절한 존을 할당하고 각 존의 기본 정책을 관리하는 것이 중요합니다. (`firewall-cmd --set-default-zone=`, `firewall-cmd --zone=<zone> --change-interface=`)
  * **서비스/포트 관리:** 미리 정의된 서비스(`http`, `ssh` 등)나 특정 포트 번호/프로토콜을 `--permanent` 옵션과 함께 추가/제거하고 `--reload`로 적용하는 방식을 익숙하게 사용해야 합니다. 불필요한 서비스나 포트는 반드시 제거합니다.
  * **리치 규칙(Rich Rules):** 특정 출발지 IP 주소에서 오는 특정 포트 접속만 허용하는 등 더 세밀한 규칙 정의가 필요할 때 사용합니다.
* **`ufw` 활용 심화 (Ubuntu 계열):**
  * **기본 정책 설정:** `sudo ufw default deny incoming`, `sudo ufw default allow outgoing` 명령으로 기본 정책을 설정합니다.
  * **규칙 관리:** `sudo ufw allow <서비스/포트>`, `sudo ufw deny <서비스/포트>` 로 필요한 규칙을 추가/삭제합니다. 특정 IP 주소나 서브넷에 대한 규칙도 가능합니다 (`sudo ufw allow from 192.168.1.100 to any port 22`).
  * **Rate Limiting:** `sudo ufw limit ssh` 와 같이 특정 서비스에 대한 접속 시도 횟수를 제한하여 무차별 대입 공격(Brute-force attack)을 방어하는 데 도움이 됩니다.
  * **상태 확인 및 규칙 삭제:** `sudo ufw status numbered` 로 규칙 목록과 번호를 확인하고, `sudo ufw delete <번호>` 로 불필요한 규칙을 삭제합니다.
* **`iptables` 직접 관리:** 매우 강력하지만 복잡합니다. 규칙의 순서가 중요하며, 설정 변경 시 기존 연결에 영향을 줄 수 있습니다. `INPUT`, `OUTPUT`, `FORWARD` 체인의 기본 정책(Policy)을 `DROP`으로 설정하고 필요한 트래픽만 `ACCEPT` 규칙으로 명시적으로 허용하는 것이 일반적인 보안 설정 방식입니다. 규칙을 영구적으로 저장하는 방법(`iptables-save`, `iptables-persistent` 등)을 반드시 사용해야 합니다.

**결론:** 어떤 도구를 사용하든, **최소한의 필요한 포트만 열고 기본적으로는 차단하는 정책**을 적용하는 것이 네트워크 보안의 핵심입니다.


## 18.4 침입 탐지 및 방지 (Intrusion Detection and Prevention)

방화벽이 허가되지 않은 접근을 막는 첫 번째 방어선이라면, 침입 탐지 및 방지 시스템은 방화벽을 통과했거나 내부에서 발생하는 **악의적인 활동이나 의심스러운 패턴을 탐지하고 대응**하는 역할을 합니다.

* **침입 탐지 시스템 (IDS - Intrusion Detection System):** 네트워크 트래픽이나 시스템 로그, 파일 변경 등을 감시하여 알려진 공격 패턴(Signature-based)이나 비정상적인 행위(Anomaly-based)를 **탐지**하고 관리자에게 **경고**를 보냅니다. 직접 트래픽을 차단하지는 않습니다.
  * **NIDS (Network IDS):** 네트워크 전체 트래픽을 감시합니다. (예: `Snort`, `Suricata`)
  * **HIDS (Host-based IDS):** 개별 호스트(서버) 내부의 활동(로그 파일, 시스템 콜, 파일 무결성 등)을 감시합니다. (예: `OSSEC`, `Wazuh`, `Tripwire`, `AIDE`)
* **침입 방지 시스템 (IPS - Intrusion Prevention System):** IDS와 유사하게 악의적인 활동을 탐지할 뿐만 아니라, 탐지된 위협에 대해 **자동으로 대응하여 해당 트래픽을 차단**하거나 연결을 끊는 등의 **방지 조치**를 수행합니다. 보통 네트워크 경로 상에 인라인(inline)으로 위치하거나 방화벽과 연동됩니다. (Snort, Suricata 등은 IPS 모드로도 작동 가능)
* **파일 무결성 모니터링 (File Integrity Monitoring):** 중요한 시스템 파일이나 설정 파일의 변경 여부를 감시하는 것은 HIDS의 중요한 기능 중 하나입니다. `Tripwire`, `AIDE`(Advanced Intrusion Detection Environment) 같은 도구는 시스템 파일들의 초기 상태(체크섬, 권한, 타임스탬프 등) 데이터베이스를 만들어 놓고, 주기적으로 현재 상태와 비교하여 허가되지 않은 변경이 발생했는지 탐지합니다.
  * AIDE 사용 예시 (개념): `sudo apt install aide` 또는 `sudo dnf install aide` -> `sudo aideinit` (초기 데이터베이스 생성) -> `sudo aide --check` (현재 상태와 비교하여 변경 사항 보고)

IDS/IPS는 보통 더 큰 규모의 네트워크나 중요한 서버 환경에서 사용되며, 설정 및 운영에 전문성이 요구됩니다. 하지만 파일 무결성 모니터링은 개별 서버에서도 비교적 쉽게 적용해 볼 수 있는 좋은 보안 강화 방법입니다.


## 18.5 보안 감사 및 취약점 스캐닝 (Security Auditing and Vulnerability Scanning)

시스템 보안은 한 번 설정하고 끝나는 것이 아니라 지속적인 관리와 점검이 필요합니다.

* **보안 감사 (Security Auditing):** 시스템 로그, 설정, 사용자 활동 등을 정기적으로 검토하여 보안 정책이 잘 지켜지고 있는지, 비정상적인 활동은 없는지 확인하는 과정입니다.
  * **Linux Audit Framework (`auditd`):** 커널 레벨에서 발생하는 매우 상세한 시스템 활동(파일 접근, 시스템 콜 호출, 로그인, 설정 변경 등)을 기록하고 감사하는 프레임워크입니다. `/etc/audit/auditd.conf` 및 `/etc/audit/rules.d/` 에서 감사 규칙을 설정하며, `ausearch` 와 `aureport` 명령어로 로그를 검색하고 보고서를 생성할 수 있습니다. 강력하지만 설정 및 로그 분석이 복잡할 수 있습니다.

* **취약점 스캐닝 (Vulnerability Scanning):** 자동화된 도구를 사용하여 시스템이나 네트워크에 알려진 보안 취약점(예: 오래된 소프트웨어 버전, 안전하지 않은 설정, 불필요하게 열린 포트 등)이 있는지 **능동적으로 검사**하는 과정입니다.
  * **네트워크 기반 스캐너:** 다른 컴퓨터에서 대상 시스템/네트워크를 스캔합니다.
    * `Nmap`: 포트 스캐닝 및 네트워크 탐색의 표준 도구. 열려 있는 포트와 실행 중인 서비스를 식별합니다. (`nmap -sV <target_ip>`)
    * `Nessus`, `OpenVAS`: 포괄적인 취약점 스캐너. 알려진 CVE(Common Vulnerabilities and Exposures) 데이터베이스와 비교하여 시스템의 약점을 찾아 보고합니다.
  * **호스트 기반 스캐너:** 대상 시스템 로컬에서 직접 실행하여 시스템 설정, 설치된 소프트웨어 버전 등을 검사합니다.
    * `Lynis`: 시스템 보안 강화 상태를 점검하고 개선 제안을 제공하는 감사 도구.
    * `OpenSCAP`: SCAP(Security Content Automation Protocol) 표준을 기반으로 시스템의 보안 규정 준수 여부를 검사하는 도구.

취약점 스캐닝을 통해 발견된 문제점들은 **즉시 패치(업데이트)** 하거나 설정을 수정하여 해결해야 합니다. 정기적인 스캐닝과 신속한 조치는 시스템을 안전하게 유지하는 데 매우 중요합니다.


## 18.6 SELinux/AppArmor 설정 (SELinux/AppArmor Configuration)

리눅스의 표준 파일 권한(소유자/그룹/기타, rwx - DAC: Discretionary Access Control)은 사용자가 자신의 파일 권한을 임의로 변경할 수 있다는 점에서 한계가 있습니다. **강제적 접근 통제(MAC - Mandatory Access Control)** 시스템은 이 DAC 위에 추가적인 보안 계층을 제공하여, 시스템 관리자가 **중앙에서 정의한 보안 정책**에 따라 프로세스가 특정 자원(파일, 포트, 다른 프로세스 등)에 접근하는 것을 강제로 제어합니다. 즉, 어떤 프로세스(예: 웹 서버)가 해킹당하더라도, 미리 정의된 MAC 정책에 의해 허용되지 않은 행동(예: 임의의 파일 읽기, 다른 시스템 서비스 접근)을 하지 못하도록 제한하여 피해 확산을 막는 강력한 보안 메커니즘입니다.

리눅스에서는 주로 SELinux와 AppArmor 두 가지 MAC 시스템이 사용됩니다.

* **SELinux (Security-Enhanced Linux):**
  * 미국 NSA에서 개발하여 리눅스 커널에 통합되었습니다. RHEL/CentOS/Fedora 계열의 기본 MAC 시스템입니다.
  * **매우 강력하고 세밀한 제어**가 가능하지만, 그만큼 **설정과 문제 해결이 복잡**하기로 유명합니다.
  * 핵심 개념: 모든 파일과 프로세스는 **보안 컨텍스트(Security Context)** 라는 레이블을 가지며, 시스템 **정책(Policy)** 은 어떤 컨텍스트를 가진 프로세스가 어떤 컨텍스트를 가진 자원에 접근할 수 있는지 규칙을 정의합니다.
  * **동작 모드:**
    * `Enforcing`: 정책 규칙을 강제로 적용하며, 위반 시 접근을 차단하고 로그를 남깁니다. (기본)
    * `Permissive`: 정책 규칙을 위반해도 차단하지는 않고, 로그만 남깁니다. (문제 해결 시 사용)
    * `Disabled`: SELinux를 완전히 끕니다. (권장하지 않음)
  * **주요 명령어:**
    * `getenforce`: 현재 모드 확인
    * `setenforce 0`: Permissive 모드로 변경 (임시)
    * `setenforce 1`: Enforcing 모드로 변경 (임시)
    * `sestatus`: SELinux 상태 상세 정보 보기
    * 컨텍스트 확인/변경: `ls -Z`, `ps auxZ`, `chcon`
    * 오류 로그 확인: `/var/log/audit/audit.log` 또는 `ausearch -m avc`
    * 정책 관리 도구: `semanage` (규칙 관리), `setsebool` (Boolean 정책 값 변경)
  * SELinux를 제대로 활용하려면 별도의 학습이 필요하지만, 최소한 현재 상태를 확인하고(`sestatus`, `getenforce`) 문제 발생 시 임시로 Permissive 모드(`sudo setenforce 0`)로 전환하여 SELinux 관련 문제인지 확인하는 방법은 알아두는 것이 좋습니다.

* **AppArmor (Application Armor):**
  * SUSE에서 개발했으며, Ubuntu 및 SUSE 계열 배포판에서 기본적으로 사용됩니다. SELinux보다 **비교적 설정이 간단**하다고 알려져 있습니다.
  * **프로필(Profile)** 기반으로 작동합니다. 각 응용 프로그램(실행 파일 경로 기준)별로 접근 가능한 파일, 네트워크 권한 등을 정의한 프로필 파일을 사용합니다 (`/etc/apparmor.d/` 디렉토리).
  * **동작 모드:**
    * `Enforce`: 프로필 규칙을 강제로 적용하고 위반 시 차단 및 로깅.
    * `Complain`: 규칙을 위반해도 차단하지 않고 로그만 기록. (프로필 작성/디버깅 시 사용)
  * **주요 명령어:**
    * `aa-status` (또는 `apparmor_status`): AppArmor 상태 및 로드된 프로필 목록 확인
    * `aa-complain /경로/프로그램`: 특정 프로필을 Complain 모드로 변경
    * `aa-enforce /경로/프로그램`: 특정 프로필을 Enforce 모드로 변경
    * 프로필 생성/학습 도구: `aa-genprof`, `aa-logprof`

SELinux나 AppArmor 같은 MAC 시스템은 시스템 보안을 한 단계 끌어올릴 수 있는 강력한 도구이지만, 그만큼 시스템 동작에 영향을 미치므로 적용 및 관리에 신중함이 필요합니다.


## 결론

이번 챕터에서는 리눅스 시스템의 보안을 강화하기 위한 다양한 핵심 요소들을 살펴보았습니다. 시스템 활동의 중요한 기록인 **로그 관리**(`rsyslog`, `journalctl`, `logrotate`)의 중요성과 방법을 강조했고, 네트워크 방어의 최전선인 **방화벽 설정 및 관리**(`firewalld`, `ufw`, `iptables`)의 기본 원칙과 도구 활용법을 복습하고 심화했습니다.

또한, 잠재적 위협을 탐지하고 대응하기 위한 **침입 탐지/방지 시스템(IDS/IPS)** 의 개념과 **파일 무결성 검사(`aide`)**, 시스템의 약점을 사전에 찾아내는 **보안 감사(`auditd`)** 및 **취약점 스캐닝(`nmap`, `OpenVAS`, `Lynis`)** 의 필요성을 알아보았습니다. 마지막으로, 리눅스의 기본 권한 모델을 넘어선 강력한 **강제적 접근 통제 시스템인 SELinux와 AppArmor**의 개념과 기본적인 관리 방법을 소개했습니다.

리눅스 보안은 단 한 번의 설정으로 끝나는 것이 아니라, 지속적인 **업데이트 적용, 로그 모니터링, 설정 검토, 새로운 위협에 대한 학습 및 대비**가 필요한 **진행형 프로세스**입니다. 이 챕터에서 다룬 내용들을 바탕으로 항상 보안을 염두에 두고 리눅스 시스템을 관리하는 습관을 들이는 것이 중요합니다.

다음 Chapter 19에서는 시스템의 자원 사용량을 측정하고 병목 현상을 분석하여 성능을 최적화하는 **시스템 모니터링 및 최적화** 기법에 대해 알아보겠습니다.
