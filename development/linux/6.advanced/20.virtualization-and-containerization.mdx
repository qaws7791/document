---
title: "20. 가상화와 컨테이너 기술"
---

이전 Chapter 19에서는 시스템의 성능을 모니터링하고 최적화하는 방법에 대해 알아보았습니다. 시스템 하나하나의 성능과 안정성을 관리하는 것도 중요하지만, 현대 IT 인프라에서는 물리적인 하드웨어 자원을 더욱 효율적으로 활용하고, 애플리케이션 배포 및 관리를 유연하게 하는 기술들이 핵심적인 역할을 합니다. 바로 **가상화(Virtualization)** 와 **컨테이너화(Containerization)** 기술입니다.

이 두 기술은 하나의 물리적 서버에서 여러 개의 운영체제 환경이나 격리된 애플리케이션 실행 환경을 만들 수 있게 해주어, 자원 활용률을 높이고, 개발, 테스트, 배포 과정을 혁신적으로 변화시켰습니다. 특히 클라우드 컴퓨팅, DevOps, 마이크로서비스 아키텍처의 기반 기술로서 그 중요성은 날로 커지고 있습니다.

이번 Chapter 20에서는 가상화와 컨테이너의 기본 개념과 차이점을 이해하고, 리눅스 환경의 대표적인 가상화 기술인 **KVM**과 컨테이너 기술의 표준으로 자리 잡은 **Docker**의 기초적인 사용법을 알아봅니다. 또한, 대규모 컨테이너 환경을 관리하기 위한 **Kubernetes**의 기본 개념까지 간략하게 소개합니다.


## 20.1 가상화 기술 개요 (Virtualization Overview)

**가상화(Virtualization)** 란 물리적인 컴퓨팅 자원(하드웨어, 운영체제, 저장 장치, 네트워크 등)의 실제 형태에 구애받지 않고 이를 논리적인 자원으로 사용할 수 있게 해주는 기술입니다. 여기서는 주로 **하드웨어 가상화** 또는 **운영체제 가상화**에 초점을 맞춥니다.

* **개념:** 하나의 물리적 컴퓨터 하드웨어 위에서 여러 개의 독립적인 **가상 머신(Virtual Machine, VM)** 을 동시에 실행하는 기술입니다. 각 VM은 마치 별도의 물리적 컴퓨터처럼 자신만의 가상 CPU, 메모리, 디스크, 네트워크 인터페이스를 가지며, 독립적인 운영체제(Guest OS)를 설치하고 실행할 수 있습니다.
* **핵심 요소: 하이퍼바이저 (Hypervisor)** 또는 가상 머신 모니터(VMM)라고 불리는 소프트웨어 계층이 물리적 하드웨어를 추상화하고 각 VM에게 가상 하드웨어를 할당하며 VM들의 실행을 관리합니다.
  * **타입 1 (Type 1, 네이티브 또는 베어메탈):** 하이퍼바이저가 하드웨어 위에서 직접 실행됩니다. 운영체제를 거치지 않아 효율성이 높으며, 주로 서버 환경에서 사용됩니다. 예: **KVM (Linux)**, VMware ESXi, Microsoft Hyper-V, Xen.
  * **타입 2 (Type 2, 호스트 기반):** 일반적인 운영체제(Host OS) 위에 응용 프로그램처럼 설치되어 실행됩니다. 설정이 간편하여 주로 데스크탑 환경에서 테스트나 개발 용도로 사용됩니다. 예: VirtualBox (Chapter 2에서 사용), VMware Workstation/Player/Fusion.
* **가상 머신 (VM):** 하이퍼바이저 위에 생성된 가상의 컴퓨터 인스턴스입니다. 완전한 운영체제를 포함하므로 상대적으로 무겁지만, 호스트 시스템 및 다른 VM들과 완전히 격리된 환경을 제공합니다.
* **가상화의 장점:**
  * **서버 통합:** 여러 대의 물리적 서버에서 실행되던 서비스들을 더 적은 수의 물리적 서버 위에 VM으로 통합하여 하드웨어 비용, 전력 소모, 상면 공간을 절약할 수 있습니다.
  * **자원 활용률 향상:** 물리적 서버의 자원을 여러 VM이 나누어 사용함으로써 전반적인 자원 활용률을 높입니다.
  * **유연한 개발 및 테스트 환경:** 다양한 운영체제 환경의 VM을 쉽게 생성하고 테스트 후 폐기할 수 있습니다.
  * **신속한 배포 및 마이그레이션:** VM 이미지를 복제하여 새로운 서버를 빠르게 배포하거나, 실행 중인 VM을 다른 물리적 서버로 이전하기 용이합니다.
* **가상화의 단점:**
  * **성능 오버헤드:** 하이퍼바이저 계층으로 인해 약간의 성능 손실이 발생할 수 있습니다.
  * **자원 소모:** 각 VM은 독립적인 운영체제를 실행하므로 상당한 양의 디스크 공간, 메모리, CPU 자원을 필요로 합니다.
  * **부팅 시간:** VM마다 운영체제를 부팅해야 하므로 컨테이너에 비해 시작 시간이 오래 걸립니다.


## 20.2 KVM 가상화 (KVM Virtualization)

**KVM(Kernel-based Virtual Machine)** 은 **리눅스 커널 자체에 내장된 타입 1 하이퍼바이저** 기능입니다. 즉, 리눅스 커널이 직접 하이퍼바이저 역할을 수행합니다. KVM은 현대 CPU가 제공하는 하드웨어 가상화 지원 기능(Intel VT-x, AMD-V)을 활용하여 높은 성능을 제공합니다.

* **작동 방식:** KVM 커널 모듈(`kvm.ko`, `kvm-intel.ko` 또는 `kvm-amd.ko`)이 CPU와 메모리 가상화를 담당하고, 사용자 공간에서는 **QEMU(Quick EMUlator)** 같은 프로그램이 디스크 컨트롤러, 네트워크 카드, 그래픽 카드 등 나머지 하드웨어를 에뮬레이션하여 완전한 가상 머신 환경을 제공합니다. 이러한 KVM 기반 가상 환경은 **libvirt** 라는 라이브러리 및 데몬을 통해 관리되는 경우가 많으며, `virsh`(명령줄 인터페이스)나 `virt-manager`(그래픽 인터페이스) 같은 도구로 VM을 생성, 실행, 관리할 수 있습니다.
* **KVM의 장점:**
  * **리눅스 커널 통합:** 별도의 하이퍼바이저 설치 없이 리눅스 커널 기능으로 제공됩니다.
  * **오픈 소스:** 라이선스 비용 없이 자유롭게 사용 가능합니다.
  * **고성능:** 하드웨어 가상화 지원을 활용하여 거의 네이티브에 가까운 성능을 낼 수 있습니다.
  * **성숙도 및 안정성:** 오랫동안 개발되고 검증되어 안정성이 높습니다.
  * **풍부한 생태계:** 다양한 게스트 운영체제(리눅스, 윈도우 등)를 지원하며, OpenStack 같은 클라우드 플랫폼과의 통합도 잘 이루어져 있습니다.

* **기본 관리 (개념 위주 - `virsh`/`virt-manager` 사용):**
  * KVM 지원 확인: CPU가 가상화 기술을 지원하는지 확인 (`egrep -c '(vmx|svm)' /proc/cpuinfo` 결과가 0보다 커야 함)하고, KVM 관련 커널 모듈이 로드되었는지 확인 (`lsmod | grep kvm`).
  * 관련 패키지 설치: (배포판별로 패키지 이름 상이) `qemu-kvm`, `libvirt-daemon-system`, `libvirt-clients`, `bridge-utils`, `virt-manager` 등 설치.
  * `libvirtd` 데몬 시작 및 활성화: `sudo systemctl start libvirtd`, `sudo systemctl enable libvirtd`. (현재 사용자를 `libvirt` 그룹에 추가해야 할 수도 있음: `sudo usermod -aG libvirt $(whoami)`)
  * VM 생성: `virt-manager`(GUI) 또는 `virt-install`(명령줄) 도구를 사용하여 VM의 이름, CPU 코어 수, 메모리 크기, 가상 디스크 이미지 경로/크기, 설치 미디어(ISO 파일 경로), 네트워크 설정(예: 브릿지 네트워크) 등을 지정하여 VM을 생성하고 OS를 설치합니다.
  * VM 관리 (`virsh` 명령줄):
    * `virsh list --all`: 모든 VM 목록 보기 (실행 중/중지됨)
    * `virsh start <VM이름>`: VM 시작
    * `virsh shutdown <VM이름>`: VM 정상 종료 시도
    * `virsh destroy <VM이름>`: VM 강제 종료 (전원 끄기와 유사)
    * `virsh console <VM이름>`: VM의 텍스트 콘솔에 연결

(KVM 및 libvirt의 상세한 사용법은 이 챕터의 범위를 벗어나므로 개념 위주로 이해합니다.)


## 20.3 컨테이너 가상화 (Containerization)

**컨테이너화(Containerization)** 는 가상 머신(VM)보다 훨씬 가벼운 형태의 가상화 기술입니다. 하드웨어를 가상화하는 대신, **호스트 운영체제의 커널을 공유**하면서 **애플리케이션 실행에 필요한 환경(프로세스, 파일 시스템, 네트워크 등)을 격리**시키는 방식입니다. 컨테이너는 애플리케이션과 그 의존성(라이브러리, 바이너리 등)을 함께 패키징합니다.

* **가상 머신(VM)과의 차이점:**
  * **VM:** 하드웨어 가상화. 각 VM은 자체 커널을 가진 **완전한 Guest OS**를 실행. 무겁고 격리 수준 높음.
  * **컨테이너:** OS 레벨 가상화. 모든 컨테이너가 **호스트 OS의 커널을 공유**. Guest OS 없음. 가볍고 격리 수준은 VM보다 낮음. 시작 속도 매우 빠름.
* **비유:** VM이 각자 독립된 기반과 구조를 가진 단독 주택이라면, 컨테이너는 하나의 큰 건물(호스트 OS 커널) 안에서 벽(격리 기술)으로 나뉜 여러 아파트 방과 같습니다. 기반 시설(커널)은 공유하지만 각 방은 독립적인 공간을 가집니다.
* **컨테이너의 장점:**
  * **경량성 및 빠른 시작 속도:** OS 부팅 과정 없이 애플리케이션 프로세스만 시작하면 되므로 매우 빠릅니다 (수 초 내외).
  * **높은 자원 효율성:** 호스트 OS 커널을 공유하므로 VM보다 훨씬 적은 메모리와 CPU 자원을 사용합니다. 동일한 하드웨어에서 더 많은 컨테이너를 실행할 수 있습니다.
  * **환경 일관성:** 개발, 테스트, 운영 환경 모두에서 동일한 컨테이너 이미지를 사용하여 "내 PC에서는 됐는데 서버에서는 안 돼요" 같은 문제를 줄여줍니다.
  * **쉬운 배포 및 확장:** 애플리케이션과 환경이 패키징되어 있어 배포가 간편하고, 필요에 따라 컨테이너 수를 늘리거나 줄이기(스케일링) 용이합니다 (특히 마이크로서비스 아키텍처에 적합).
* **핵심 기술:** 리눅스 커널의 **네임스페이스(Namespaces)** 와 **컨트롤 그룹(Cgroups)** 기능이 컨테이너 격리 및 자원 제한의 핵심입니다.
  * **Namespaces:** PID(프로세스 ID), Net(네트워크), Mnt(파일 시스템 마운트), User(사용자 ID) 등을 컨테이너별로 격리하여 독립적인 환경처럼 보이게 합니다.
  * **Cgroups:** 특정 컨테이너(프로세스 그룹)가 사용할 수 있는 CPU, 메모리, 디스크 I/O 등의 자원을 제한합니다.
* **Docker:** 현재 가장 널리 사용되는 컨테이너화 플랫폼입니다.


### 20.3.1 Docker 기초 (Docker Basics)

**Docker**는 컨테이너 기술을 누구나 쉽게 사용할 수 있도록 만든 오픈소스 플랫폼입니다. 컨테이너의 생성(빌드), 실행, 배포, 관리를 위한 도구와 환경을 제공합니다.

* **Docker의 주요 구성 요소:**
  * **Docker 엔진 (Docker Engine):** 컨테이너를 만들고 실행하며 관리하는 핵심 백그라운드 서비스(데몬) 및 클라이언트 명령어 인터페이스(`docker` 명령어).
  * **Docker 이미지 (Image):** 컨테이너 실행에 필요한 모든 것(애플리케이션 코드, 런타임, 시스템 도구, 라이브러리 등)을 담고 있는 **읽기 전용 템플릿**입니다. `Dockerfile`이라는 텍스트 파일에 정의된 절차에 따라 빌드됩니다. 이미지는 로컬에 저장되거나 레지스트리에서 가져올 수 있습니다.
  * **Docker 컨테이너 (Container):** Docker 이미지의 **실행 가능한 인스턴스**입니다. 호스트 OS 커널 위에서 격리된 프로세스로 실행되며, 이미지에 포함된 파일 시스템과 네트워크 환경을 가집니다. 기본적으로 컨테이너 내부에 변경된 내용은 컨테이너가 삭제되면 사라집니다 (휘발성). 영구 데이터는 **볼륨(Volume)** 이나 **바인드 마운트(Bind Mount)** 를 사용합니다.
  * **Dockerfile:** Docker 이미지를 만드는 방법을 정의하는 텍스트 파일입니다. 베이스 이미지 지정(`FROM`), 파일 복사(`COPY`), 명령어 실행(`RUN`), 컨테이너 시작 시 실행될 명령어 지정(`CMD`, `ENTRYPOINT`) 등의 지시어를 포함합니다.
  * **Docker 레지스트리 (Registry):** Docker 이미지를 저장하고 공유하는 서비스입니다. **Docker Hub**가 기본 공개 레지스트리이며, 비공개 레지스트리를 직접 구축하거나 클라우드 서비스를 이용할 수도 있습니다.

* **Docker 설치:** (배포판별로 방법이 약간 다름. 공식 Docker 문서 참조 권장)
  * 보통 Docker 공식 저장소를 시스템에 추가한 후 패키지 매니저로 설치합니다. (예: `sudo apt install docker-ce docker-ce-cli containerd.io` 또는 `sudo dnf install docker-ce ...`)
  * 설치 후 현재 사용자를 `docker` 그룹에 추가하면 `sudo` 없이 `docker` 명령어를 사용할 수 있습니다. (`sudo usermod -aG docker $(whoami)`, **로그아웃/로그인 필요**)
  * Docker 서비스 시작 및 활성화: `sudo systemctl start docker`, `sudo systemctl enable docker`

* **기본 `docker` 명령어:**
  * `docker --version`: Docker 버전 확인
  * `docker pull <이미지명>[:태그]`: 레지스트리에서 이미지 다운로드 (예: `docker pull nginx:latest`)
  * `docker images`: 로컬에 다운로드된 이미지 목록 보기
  * `docker run [옵션] <이미지명>[:태그] [실행할 명령어]` : 이미지로부터 새 컨테이너를 생성하고 실행
    * `-d`: Detached 모드 (백그라운드 실행)
    * `-it`: Interactive 모드 + pseudo-TTY 할당 (컨테이너 쉘 접속 등에 사용)
    * `--name <컨테이너명>`: 컨테이너에 이름 부여
    * `-p <호스트포트>:<컨테이너포트>`: 호스트와 컨테이너 간 포트 매핑
    * `-v <호스트경로>:<컨테이너경로>`: 호스트 디렉토리/파일을 컨테이너에 마운트 (데이터 영속성)
    * 예시:

            ```bash
            docker run hello-world                  # 간단한 테스트 이미지 실행
            docker run -it ubuntu /bin/bash         # Ubuntu 컨테이너 실행 후 Bash 쉘 접속
            docker run -d -p 8080:80 --name my-nginx nginx # Nginx 웹 서버 백그라운드 실행 (호스트 8080 -> 컨테이너 80)
            ```

  * `docker ps`: 현재 **실행 중인** 컨테이너 목록 보기
  * `docker ps -a`: 중지된 컨테이너를 포함한 **모든** 컨테이너 목록 보기
  * `docker stop <컨테이너명 또는 ID>`: 실행 중인 컨테이너 중지
  * `docker start <컨테이너명 또는 ID>`: 중지된 컨테이너 시작
  * `docker rm <컨테이너명 또는 ID>`: **중지된** 컨테이너 삭제
  * `docker rmi <이미지명 또는 ID>`: 로컬 이미지 삭제
  * `docker logs <컨테이너명 또는 ID>`: 컨테이너의 로그(표준 출력/에러) 보기 (`-f` 옵션으로 실시간 보기 가능)
  * `docker exec -it <컨테이너명 또는 ID> <명령어>`: **실행 중인 컨테이너 내부에서** 추가 명령어 실행 (예: `docker exec -it my-nginx bash` -> 실행 중인 nginx 컨테이너의 쉘 접속)


### 20.3.2 Docker 이미지 관리 (Managing Docker Images)

* 이미지 목록(`docker images`), 이미지 다운로드(`docker pull`), 이미지 삭제(`docker rmi`)는 위에서 다뤘습니다.
* **이미지 빌드:** `Dockerfile`이 있는 디렉토리에서 `docker build` 명령어를 사용하여 직접 이미지를 만들 수 있습니다.

    ```bash
    # 현재 디렉토리의 Dockerfile을 사용하여 myapp:1.0 이라는 이름과 태그로 이미지 빌드
    docker build -t myapp:1.0 .
    ```


### 20.3.3 Docker 네트워크 설정 (Docker Network Configuration)

* Docker는 컨테이너 간, 그리고 컨테이너와 외부 네트워크 간의 통신을 위해 자체적인 가상 네트워크를 생성하고 관리합니다.
* **기본 `bridge` 네트워크:** 가장 일반적으로 사용됩니다. 컨테이너들은 이 브릿지 네트워크에 연결되어 각자 사설 IP를 할당받고 서로 통신할 수 있습니다. 외부에서 컨테이너의 서비스에 접근하려면 `docker run` 시 `-p` 옵션을 사용하여 호스트의 포트와 컨테이너의 포트를 매핑해야 합니다.
* **기타 네트워크:** `host` (호스트의 네트워크 직접 사용), `overlay` (여러 호스트에 걸친 컨테이너 통신 - Docker Swarm/Kubernetes 사용 시), 사용자 정의 네트워크 등 다양한 네트워크 모드가 있습니다. 초보 단계에서는 기본 `bridge` 네트워크와 포트 매핑(`-p`) 개념을 이해하는 것이 중요합니다.


## 20.4 Kubernetes 기초 (Kubernetes Basics)

애플리케이션을 컨테이너화하여 배포하는 것이 일반화되면서, 수십, 수백, 수천 개의 컨테이너를 여러 대의 서버(호스트)에 걸쳐 효율적으로 관리해야 할 필요성이 커졌습니다. Docker만으로는 이러한 대규모 환경의 컨테이너 배포, 확장(스케일링), 네트워킹, 자동 복구 등을 관리하기 어렵습니다.

**쿠버네티스(Kubernetes, 줄여서 K8s)** 는 이러한 문제점을 해결하기 위해 등장한 **컨테이너 오케스트레이션(Container Orchestration)** 플랫폼입니다. 컨테이너화된 애플리케이션의 **배포, 확장, 관리**를 자동화하는 오픈소스 시스템으로, 현재 사실상의 표준으로 자리 잡았습니다. (구글에서 시작되어 CNCF(Cloud Native Computing Foundation)에서 관리)

* **쿠버네티스의 역할:** 여러 대의 서버(노드)를 하나의 클러스터로 묶어, 컨테이너들을 이 클러스터 위에 효율적으로 배치하고, 서비스의 상태를 모니터링하며, 문제가 발생하면 자동으로 복구하고, 필요에 따라 컨테이너 수를 늘리거나 줄이는 등의 작업을 자동화합니다.

* **주요 개념 (매우 간략한 소개):**
  * **클러스터 (Cluster):** 쿠버네티스가 관리하는 노드(서버)들의 집합. 제어 기능을 담당하는 컨트롤 플레인(Control Plane, 마스터 노드)과 실제 컨테이너가 실행되는 워커 노드(Worker Node)들로 구성됩니다.
  * **노드 (Node):** 클러스터에 속한 개별 워커 머신 (물리 서버 또는 VM).
  * **파드 (Pod):** 쿠버네티스에서 생성하고 관리하는 **가장 작은 배포 단위**. 하나 이상의 컨테이너 그룹으로 구성되며, 같은 파드 내의 컨테이너들은 네트워크와 스토리지 자원을 공유합니다. 파드는 비영구적이어서 언제든 죽고 새로 생성될 수 있습니다.
  * **서비스 (Service):** 여러 개의 파드(동일한 기능을 하는)에 대한 **안정적인 접근점(고정 IP 주소 및 DNS 이름)** 을 제공하고, 로드 밸런싱 기능을 수행합니다. 파드가 죽고 새로 생성되어 IP가 바뀌더라도 서비스 이름/IP는 유지됩니다.
  * **디플로이먼트 (Deployment):** 동일한 파드의 복제본(Replica) 개수를 정의하고 관리하며, 애플리케이션의 **무중단 업데이트(Rolling Update)** 나 롤백 기능을 제공합니다.
  * **네임스페이스 (Namespace):** 하나의 클러스터를 여러 사용자나 팀이 논리적으로 나누어 사용할 수 있도록 하는 **격리된 가상 공간**입니다.
  * **`kubectl`:** 쿠버네티스 클러스터와 상호작용하기 위한 **명령줄 도구**입니다.

쿠버네티스는 매우 강력하지만 그만큼 배우고 운영하기 복잡한 시스템입니다. 보통 대규모 서비스 환경에서 사용되며, AWS EKS, GCP GKE, Azure AKS 등 클라우드 제공 업체들이 관리형 쿠버네티스 서비스를 제공하여 운영 부담을 덜어줍니다. 로컬 개발/테스트용으로는 Minikube, k3s, Kind 같은 도구들이 있습니다. 이 챕터에서는 개념 소개 정도로 마무리하며, 쿠버네티스는 별도의 전문적인 학습이 필요합니다.


## 결론

이번 챕터에서는 물리적인 하드웨어 자원을 효율적으로 활용하고 애플리케이션 환경을 격리하는 두 가지 핵심 기술, **가상화(Virtualization)** 와 **컨테이너화(Containerization)** 에 대해 알아보았습니다.

**가상 머신(VM)** 은 하드웨어를 가상화하여 완전한 독립 OS 환경을 제공하며 (예: **KVM**), 높은 격리 수준을 보장하지만 상대적으로 무겁습니다. 반면 **컨테이너(Container)** 는 호스트 OS 커널을 공유하며 프로세스를 격리하여 매우 가볍고 빠르게 애플리케이션 환경을 제공합니다 (예: **Docker**). 이 둘의 차이점과 장단점을 이해하는 것이 중요합니다.

특히 현대적인 애플리케이션 개발 및 배포의 표준으로 자리 잡은 **Docker**의 기본 개념(이미지, 컨테이너, Dockerfile, 레지스트리)과 핵심 명령어(`pull`, `images`, `run`, `ps`, `stop`, `rm`, `exec` 등) 사용법을 익혔습니다. 더 나아가 대규모 컨테이너 환경을 관리하기 위한 오케스트레이션 도구인 **Kubernetes**의 필요성과 기본 개념까지 간략하게 소개했습니다.

가상화와 컨테이너 기술은 클라우드 컴퓨팅, DevOps, 마이크로서비스 등 현대 IT 인프라의 근간을 이루는 매우 중요한 기술입니다. 특히 Docker는 개발자 및 시스템 관리자 모두에게 매우 유용한 도구이므로, 이 챕터에서 배운 내용을 바탕으로 직접 컨테이너를 실행해보며 더 깊이 탐구해보시기를 권장합니다.

다음 Chapter 21에서는 시스템 구성 및 배포 작업을 자동화하여 효율성과 일관성을 높이는 **자동화 및 구성 관리(Automation and Configuration Management)** 도구, 특히 **Ansible**에 대해 알아보겠습니다.
