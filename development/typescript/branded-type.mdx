# TypeScriptì—ì„œì˜ Branded Type


## ì™œ Branded Typeì´ í•„ìš”í•œê°€?

TypeScriptë¥¼ ì‚¬ìš©í•˜ë©´ì„œ ì´ëŸ° ê²½í—˜ì´ ìˆìœ¼ì…¨ë‚˜ìš”? ì‚¬ìš©ì IDì™€ ìƒí’ˆ IDê°€ ëª¨ë‘ `string` íƒ€ì…ì´ë¼ì„œ, ì‹¤ìˆ˜ë¡œ ì„œë¡œ ë°”ê¿”ì„œ ì „ë‹¬í•´ë„ ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ” ìƒí™© ë§ì…ë‹ˆë‹¤.

- êµ¬ì¡°ì  íƒ€ì´í•‘ì˜ ë‹¨ì : êµ¬ì¡°ê°€ ë™ì¼í•˜ë©´ ì„œë¡œ í˜¸í™˜ë˜ëŠ” íŠ¹ì„±ìœ¼ë¡œ ì¸í•´ ì˜ë¯¸ì ìœ¼ë¡œëŠ” ì „í˜€ ë‹¤ë¥¸ ê°’ë“¤ì´ ì‹¤ìˆ˜ë¡œ êµì²´ë˜ëŠ” ìƒí™©ì´ ë§Œë“¤ì–´ì§ˆ ìˆ˜ ìˆë‹¤.

```typescript
function getUser(userId: string) { /* ... */ }
function getProduct(productId: string) { /* ... */ }

const userId = "user_123";
const productId = "product_456";

// ì‹¤ìˆ˜ë¡œ ë°”ê¿”ì„œ ì „ë‹¬í•´ë„ TypeScriptëŠ” ì—ëŸ¬ë¥¼ ì¡ì§€ ëª»í•¨
getUser(productId); // ğŸ˜± ëŸ°íƒ€ì„ì—ì„œì•¼ ë¬¸ì œë¥¼ ë°œê²¬
getProduct(userId); // ğŸ˜± íƒ€ì… ì•ˆì „ì„±ì´ ë³´ì¥ë˜ì§€ ì•ŠìŒ
```

ì´ëŸ° ë¬¸ì œëŠ” íŠ¹íˆ ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ì—ì„œ ìì£¼ ë°œìƒí•©ë‹ˆë‹¤. ê°™ì€ ê¸°ë³¸ íƒ€ì…(`string`, `number`)ì„ ê°€ì§€ì§€ë§Œ ì˜ë¯¸ì ìœ¼ë¡œ ì™„ì „íˆ ë‹¤ë¥¸ ê°’ë“¤ì´ ì„œë¡œ í˜¸í™˜ë˜ì–´ë²„ë¦¬ì£ . ì´ë•Œ **Branded Type** ì´ í•´ê²°ì±…ì´ ë©ë‹ˆë‹¤.

Branded Typeì€ ë™ì¼í•œ ê¸°ë³¸ íƒ€ì…ì´ì§€ë§Œ **ì˜ë¯¸ì ìœ¼ë¡œ êµ¬ë¶„ë˜ëŠ” íƒ€ì…ì„ ë§Œë“¤ì–´ì£¼ëŠ” TypeScriptì˜ ê³ ê¸‰ íŒ¨í„´** ì…ë‹ˆë‹¤. ë§ˆì¹˜ ë¬¼ë¦¬í•™ì—ì„œ "ê¸¸ì´"ì™€ "ì‹œê°„"ì´ ëª¨ë‘ ìˆ«ìì§€ë§Œ ì™„ì „íˆ ë‹¤ë¥¸ ê°œë…ì¸ ê²ƒì²˜ëŸ¼, ì½”ë“œì—ì„œë„ ê°™ì€ ì›ë¦¬ë¥¼ ì ìš©í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.

---


## Branded Typeì˜ í•µì‹¬ ê°œë…


### ê¸°ë³¸ ì •ì˜

Branded Type(ë¸Œëœë“œ íƒ€ì…)ì€ ê¸°ì¡´ íƒ€ì…ì— **ê³ ìœ í•œ "ë¸Œëœë“œ" ë§ˆí¬ë¥¼ ë¶™ì—¬ì„œ íƒ€ì… ë ˆë²¨ì—ì„œ êµ¬ë¶„ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” ê¸°ë²•** ì…ë‹ˆë‹¤. TypeScriptì˜ êµ¬ì¡°ì  íƒ€ì´í•‘(Structural Typing) ì‹œìŠ¤í…œì„ í™œìš©í•´, ëŸ°íƒ€ì„ì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©´ì„œë„ ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ì•ˆì „ì„±ì„ í™•ë³´í•©ë‹ˆë‹¤.


### ê¸°ìˆ ì  ë°°ê²½

ì´ íŒ¨í„´ì€ **Nominal Typing** ì˜ ê°œë…ì„ TypeScriptì˜ **Structural Typing** í™˜ê²½ì— ë„ì…í•œ ê²ƒì…ë‹ˆë‹¤.

- **êµ¬ì¡°ì  íƒ€ì´í•‘(Structural Typing)** : íƒ€ì…ì˜ êµ¬ì¡°ê°€ ê°™ìœ¼ë©´ í˜¸í™˜ ê°€ëŠ¥ (TypeScript ê¸°ë³¸ ë°©ì‹)
- **ëª…ì‹œì  íƒ€ì´í•‘(Nominal Typing)** : íƒ€ì…ì˜ ì´ë¦„ì´ ê°™ì•„ì•¼ë§Œ í˜¸í™˜ ê°€ëŠ¥ (Java, C# ë°©ì‹)

Branded Typeì€ êµ¬ì¡°ì ìœ¼ë¡œëŠ” ê°™ì§€ë§Œ **ë…¼ë¦¬ì ìœ¼ë¡œëŠ” ë‹¤ë¥¸ íƒ€ì…** ì„ ë§Œë“¤ì–´, ë‘ ë°©ì‹ì˜ ì¥ì ì„ ê²°í•©í•©ë‹ˆë‹¤.

---


## ê¸°ë³¸ êµ¬í˜„ê³¼ í™œìš©

### ê°€ì¥ ê¸°ë³¸ì ì¸ Branded Type ë§Œë“¤ê¸°

ë¸Œëœë“œ íƒ€ì…ì€ êµì°¨ íƒ€ì…(intersection types)ì„ í™œìš©í•´ êµ¬ì¡°ì ìœ¼ë¡œ ë™ì¼í•œ íƒ€ì…ì— ê³ ìœ í•œ "ë¸Œëœë“œ" ì†ì„±ì„ ì¶”ê°€í•˜ì—¬ íƒ€ì… ë ˆë²¨ì—ì„œ êµ¬ë¶„ ê°€ëŠ¥í•˜ê²Œ ë§Œë“ ë‹¤.

```typescript
// Brand ìœ í‹¸ë¦¬í‹° íƒ€ì… ì •ì˜
type Brand<T, TBrand extends string> = T & { readonly __brand: TBrand };

// êµ¬ì²´ì ì¸ Branded Typeë“¤ ì •ì˜
type UserId = Brand<string, 'UserId'>;
type ProductId = Brand<string, 'ProductId'>;
type Email = Brand<string, 'Email'>;

// ìƒì„± í•¨ìˆ˜ë“¤
function createUserId(id: string): UserId {
  return id as UserId;
}

function createProductId(id: string): ProductId {
  return id as ProductId;
}

function createEmail(email: string): Email {
  // ê°„ë‹¨í•œ ê²€ì¦ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
  if (!email.includes('@')) {
    throw new Error('Invalid email format');
  }
  return email as Email;
}
```

### TypeScript ì»´íŒŒì¼ëŸ¬ì˜ ë¸Œëœë“œ íƒ€ì… ì²˜ë¦¬

TypeScript ì»´íŒŒì¼ëŸ¬ëŠ” **íƒ€ì… ì‚­ì œ(type erasure)** ê³¼ì •ì—ì„œ ëª¨ë“  ë¸Œëœë“œ ì •ë³´ë¥¼ ì œê±°í•œë‹¤. ì´ëŠ” ë¸Œëœë“œ íƒ€ì…ì´ ëŸ°íƒ€ì„ì— ì „í˜€ ì˜í–¥ì„ ì£¼ì§€ ì•Šìœ¼ë©´ì„œë„ ì»´íŒŒì¼ íƒ€ì„ì— ê°•ë ¥í•œ íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.

```typescript
type UserId = Branded<string, "UserId">;
const userId: UserId = "user_123" as UserId;

// ì»´íŒŒì¼ í›„ì—ëŠ” ë‹¨ìˆœí•œ ë¬¸ìì—´ë¡œ ë³€í™˜ë¨
console.log(typeof userId); // "string"
console.log(userId.__brand); // undefined - ëŸ°íƒ€ì„ì—ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŒ
```

### ì‹¤ì œ ì‚¬ìš© ì˜ˆì œ

```typescript
// í•¨ìˆ˜ ì •ì˜
function getUser(userId: UserId) {
  console.log(`ì‚¬ìš©ì ì¡°íšŒ: ${userId}`);
}

function getProduct(productId: ProductId) {
  console.log(`ìƒí’ˆ ì¡°íšŒ: ${productId}`);
}

function sendEmail(email: Email, message: string) {
  console.log(`ì´ë©”ì¼ ë°œì†¡ to ${email}: ${message}`);
}

// ì˜¬ë°”ë¥¸ ì‚¬ìš©ë²•
const userId = createUserId("user_123");
const productId = createProductId("product_456");
const email = createEmail("user@example.com");

getUser(userId); // âœ… ì •ìƒ ë™ì‘
getProduct(productId); // âœ… ì •ìƒ ë™ì‘
sendEmail(email, "Welcome!"); // âœ… ì •ìƒ ë™ì‘

// ì˜ëª»ëœ ì‚¬ìš©ë²• - ì»´íŒŒì¼ ì—ëŸ¬ ë°œìƒ!
getUser(productId); // âŒ Type 'ProductId' is not assignable to parameter of type 'UserId'
getProduct(userId); // âŒ Type 'UserId' is not assignable to parameter of type 'ProductId'
sendEmail("invalid-email", "Hello"); // âŒ Type 'string' is not assignable to parameter of type 'Email'
```


### ìˆ«ìí˜• Branded Type ì˜ˆì œ

```typescript
type Age = Brand<number, 'Age'>;
type Price = Brand<number, 'Price'>;
type Temperature = Brand<number, 'Temperature'>;

function createAge(age: number): Age {
  if (age < 0 || age > 150) {
    throw new Error('Invalid age range');
  }
  return age as Age;
}

function createPrice(price: number): Price {
  if (price < 0) {
    throw new Error('Price cannot be negative');
  }
  return price as Price;
}

function createTemperature(temp: number): Temperature {
  return temp as Temperature;
}

// ì‚¬ìš© ì˜ˆì œ
function calculateDiscount(age: Age, price: Price): Price {
  if (age >= 65) {
    return createPrice(price * 0.8); // 65ì„¸ ì´ìƒ 20% í• ì¸
  }
  return price;
}

const customerAge = createAge(70);
const itemPrice = createPrice(100);
const discountedPrice = calculateDiscount(customerAge, itemPrice);

// ì˜ëª»ëœ ì‚¬ìš© - ì»´íŒŒì¼ ì—ëŸ¬
// calculateDiscount(itemPrice, customerAge); // âŒ ë§¤ê°œë³€ìˆ˜ ìˆœì„œ ë°”ë€œ
```


### Anti-pattern: ì˜ëª»ëœ ì‚¬ìš© ì˜ˆì œ

```typescript
// âŒ ì˜ëª»ëœ ë°©ë²•: Brand ì—†ì´ ê·¸ëƒ¥ ì‚¬ìš©
function badGetUser(userId: string) { /* ... */ }
function badGetProduct(productId: string) { /* ... */ }

const badUserId = "user_123";
const badProductId = "product_456";

// ì´ë ‡ê²Œ í•˜ë©´ ì‹¤ìˆ˜ë¡œ ë°”ê¿”ë„ ì—ëŸ¬ê°€ ë‚˜ì§€ ì•ŠìŒ
badGetUser(badProductId); // ğŸ˜± ì»´íŒŒì¼ í†µê³¼, ëŸ°íƒ€ì„ ì—ëŸ¬ ê°€ëŠ¥ì„±

// âŒ ì˜ëª»ëœ ë°©ë²•: ì§ì ‘ íƒ€ì… ì–´ì„¤ì…˜ ì‚¬ìš©
const directUserId = "user_123" as UserId; // ê²€ì¦ ë¡œì§ ì—†ì´ ê°•ì œ ë³€í™˜
```

------

## Zodì™€ì˜ í†µí•©

### Zod ë¸Œëœë“œ íƒ€ì…ì˜ ê¸°ë³¸ ì‚¬ìš©ë²•

ZodëŠ” ë‚´ì¥ëœ `.brand<T>()` ë©”ì„œë“œë¥¼ í†µí•´ ë¸Œëœë“œ íƒ€ì…ì„ ìì—°ìŠ¤ëŸ½ê²Œ ì§€ì›í•œë‹¤. ì´ëŠ” ëŸ°íƒ€ì„ ê²€ì¦ê³¼ ì»´íŒŒì¼ íƒ€ì„ ì•ˆì „ì„±ì„ ë™ì‹œì— ì œê³µí•˜ëŠ” ê°•ë ¥í•œ ì¡°í•©ì„ ë§Œë“¤ì–´ë‚¸ë‹¤. 

```typescript
import { z } from "zod";

// ê¸°ë³¸ ë¸Œëœë“œ íƒ€ì… ìŠ¤í‚¤ë§ˆ ì •ì˜
const UserIdSchema = z.string().uuid().brand<"UserId">();
const EmailSchema = z.string().email().brand<"EmailAddress">();
const PositiveNumberSchema = z.number().positive().brand<"PositiveNumber">();

// íƒ€ì… ì¶”ì¶œ
type UserId = z.infer<typeof UserIdSchema>;
type EmailAddress = z.infer<typeof EmailSchema>;
type PositiveNumber = z.infer<typeof PositiveNumberSchema>;

// ì‚¬ìš© ì˜ˆì‹œ
const rawData = {
  userId: "550e8400-e29b-41d4-a716-446655440000",
  email: "user@example.com", 
  score: 95
};

// ì•ˆì „í•œ íŒŒì‹±ê³¼ ë¸Œëœë”©
const userId = UserIdSchema.parse(rawData.userId);
const email = EmailSchema.parse(rawData.email);
const score = PositiveNumberSchema.parse(rawData.score);

// ì´ì œ ë¸Œëœë“œê°€ ì ìš©ëœ íƒ€ì…ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©
processUser(userId, email); // íƒ€ì… ì•ˆì „ì„± ë³´ì¥
```

### ê³ ê¸‰ ê²€ì¦ íŒ¨í„´ê³¼ ë³€í™˜

Zodì˜ `.refine()`ê³¼ `.transform()` ë©”ì„œë“œë¥¼ ë¸Œëœë“œ íƒ€ì…ê³¼ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ ë”ìš± ì •êµí•œ ê²€ì¦ê³¼ ë°ì´í„° ë³€í™˜ì´ ê°€ëŠ¥í•˜ë‹¤. 

```typescript
// ë³µí•© ê²€ì¦ ê·œì¹™ì´ ì ìš©ëœ ë¸Œëœë“œ íƒ€ì…
const StrongPasswordSchema = z.string()
  .min(8, "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
  .refine(val => /[A-Z]/.test(val), "ëŒ€ë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
  .refine(val => /[a-z]/.test(val), "ì†Œë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
  .refine(val => /[0-9]/.test(val), "ìˆ«ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
  .refine(val => /[!@#$%^&*]/.test(val), "íŠ¹ìˆ˜ë¬¸ìê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
  .brand<"StrongPassword">();

// ë°ì´í„° ë³€í™˜ê³¼ ì •ê·œí™”ë¥¼ í¬í•¨í•œ ë¸Œëœë“œ íƒ€ì…
const NormalizedEmailSchema = z.string()
  .email("ìœ íš¨í•œ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”")
  .transform(email => email.toLowerCase().trim())
  .brand<"NormalizedEmail">();

// URL ê²€ì¦ ë° ë³´ì™„
const ValidatedUrlSchema = z.string()
  .transform((val, ctx) => {
    let completeUrl = val;
    
    // http/https í”„ë¡œí† ì½œ ìë™ ì¶”ê°€
    if (!val.startsWith('http')) {
      completeUrl = `https://${val}`;
    }
    
    try {
      new URL(completeUrl);
      return completeUrl;
    } catch {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "ìœ íš¨í•œ URL í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤",
      });
      return z.NEVER;
    }
  })
  .brand<"ValidatedUrl">();

type StrongPassword = z.infer<typeof StrongPasswordSchema>;
type NormalizedEmail = z.infer<typeof NormalizedEmailSchema>;
type ValidatedUrl = z.infer<typeof ValidatedUrlSchema>;
```

### ìŠ¤í‚¤ë§ˆ êµ¬ì„±ê³¼ ì¬ì‚¬ìš©ì„±

ëŒ€ê·œëª¨ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œëŠ” ìŠ¤í‚¤ë§ˆì˜ êµ¬ì„±ê³¼ ì¬ì‚¬ìš©ì´ í•µì‹¬ì´ë‹¤. Zodì˜ ê°•ë ¥í•œ ìŠ¤í‚¤ë§ˆ ì¡°í•© ê¸°ëŠ¥ì„ ë¸Œëœë“œ íƒ€ì…ê³¼ í•¨ê»˜ í™œìš©í•´ë³´ì.

```typescript
// ê¸°ë³¸ ì—”í„°í‹° ìŠ¤í‚¤ë§ˆ ì •ì˜
const BaseEntitySchema = z.object({
  id: z.string().uuid().brand<"EntityId">(),
  createdAt: z.date(),
  updatedAt: z.date(),
  version: z.number().int().nonnegative().brand<"Version">()
});

// ì£¼ì†Œ ì •ë³´ ìŠ¤í‚¤ë§ˆ
const AddressSchema = z.object({
  street: z.string().min(1, "ë„ë¡œëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”"),
  city: z.string().min(1, "ë„ì‹œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”"),
  zipCode: z.string()
    .regex(/^\d{5}$/, "ìš°í¸ë²ˆí˜¸ëŠ” 5ìë¦¬ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤")
    .brand<"ZipCode">(),
  country: z.string().default("KR")
}).brand<"Address">();

// ì‚¬ìš©ì ìŠ¤í‚¤ë§ˆ í™•ì¥
const UserSchema = BaseEntitySchema.extend({
  email: NormalizedEmailSchema,
  name: z.string().min(1, "ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”"),
  age: z.number()
    .int("ë‚˜ì´ëŠ” ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
    .min(0, "ë‚˜ì´ëŠ” 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
    .max(150, "ìœ íš¨í•œ ë‚˜ì´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”")
    .brand<"ValidAge">(),
  address: AddressSchema.optional()
}).brand<"User">();

// ì£¼ë¬¸ ìŠ¤í‚¤ë§ˆ êµ¬ì„±
const OrderItemSchema = z.object({
  productId: z.string().uuid().brand<"ProductId">(),
  quantity: z.number().int().positive().brand<"Quantity">(),
  unitPrice: z.number().positive().brand<"Price">()
}).brand<"OrderItem">();

const OrderSchema = BaseEntitySchema.extend({
  userId: z.string().uuid().brand<"UserId">(),
  items: z.array(OrderItemSchema),
  totalAmount: z.number().positive().brand<"TotalAmount">(),
  status: z.enum(["pending", "confirmed", "shipped", "delivered"])
    .brand<"OrderStatus">()
}).superRefine((order, ctx) => {
  // ë¹„ì¦ˆë‹ˆìŠ¤ ë£°: ì´ì•¡ì´ ì•„ì´í…œ ê°€ê²©ì˜ í•©ê³¼ ì¼ì¹˜í•´ì•¼ í•¨
  const calculatedTotal = order.items.reduce(
    (sum, item) => sum + (item.quantity * item.unitPrice), 
    0
  );
  
  if (Math.abs(calculatedTotal - order.totalAmount) > 0.01) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "ì´ ì£¼ë¬¸ ê¸ˆì•¡ì´ ì•„ì´í…œ ê°€ê²©ì˜ í•©ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
      path: ["totalAmount"]
    });
  }
}).brand<"Order">();

// íƒ€ì… ì¶”ì¶œ
type User = z.infer<typeof UserSchema>;
type Order = z.infer<typeof OrderSchema>;
type OrderItem = z.infer<typeof OrderItemSchema>;
```

### ì‹¤ì „ ë„ë©”ì¸ ëª¨ë¸ë§ ì‚¬ë¡€

ì‹¤ì œ ì „ììƒê±°ë˜ í”Œë«í¼ì—ì„œ ë¸Œëœë“œ íƒ€ì…ì„ ì–´ë–»ê²Œ í™œìš©í•˜ëŠ”ì§€ ì‚´í´ë³´ì. 

```typescript
// ì œí’ˆ ë„ë©”ì¸ ëª¨ë¸ë§
const SKUSchema = z.string()
  .regex(/^[A-Z0-9]{3}-[A-Z0-9]{4}-[A-Z0-9]{3}$/, "SKUëŠ” XXX-XXXX-XXX í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
  .brand<"SKU">();

const PriceSchema = z.number()
  .positive("ê°€ê²©ì€ ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
  .multipleOf(0.01, "ê°€ê²©ì€ ì„¼íŠ¸ ë‹¨ìœ„ê¹Œì§€ë§Œ í—ˆìš©ë©ë‹ˆë‹¤")
  .brand<"Price">();

const InventoryCountSchema = z.number()
  .int("ì¬ê³  ìˆ˜ëŸ‰ì€ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
  .nonnegative("ì¬ê³  ìˆ˜ëŸ‰ì€ 0 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
  .brand<"InventoryCount">();

// ì œí’ˆ ì—”í„°í‹°
const ProductSchema = z.object({
  id: z.string().uuid().brand<"ProductId">(),
  sku: SKUSchema,
  name: z.string().min(1, "ì œí’ˆëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤"),
  description: z.string().optional(),
  price: PriceSchema,
  categoryId: z.string().uuid().brand<"CategoryId">(),
  inventory: InventoryCountSchema,
  isActive: z.boolean().default(true),
  tags: z.array(z.string()).default([])
}).brand<"Product">();

// ì¥ë°”êµ¬ë‹ˆ ì‹œìŠ¤í…œ
const CartItemSchema = z.object({
  productId: z.string().uuid().brand<"ProductId">(),
  quantity: z.number().int().positive().brand<"Quantity">(),
  addedAt: z.date()
}).brand<"CartItem">();

const ShoppingCartSchema = z.object({
  id: z.string().uuid().brand<"CartId">(),
  userId: z.string().uuid().brand<"UserId">(),
  items: z.array(CartItemSchema),
  createdAt: z.date(),
  updatedAt: z.date()
}).brand<"ShoppingCart">();

// ê²°ì œ ì‹œìŠ¤í…œ
const PaymentMethodSchema = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("credit_card"),
    cardNumber: z.string()
      .regex(/^\d{16}$/, "ì¹´ë“œ ë²ˆí˜¸ëŠ” 16ìë¦¬ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤")
      .transform(num => `****-****-****-${num.slice(-4)}`) // ë§ˆìŠ¤í‚¹ ì²˜ë¦¬
      .brand<"MaskedCardNumber">(),
    expiryDate: z.string()
      .regex(/^(0[1-9]|1[0-2])\/\d{2}$/, "ë§Œë£Œì¼ì€ MM/YY í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
      .brand<"ExpiryDate">(),
    cvv: z.string().regex(/^\d{3,4}$/).brand<"CVV">()
  }).brand<"CreditCardPayment">(),
  
  z.object({
    type: z.literal("bank_transfer"),
    accountNumber: z.string()
      .regex(/^\d{10,12}$/, "ê³„ì¢Œë²ˆí˜¸ëŠ” 10-12ìë¦¬ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤")
      .brand<"AccountNumber">(),
    bankCode: z.string().length(3).brand<"BankCode">()
  }).brand<"BankTransferPayment">()
]);

type Product = z.infer<typeof ProductSchema>;
type ShoppingCart = z.infer<typeof ShoppingCartSchema>;
type PaymentMethod = z.infer<typeof PaymentMethodSchema>;
```



---


## ì‹¤ì œ í”„ë¡œì íŠ¸ ì ìš© ì˜ˆì‹œ


### 1. E-commerce ì‹œìŠ¤í…œì—ì„œì˜ í™œìš©

```typescript
// ë„ë©”ì¸ íƒ€ì… ì •ì˜
type CustomerId = Brand<string, 'CustomerId'>;
type OrderId = Brand<string, 'OrderId'>;
type ProductSku = Brand<string, 'ProductSku'>;
type PaymentId = Brand<string, 'PaymentId'>;

// ì£¼ë¬¸ ë„ë©”ì¸ ëª¨ë¸
interface Order {
  id: OrderId;
  customerId: CustomerId;
  items: OrderItem[];
  paymentId?: PaymentId;
  status: OrderStatus;
}

interface OrderItem {
  productSku: ProductSku;
  quantity: number;
  price: Price;
}

// ì„œë¹„ìŠ¤ ë ˆì´ì–´
class OrderService {
  async createOrder(
    customerId: CustomerId, 
    items: Array<{ sku: ProductSku; quantity: number }>
  ): Promise<OrderId> {
    // ì£¼ë¬¸ ìƒì„± ë¡œì§
    const orderId = createOrderId(generateUniqueId());
    // ...
    return orderId;
  }

  async getOrder(orderId: OrderId): Promise<Order | null> {
    // ì£¼ë¬¸ ì¡°íšŒ ë¡œì§
    return null; // ì˜ˆì‹œ
  }

  // ì˜ëª»ëœ IDë¥¼ ì „ë‹¬í•˜ëŠ” ì‹¤ìˆ˜ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— ë°©ì§€
  async processPayment(orderId: OrderId, paymentId: PaymentId): Promise<void> {
    // ê²°ì œ ì²˜ë¦¬ ë¡œì§
  }
}

// ìƒì„± í•¨ìˆ˜ë“¤
function createCustomerId(id: string): CustomerId {
  if (!id.startsWith('cust_')) {
    throw new Error('Customer ID must start with "cust_"');
  }
  return id as CustomerId;
}

function createOrderId(id: string): OrderId {
  if (!id.startsWith('ord_')) {
    throw new Error('Order ID must start with "ord_"');
  }
  return id as OrderId;
}

function createProductSku(sku: string): ProductSku {
  if (!/^[A-Z0-9-]+$/.test(sku)) {
    throw new Error('Invalid SKU format');
  }
  return sku as ProductSku;
}
```


### 2. ê¸ˆìœµ ì‹œìŠ¤í…œì—ì„œì˜ í™œìš©

```typescript
// ê¸ˆìœµ ë„ë©”ì¸ íƒ€ì…
type AccountNumber = Brand<string, 'AccountNumber'>;
type TransactionId = Brand<string, 'TransactionId'>;
type Amount = Brand<number, 'Amount'>;
type Currency = Brand<string, 'Currency'>;

interface Money {
  amount: Amount;
  currency: Currency;
}

// ê³„ì¢Œ ì´ì²´ ì„œë¹„ìŠ¤
class TransferService {
  async transfer(
    fromAccount: AccountNumber,
    toAccount: AccountNumber,
    money: Money
  ): Promise<TransactionId> {
    // ì´ì²´ ë¡œì§
    const transactionId = createTransactionId(generateUniqueId());
    return transactionId;
  }

  // ê¸ˆì•¡ê³¼ ê³„ì¢Œë²ˆí˜¸ë¥¼ ë°”ê¿”ì„œ ì „ë‹¬í•˜ëŠ” ì‹¤ìˆ˜ ë°©ì§€
  async getBalance(accountNumber: AccountNumber): Promise<Money> {
    // ì”ì•¡ ì¡°íšŒ ë¡œì§
    return {
      amount: createAmount(1000),
      currency: createCurrency('KRW')
    };
  }
}

function createAccountNumber(account: string): AccountNumber {
  if (!/^\d{3}-\d{2}-\d{6}$/.test(account)) {
    throw new Error('Invalid account number format');
  }
  return account as AccountNumber;
}

function createAmount(amount: number): Amount {
  if (amount < 0) {
    throw new Error('Amount cannot be negative');
  }
  return amount as Amount;
}

function createCurrency(currency: string): Currency {
  const validCurrencies = ['KRW', 'USD', 'EUR', 'JPY'];
  if (!validCurrencies.includes(currency)) {
    throw new Error('Invalid currency');
  }
  return currency as Currency;
}
```

---


## ê³ ê¸‰ íŒ¨í„´ê³¼ ì‘ìš©


### 1. Union Branded Types

```typescript
type DatabaseId = Brand<string, 'DatabaseId'>;
type RedisId = Brand<string, 'RedisId'>;
type CacheId = DatabaseId | RedisId;

// ë‘˜ ë‹¤ í—ˆìš©í•˜ëŠ” í•¨ìˆ˜
function clearCache(id: CacheId) {
  console.log(`Clearing cache for ${id}`);
}

const dbId = createDatabaseId("db_123");
const redisId = createRedisId("redis_456");

clearCache(dbId); // âœ…
clearCache(redisId); // âœ…

function createDatabaseId(id: string): DatabaseId {
  return id as DatabaseId;
}

function createRedisId(id: string): RedisId {
  return id as RedisId;
}
```


### 2. Branded Type with Validation

```typescript
// ë” ì •êµí•œ ê²€ì¦ì„ í¬í•¨í•œ Branded Type
type PhoneNumber = Brand<string, 'PhoneNumber'>;
type CreditCardNumber = Brand<string, 'CreditCardNumber'>;

function createPhoneNumber(phone: string): PhoneNumber {
  // í•œêµ­ íœ´ëŒ€í° ë²ˆí˜¸ í˜•ì‹ ê²€ì¦
  const phoneRegex = /^01[0-9]-\d{3,4}-\d{4}$/;
  if (!phoneRegex.test(phone)) {
    throw new Error('Invalid phone number format. Use: 010-XXXX-XXXX');
  }
  return phone as PhoneNumber;
}

function createCreditCardNumber(cardNumber: string): CreditCardNumber {
  // Luhn ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ ê²€ì¦
  const cleaned = cardNumber.replace(/\D/g, '');
  if (!isValidCreditCard(cleaned)) {
    throw new Error('Invalid credit card number');
  }
  return cleaned as CreditCardNumber;
}

function isValidCreditCard(cardNumber: string): boolean {
  // Luhn ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
  let sum = 0;
  let shouldDouble = false;

  for (let i = cardNumber.length - 1; i >= 0; i--) {
    let digit = parseInt(cardNumber.charAt(i), 10);

    if (shouldDouble) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }

    sum += digit;
    shouldDouble = !shouldDouble;
  }

  return (sum % 10) === 0;
}

// ì‚¬ìš© ì˜ˆì œ
try {
  const phone = createPhoneNumber("010-1234-5678");
  const card = createCreditCardNumber("4532015112830366"); // ìœ íš¨í•œ í…ŒìŠ¤íŠ¸ ì¹´ë“œ ë²ˆí˜¸
  
  console.log("Valid inputs created successfully");
} catch (error) {
  console.error("Validation failed:", error.message);
}
```


### 3. Generic Branded Type Factory

```typescript
// ì œë„¤ë¦­ì„ í™œìš©í•œ Branded Type íŒ©í† ë¦¬
function createBrandedType<T, TBrand extends string>(
  brandName: TBrand,
  validator?: (value: T) => boolean,
  errorMessage?: string
) {
  type BrandedType = Brand<T, TBrand>;
  
  return {
    create: (value: T): BrandedType => {
      if (validator && !validator(value)) {
        throw new Error(errorMessage || `Invalid ${brandName}`);
      }
      return value as BrandedType;
    },
    is: (value: any): value is BrandedType => {
      return validator ? validator(value) : true;
    }
  };
}

// ì‚¬ìš© ì˜ˆì œ
const PositiveNumber = createBrandedType(
  'PositiveNumber',
  (n: number) => n > 0,
  'Number must be positive'
);

const EvenNumber = createBrandedType(
  'EvenNumber',
  (n: number) => n % 2 === 0,
  'Number must be even'
);

type PositiveNumber = Brand<number, 'PositiveNumber'>;
type EvenNumber = Brand<number, 'EvenNumber'>;

const positiveNum = PositiveNumber.create(42); // âœ…
const evenNum = EvenNumber.create(10); // âœ…

// PositiveNumber.create(-5); // âŒ Error: Number must be positive
// EvenNumber.create(7); // âŒ Error: Number must be even
```


### 4. Branded Typeê³¼ Class ì¡°í•©

```typescript
class UserId {
  private readonly __brand = 'UserId';
  
  private constructor(private readonly value: string) {}
  
  static create(id: string): UserId {
    if (!id.startsWith('user_')) {
      throw new Error('User ID must start with "user_"');
    }
    return new UserId(id);
  }
  
  toString(): string {
    return this.value;
  }
  
  equals(other: UserId): boolean {
    return this.value === other.value;
  }
}

// ì‚¬ìš©ë²•ì´ ë” ê°ì²´ì§€í–¥ì 
const userId1 = UserId.create('user_123');
const userId2 = UserId.create('user_123');

console.log(userId1.toString()); // "user_123"
console.log(userId1.equals(userId2)); // true
```

---

## ê¶Œì¥ì‚¬í•­ ì²´í¬ë¦¬ìŠ¤íŠ¸

```typescript
// âœ… ê¶Œì¥ì‚¬í•­ë“¤

// 1. ì¼ê´€ëœ ë¸Œëœë“œ ë„¤ì´ë° ì»¨ë²¤ì…˜
type UserId = Branded<string, "User.Id">; // ë„ë©”ì¸.íƒ€ì… íŒ¨í„´
type UserEmail = Branded<string, "User.Email">;
type UserName = Branded<string, "User.Name">;

// 2. ì¤‘ì•™í™”ëœ ë¸Œëœë“œ ì •ì˜
// types/brands.ts
export const BrandSymbol: unique symbol = Symbol('brand');
export type Brand<T> = { readonly [BrandSymbol]: T };
export type Branded<T, B> = T & Brand<B>;

// 3. ê²€ì¦ ë¡œì§ê³¼ íŒ©í† ë¦¬ í•¨ìˆ˜ ë¶„ë¦¬
// validators/user.ts
export const createUserId = (raw: string): Result<UserId, ValidationError> => {
  if (!isValidUUID(raw)) {
    return failure(new ValidationError("Invalid UUID format for UserId"));
  }
  return success(raw as UserId);
};

// 4. ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€í™”
class BrandValidationError extends Error {
  constructor(
    public readonly expectedBrand: string,
    public readonly receivedValue: unknown
  ) {
    super(`Expected ${expectedBrand}, received: ${receivedValue}`);
    this.name = "BrandValidationError";
  }
}

// âŒ í”¼í•´ì•¼ í•  ì•ˆí‹°íŒ¨í„´ë“¤

// 1. ê³¼ë„í•œ ë¸Œëœë”© - ëª¨ë“  ì›ì‹œ íƒ€ì…ì„ ë¸Œëœë”©í•˜ì§€ ë§ˆì„¸ìš”
type OverBrandedUser = {
  id: Branded<string, "UserId">;
  name: Branded<string, "UserName">; // í•„ìš” ì´ìƒì˜ ë¸Œëœë”©
  age: Branded<number, "UserAge">;   // ë‹¨ìˆœí•œ ìˆ«ìê¹Œì§€ ë¸Œëœë”©
  isActive: Branded<boolean, "UserActiveStatus">; // ë¶ˆí•„ìš”
};

// 2. ë¸Œëœë“œ ëˆ„ì¶œ - ë¸Œëœë“œ ì†ì„±ì´ ëŸ°íƒ€ì„ì— ë…¸ì¶œë˜ì§€ ì•Šë„ë¡ ì£¼ì˜
const wrongUsage = (userId: UserId) => {
  // âŒ ì˜ëª»ëœ ì‚¬ìš© - ë¸Œëœë“œ ì†ì„±ì— ì ‘ê·¼í•˜ë ¤ í•¨
  console.log(userId.__brand); // undefinedê°€ ì¶œë ¥ë¨
  
  // âœ… ì˜¬ë°”ë¥¸ ì‚¬ìš© - ê°’ ìì²´ë¥¼ ì‚¬ìš©
  console.log(userId); // ì‹¤ì œ ë¬¸ìì—´ ê°’ì´ ì¶œë ¥ë¨
};

// 3. íƒ€ì… ë‹¨ì–¸ ë‚¨ìš© - ê²€ì¦ ì—†ì´ ë¸Œëœë“œ íƒ€ì…ìœ¼ë¡œ ë³€í™˜
const dangerousConversion = (raw: string): UserId => {
  return raw as UserId; // âŒ ìœ„í—˜ - ê²€ì¦ ì—†ì´ ë³€í™˜
};

const safeConversion = (raw: string): Result<UserId, Error> => {
  return UserIdSchema.safeParse(raw).success
    ? success(raw as UserId)
    : failure(new Error("Invalid user ID"));
};
```

## ì¥ì ê³¼ ì£¼ì˜ì‚¬í•­


### ì¥ì 

1. **ì»´íŒŒì¼ íƒ€ì„ ì•ˆì „ì„±** : ì˜ëª»ëœ íƒ€ì… ì „ë‹¬ì„ ì‚¬ì „ì— ë°©ì§€
2. **ì½”ë“œ ê°€ë…ì„± í–¥ìƒ** : í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë§Œ ë´ë„ ì–´ë–¤ ì¢…ë¥˜ì˜ ê°’ì„ ë°›ëŠ”ì§€ ëª…í™•
3. **ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œ ì—†ìŒ** : ì»´íŒŒì¼ í›„ì—ëŠ” ì¼ë°˜ íƒ€ì…ê³¼ ë™ì¼
4. **ë„ë©”ì¸ ëª¨ë¸ë§** : ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ íƒ€ì… ë ˆë²¨ì—ì„œ í‘œí˜„ ê°€ëŠ¥


### í•œê³„ì™€ ì£¼ì˜ì‚¬í•­

1. **ì´ˆê¸° í•™ìŠµ ë¹„ìš©** : íŒ€ì›ë“¤ì´ íŒ¨í„´ì„ ì´í•´í•˜ê³  ì ìš©í•˜ëŠ” ë° ì‹œê°„ í•„ìš”
2. **ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ** : ìƒì„± í•¨ìˆ˜ë“¤ì„ ë§Œë“¤ì–´ì•¼ í•˜ëŠ” ì¶”ê°€ ì‘ì—…
3. **íƒ€ì… ì–´ì„¤ì…˜ ë‚¨ìš© ìœ„í—˜** : `as` í‚¤ì›Œë“œë¥¼ ì˜ëª» ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
4. **ê³¼ë„í•œ ì ìš©** : ëª¨ë“  primitive íƒ€ì…ì— ì ìš©í•˜ë©´ ì˜¤íˆë ¤ ë³µì¡ì„± ì¦ê°€


### íŒ€ ë„ì… ì‹œ ê¶Œì¥ì‚¬í•­

1. **ì ì§„ì  ë„ì…** : í•µì‹¬ ë„ë©”ì¸ë¶€í„° ì‹œì‘í•´ì„œ ì ì°¨ í™•ì¥
2. **ë„¤ì´ë° ì»¨ë²¤ì…˜ ì •ë¦½** : ì¼ê´€ëœ ìƒì„± í•¨ìˆ˜ ëª…ëª… ê·œì¹™ ìˆ˜ë¦½
3. **ë¬¸ì„œí™”**: ì–´ë–¤ ê²½ìš°ì— Branded Typeì„ ì‚¬ìš©í• ì§€ ê°€ì´ë“œë¼ì¸ ì‘ì„±
4. **ì½”ë“œ ë¦¬ë·°** : ì˜¬ë°”ë¥¸ íŒ¨í„´ ì‚¬ìš© ì—¬ë¶€ë¥¼ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸ì— í¬í•¨
