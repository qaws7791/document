# TypeScript에서의 Branded Type


## 왜 Branded Type이 필요한가?

TypeScript를 사용하면서 이런 경험이 있으셨나요? 사용자 ID와 상품 ID가 모두 `string` 타입이라서, 실수로 서로 바꿔서 전달해도 컴파일 에러가 발생하지 않는 상황 말입니다.

- 구조적 타이핑의 단점: 구조가 동일하면 서로 호환되는 특성으로 인해 의미적으로는 전혀 다른 값들이 실수로 교체되는 상황이 만들어질 수 있다.

```typescript
function getUser(userId: string) { /* ... */ }
function getProduct(productId: string) { /* ... */ }

const userId = "user_123";
const productId = "product_456";

// 실수로 바꿔서 전달해도 TypeScript는 에러를 잡지 못함
getUser(productId); // 😱 런타임에서야 문제를 발견
getProduct(userId); // 😱 타입 안전성이 보장되지 않음
```

이런 문제는 특히 대규모 프로젝트에서 자주 발생합니다. 같은 기본 타입(`string`, `number`)을 가지지만 의미적으로 완전히 다른 값들이 서로 호환되어버리죠. 이때 **Branded Type** 이 해결책이 됩니다.

Branded Type은 동일한 기본 타입이지만 **의미적으로 구분되는 타입을 만들어주는 TypeScript의 고급 패턴** 입니다. 마치 물리학에서 "길이"와 "시간"이 모두 숫자지만 완전히 다른 개념인 것처럼, 코드에서도 같은 원리를 적용할 수 있게 해줍니다.

---


## Branded Type의 핵심 개념


### 기본 정의

Branded Type(브랜드 타입)은 기존 타입에 **고유한 "브랜드" 마크를 붙여서 타입 레벨에서 구분 가능하게 만드는 기법** 입니다. TypeScript의 구조적 타이핑(Structural Typing) 시스템을 활용해, 런타임에는 영향을 주지 않으면서도 컴파일 타임에 타입 안전성을 확보합니다.


### 기술적 배경

이 패턴은 **Nominal Typing** 의 개념을 TypeScript의 **Structural Typing** 환경에 도입한 것입니다.

- **구조적 타이핑(Structural Typing)** : 타입의 구조가 같으면 호환 가능 (TypeScript 기본 방식)
- **명시적 타이핑(Nominal Typing)** : 타입의 이름이 같아야만 호환 가능 (Java, C# 방식)

Branded Type은 구조적으로는 같지만 **논리적으로는 다른 타입** 을 만들어, 두 방식의 장점을 결합합니다.

---


## 기본 구현과 활용

### 가장 기본적인 Branded Type 만들기

브랜드 타입은 교차 타입(intersection types)을 활용해 구조적으로 동일한 타입에 고유한 "브랜드" 속성을 추가하여 타입 레벨에서 구분 가능하게 만든다.

```typescript
// Brand 유틸리티 타입 정의
type Brand<T, TBrand extends string> = T & { readonly __brand: TBrand };

// 구체적인 Branded Type들 정의
type UserId = Brand<string, 'UserId'>;
type ProductId = Brand<string, 'ProductId'>;
type Email = Brand<string, 'Email'>;

// 생성 함수들
function createUserId(id: string): UserId {
  return id as UserId;
}

function createProductId(id: string): ProductId {
  return id as ProductId;
}

function createEmail(email: string): Email {
  // 간단한 검증 로직 추가 가능
  if (!email.includes('@')) {
    throw new Error('Invalid email format');
  }
  return email as Email;
}
```

### TypeScript 컴파일러의 브랜드 타입 처리

TypeScript 컴파일러는 **타입 삭제(type erasure)** 과정에서 모든 브랜드 정보를 제거한다. 이는 브랜드 타입이 런타임에 전혀 영향을 주지 않으면서도 컴파일 타임에 강력한 타입 안전성을 제공한다는 의미이다.

```typescript
type UserId = Branded<string, "UserId">;
const userId: UserId = "user_123" as UserId;

// 컴파일 후에는 단순한 문자열로 변환됨
console.log(typeof userId); // "string"
console.log(userId.__brand); // undefined - 런타임에는 존재하지 않음
```

### 실제 사용 예제

```typescript
// 함수 정의
function getUser(userId: UserId) {
  console.log(`사용자 조회: ${userId}`);
}

function getProduct(productId: ProductId) {
  console.log(`상품 조회: ${productId}`);
}

function sendEmail(email: Email, message: string) {
  console.log(`이메일 발송 to ${email}: ${message}`);
}

// 올바른 사용법
const userId = createUserId("user_123");
const productId = createProductId("product_456");
const email = createEmail("user@example.com");

getUser(userId); // ✅ 정상 동작
getProduct(productId); // ✅ 정상 동작
sendEmail(email, "Welcome!"); // ✅ 정상 동작

// 잘못된 사용법 - 컴파일 에러 발생!
getUser(productId); // ❌ Type 'ProductId' is not assignable to parameter of type 'UserId'
getProduct(userId); // ❌ Type 'UserId' is not assignable to parameter of type 'ProductId'
sendEmail("invalid-email", "Hello"); // ❌ Type 'string' is not assignable to parameter of type 'Email'
```


### 숫자형 Branded Type 예제

```typescript
type Age = Brand<number, 'Age'>;
type Price = Brand<number, 'Price'>;
type Temperature = Brand<number, 'Temperature'>;

function createAge(age: number): Age {
  if (age < 0 || age > 150) {
    throw new Error('Invalid age range');
  }
  return age as Age;
}

function createPrice(price: number): Price {
  if (price < 0) {
    throw new Error('Price cannot be negative');
  }
  return price as Price;
}

function createTemperature(temp: number): Temperature {
  return temp as Temperature;
}

// 사용 예제
function calculateDiscount(age: Age, price: Price): Price {
  if (age >= 65) {
    return createPrice(price * 0.8); // 65세 이상 20% 할인
  }
  return price;
}

const customerAge = createAge(70);
const itemPrice = createPrice(100);
const discountedPrice = calculateDiscount(customerAge, itemPrice);

// 잘못된 사용 - 컴파일 에러
// calculateDiscount(itemPrice, customerAge); // ❌ 매개변수 순서 바뀜
```


### Anti-pattern: 잘못된 사용 예제

```typescript
// ❌ 잘못된 방법: Brand 없이 그냥 사용
function badGetUser(userId: string) { /* ... */ }
function badGetProduct(productId: string) { /* ... */ }

const badUserId = "user_123";
const badProductId = "product_456";

// 이렇게 하면 실수로 바꿔도 에러가 나지 않음
badGetUser(badProductId); // 😱 컴파일 통과, 런타임 에러 가능성

// ❌ 잘못된 방법: 직접 타입 어설션 사용
const directUserId = "user_123" as UserId; // 검증 로직 없이 강제 변환
```

------

## Zod와의 통합

### Zod 브랜드 타입의 기본 사용법

Zod는 내장된 `.brand<T>()` 메서드를 통해 브랜드 타입을 자연스럽게 지원한다. 이는 런타임 검증과 컴파일 타임 안전성을 동시에 제공하는 강력한 조합을 만들어낸다. 

```typescript
import { z } from "zod";

// 기본 브랜드 타입 스키마 정의
const UserIdSchema = z.string().uuid().brand<"UserId">();
const EmailSchema = z.string().email().brand<"EmailAddress">();
const PositiveNumberSchema = z.number().positive().brand<"PositiveNumber">();

// 타입 추출
type UserId = z.infer<typeof UserIdSchema>;
type EmailAddress = z.infer<typeof EmailSchema>;
type PositiveNumber = z.infer<typeof PositiveNumberSchema>;

// 사용 예시
const rawData = {
  userId: "550e8400-e29b-41d4-a716-446655440000",
  email: "user@example.com", 
  score: 95
};

// 안전한 파싱과 브랜딩
const userId = UserIdSchema.parse(rawData.userId);
const email = EmailSchema.parse(rawData.email);
const score = PositiveNumberSchema.parse(rawData.score);

// 이제 브랜드가 적용된 타입으로 안전하게 사용
processUser(userId, email); // 타입 안전성 보장
```

### 고급 검증 패턴과 변환

Zod의 `.refine()`과 `.transform()` 메서드를 브랜드 타입과 함께 사용하면 더욱 정교한 검증과 데이터 변환이 가능하다. 

```typescript
// 복합 검증 규칙이 적용된 브랜드 타입
const StrongPasswordSchema = z.string()
  .min(8, "비밀번호는 최소 8자 이상이어야 합니다")
  .refine(val => /[A-Z]/.test(val), "대문자가 포함되어야 합니다")
  .refine(val => /[a-z]/.test(val), "소문자가 포함되어야 합니다")
  .refine(val => /[0-9]/.test(val), "숫자가 포함되어야 합니다")
  .refine(val => /[!@#$%^&*]/.test(val), "특수문자가 포함되어야 합니다")
  .brand<"StrongPassword">();

// 데이터 변환과 정규화를 포함한 브랜드 타입
const NormalizedEmailSchema = z.string()
  .email("유효한 이메일 주소를 입력해주세요")
  .transform(email => email.toLowerCase().trim())
  .brand<"NormalizedEmail">();

// URL 검증 및 보완
const ValidatedUrlSchema = z.string()
  .transform((val, ctx) => {
    let completeUrl = val;
    
    // http/https 프로토콜 자동 추가
    if (!val.startsWith('http')) {
      completeUrl = `https://${val}`;
    }
    
    try {
      new URL(completeUrl);
      return completeUrl;
    } catch {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "유효한 URL 형식이 아닙니다",
      });
      return z.NEVER;
    }
  })
  .brand<"ValidatedUrl">();

type StrongPassword = z.infer<typeof StrongPasswordSchema>;
type NormalizedEmail = z.infer<typeof NormalizedEmailSchema>;
type ValidatedUrl = z.infer<typeof ValidatedUrlSchema>;
```

### 스키마 구성과 재사용성

대규모 애플리케이션에서는 스키마의 구성과 재사용이 핵심이다. Zod의 강력한 스키마 조합 기능을 브랜드 타입과 함께 활용해보자.

```typescript
// 기본 엔터티 스키마 정의
const BaseEntitySchema = z.object({
  id: z.string().uuid().brand<"EntityId">(),
  createdAt: z.date(),
  updatedAt: z.date(),
  version: z.number().int().nonnegative().brand<"Version">()
});

// 주소 정보 스키마
const AddressSchema = z.object({
  street: z.string().min(1, "도로명을 입력해주세요"),
  city: z.string().min(1, "도시를 입력해주세요"),
  zipCode: z.string()
    .regex(/^\d{5}$/, "우편번호는 5자리 숫자여야 합니다")
    .brand<"ZipCode">(),
  country: z.string().default("KR")
}).brand<"Address">();

// 사용자 스키마 확장
const UserSchema = BaseEntitySchema.extend({
  email: NormalizedEmailSchema,
  name: z.string().min(1, "이름을 입력해주세요"),
  age: z.number()
    .int("나이는 정수여야 합니다")
    .min(0, "나이는 0 이상이어야 합니다")
    .max(150, "유효한 나이를 입력해주세요")
    .brand<"ValidAge">(),
  address: AddressSchema.optional()
}).brand<"User">();

// 주문 스키마 구성
const OrderItemSchema = z.object({
  productId: z.string().uuid().brand<"ProductId">(),
  quantity: z.number().int().positive().brand<"Quantity">(),
  unitPrice: z.number().positive().brand<"Price">()
}).brand<"OrderItem">();

const OrderSchema = BaseEntitySchema.extend({
  userId: z.string().uuid().brand<"UserId">(),
  items: z.array(OrderItemSchema),
  totalAmount: z.number().positive().brand<"TotalAmount">(),
  status: z.enum(["pending", "confirmed", "shipped", "delivered"])
    .brand<"OrderStatus">()
}).superRefine((order, ctx) => {
  // 비즈니스 룰: 총액이 아이템 가격의 합과 일치해야 함
  const calculatedTotal = order.items.reduce(
    (sum, item) => sum + (item.quantity * item.unitPrice), 
    0
  );
  
  if (Math.abs(calculatedTotal - order.totalAmount) > 0.01) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "총 주문 금액이 아이템 가격의 합과 일치하지 않습니다",
      path: ["totalAmount"]
    });
  }
}).brand<"Order">();

// 타입 추출
type User = z.infer<typeof UserSchema>;
type Order = z.infer<typeof OrderSchema>;
type OrderItem = z.infer<typeof OrderItemSchema>;
```

### 실전 도메인 모델링 사례

실제 전자상거래 플랫폼에서 브랜드 타입을 어떻게 활용하는지 살펴보자. 

```typescript
// 제품 도메인 모델링
const SKUSchema = z.string()
  .regex(/^[A-Z0-9]{3}-[A-Z0-9]{4}-[A-Z0-9]{3}$/, "SKU는 XXX-XXXX-XXX 형식이어야 합니다")
  .brand<"SKU">();

const PriceSchema = z.number()
  .positive("가격은 양수여야 합니다")
  .multipleOf(0.01, "가격은 센트 단위까지만 허용됩니다")
  .brand<"Price">();

const InventoryCountSchema = z.number()
  .int("재고 수량은 정수여야 합니다")
  .nonnegative("재고 수량은 0 이상이어야 합니다")
  .brand<"InventoryCount">();

// 제품 엔터티
const ProductSchema = z.object({
  id: z.string().uuid().brand<"ProductId">(),
  sku: SKUSchema,
  name: z.string().min(1, "제품명은 필수입니다"),
  description: z.string().optional(),
  price: PriceSchema,
  categoryId: z.string().uuid().brand<"CategoryId">(),
  inventory: InventoryCountSchema,
  isActive: z.boolean().default(true),
  tags: z.array(z.string()).default([])
}).brand<"Product">();

// 장바구니 시스템
const CartItemSchema = z.object({
  productId: z.string().uuid().brand<"ProductId">(),
  quantity: z.number().int().positive().brand<"Quantity">(),
  addedAt: z.date()
}).brand<"CartItem">();

const ShoppingCartSchema = z.object({
  id: z.string().uuid().brand<"CartId">(),
  userId: z.string().uuid().brand<"UserId">(),
  items: z.array(CartItemSchema),
  createdAt: z.date(),
  updatedAt: z.date()
}).brand<"ShoppingCart">();

// 결제 시스템
const PaymentMethodSchema = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("credit_card"),
    cardNumber: z.string()
      .regex(/^\d{16}$/, "카드 번호는 16자리 숫자여야 합니다")
      .transform(num => `****-****-****-${num.slice(-4)}`) // 마스킹 처리
      .brand<"MaskedCardNumber">(),
    expiryDate: z.string()
      .regex(/^(0[1-9]|1[0-2])\/\d{2}$/, "만료일은 MM/YY 형식이어야 합니다")
      .brand<"ExpiryDate">(),
    cvv: z.string().regex(/^\d{3,4}$/).brand<"CVV">()
  }).brand<"CreditCardPayment">(),
  
  z.object({
    type: z.literal("bank_transfer"),
    accountNumber: z.string()
      .regex(/^\d{10,12}$/, "계좌번호는 10-12자리 숫자여야 합니다")
      .brand<"AccountNumber">(),
    bankCode: z.string().length(3).brand<"BankCode">()
  }).brand<"BankTransferPayment">()
]);

type Product = z.infer<typeof ProductSchema>;
type ShoppingCart = z.infer<typeof ShoppingCartSchema>;
type PaymentMethod = z.infer<typeof PaymentMethodSchema>;
```



---


## 실제 프로젝트 적용 예시


### 1. E-commerce 시스템에서의 활용

```typescript
// 도메인 타입 정의
type CustomerId = Brand<string, 'CustomerId'>;
type OrderId = Brand<string, 'OrderId'>;
type ProductSku = Brand<string, 'ProductSku'>;
type PaymentId = Brand<string, 'PaymentId'>;

// 주문 도메인 모델
interface Order {
  id: OrderId;
  customerId: CustomerId;
  items: OrderItem[];
  paymentId?: PaymentId;
  status: OrderStatus;
}

interface OrderItem {
  productSku: ProductSku;
  quantity: number;
  price: Price;
}

// 서비스 레이어
class OrderService {
  async createOrder(
    customerId: CustomerId, 
    items: Array<{ sku: ProductSku; quantity: number }>
  ): Promise<OrderId> {
    // 주문 생성 로직
    const orderId = createOrderId(generateUniqueId());
    // ...
    return orderId;
  }

  async getOrder(orderId: OrderId): Promise<Order | null> {
    // 주문 조회 로직
    return null; // 예시
  }

  // 잘못된 ID를 전달하는 실수를 컴파일 타임에 방지
  async processPayment(orderId: OrderId, paymentId: PaymentId): Promise<void> {
    // 결제 처리 로직
  }
}

// 생성 함수들
function createCustomerId(id: string): CustomerId {
  if (!id.startsWith('cust_')) {
    throw new Error('Customer ID must start with "cust_"');
  }
  return id as CustomerId;
}

function createOrderId(id: string): OrderId {
  if (!id.startsWith('ord_')) {
    throw new Error('Order ID must start with "ord_"');
  }
  return id as OrderId;
}

function createProductSku(sku: string): ProductSku {
  if (!/^[A-Z0-9-]+$/.test(sku)) {
    throw new Error('Invalid SKU format');
  }
  return sku as ProductSku;
}
```


### 2. 금융 시스템에서의 활용

```typescript
// 금융 도메인 타입
type AccountNumber = Brand<string, 'AccountNumber'>;
type TransactionId = Brand<string, 'TransactionId'>;
type Amount = Brand<number, 'Amount'>;
type Currency = Brand<string, 'Currency'>;

interface Money {
  amount: Amount;
  currency: Currency;
}

// 계좌 이체 서비스
class TransferService {
  async transfer(
    fromAccount: AccountNumber,
    toAccount: AccountNumber,
    money: Money
  ): Promise<TransactionId> {
    // 이체 로직
    const transactionId = createTransactionId(generateUniqueId());
    return transactionId;
  }

  // 금액과 계좌번호를 바꿔서 전달하는 실수 방지
  async getBalance(accountNumber: AccountNumber): Promise<Money> {
    // 잔액 조회 로직
    return {
      amount: createAmount(1000),
      currency: createCurrency('KRW')
    };
  }
}

function createAccountNumber(account: string): AccountNumber {
  if (!/^\d{3}-\d{2}-\d{6}$/.test(account)) {
    throw new Error('Invalid account number format');
  }
  return account as AccountNumber;
}

function createAmount(amount: number): Amount {
  if (amount < 0) {
    throw new Error('Amount cannot be negative');
  }
  return amount as Amount;
}

function createCurrency(currency: string): Currency {
  const validCurrencies = ['KRW', 'USD', 'EUR', 'JPY'];
  if (!validCurrencies.includes(currency)) {
    throw new Error('Invalid currency');
  }
  return currency as Currency;
}
```

---


## 고급 패턴과 응용


### 1. Union Branded Types

```typescript
type DatabaseId = Brand<string, 'DatabaseId'>;
type RedisId = Brand<string, 'RedisId'>;
type CacheId = DatabaseId | RedisId;

// 둘 다 허용하는 함수
function clearCache(id: CacheId) {
  console.log(`Clearing cache for ${id}`);
}

const dbId = createDatabaseId("db_123");
const redisId = createRedisId("redis_456");

clearCache(dbId); // ✅
clearCache(redisId); // ✅

function createDatabaseId(id: string): DatabaseId {
  return id as DatabaseId;
}

function createRedisId(id: string): RedisId {
  return id as RedisId;
}
```


### 2. Branded Type with Validation

```typescript
// 더 정교한 검증을 포함한 Branded Type
type PhoneNumber = Brand<string, 'PhoneNumber'>;
type CreditCardNumber = Brand<string, 'CreditCardNumber'>;

function createPhoneNumber(phone: string): PhoneNumber {
  // 한국 휴대폰 번호 형식 검증
  const phoneRegex = /^01[0-9]-\d{3,4}-\d{4}$/;
  if (!phoneRegex.test(phone)) {
    throw new Error('Invalid phone number format. Use: 010-XXXX-XXXX');
  }
  return phone as PhoneNumber;
}

function createCreditCardNumber(cardNumber: string): CreditCardNumber {
  // Luhn 알고리즘으로 신용카드 번호 검증
  const cleaned = cardNumber.replace(/\D/g, '');
  if (!isValidCreditCard(cleaned)) {
    throw new Error('Invalid credit card number');
  }
  return cleaned as CreditCardNumber;
}

function isValidCreditCard(cardNumber: string): boolean {
  // Luhn 알고리즘 구현
  let sum = 0;
  let shouldDouble = false;

  for (let i = cardNumber.length - 1; i >= 0; i--) {
    let digit = parseInt(cardNumber.charAt(i), 10);

    if (shouldDouble) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }

    sum += digit;
    shouldDouble = !shouldDouble;
  }

  return (sum % 10) === 0;
}

// 사용 예제
try {
  const phone = createPhoneNumber("010-1234-5678");
  const card = createCreditCardNumber("4532015112830366"); // 유효한 테스트 카드 번호
  
  console.log("Valid inputs created successfully");
} catch (error) {
  console.error("Validation failed:", error.message);
}
```


### 3. Generic Branded Type Factory

```typescript
// 제네릭을 활용한 Branded Type 팩토리
function createBrandedType<T, TBrand extends string>(
  brandName: TBrand,
  validator?: (value: T) => boolean,
  errorMessage?: string
) {
  type BrandedType = Brand<T, TBrand>;
  
  return {
    create: (value: T): BrandedType => {
      if (validator && !validator(value)) {
        throw new Error(errorMessage || `Invalid ${brandName}`);
      }
      return value as BrandedType;
    },
    is: (value: any): value is BrandedType => {
      return validator ? validator(value) : true;
    }
  };
}

// 사용 예제
const PositiveNumber = createBrandedType(
  'PositiveNumber',
  (n: number) => n > 0,
  'Number must be positive'
);

const EvenNumber = createBrandedType(
  'EvenNumber',
  (n: number) => n % 2 === 0,
  'Number must be even'
);

type PositiveNumber = Brand<number, 'PositiveNumber'>;
type EvenNumber = Brand<number, 'EvenNumber'>;

const positiveNum = PositiveNumber.create(42); // ✅
const evenNum = EvenNumber.create(10); // ✅

// PositiveNumber.create(-5); // ❌ Error: Number must be positive
// EvenNumber.create(7); // ❌ Error: Number must be even
```


### 4. Branded Type과 Class 조합

```typescript
class UserId {
  private readonly __brand = 'UserId';
  
  private constructor(private readonly value: string) {}
  
  static create(id: string): UserId {
    if (!id.startsWith('user_')) {
      throw new Error('User ID must start with "user_"');
    }
    return new UserId(id);
  }
  
  toString(): string {
    return this.value;
  }
  
  equals(other: UserId): boolean {
    return this.value === other.value;
  }
}

// 사용법이 더 객체지향적
const userId1 = UserId.create('user_123');
const userId2 = UserId.create('user_123');

console.log(userId1.toString()); // "user_123"
console.log(userId1.equals(userId2)); // true
```

---

## 권장사항 체크리스트

```typescript
// ✅ 권장사항들

// 1. 일관된 브랜드 네이밍 컨벤션
type UserId = Branded<string, "User.Id">; // 도메인.타입 패턴
type UserEmail = Branded<string, "User.Email">;
type UserName = Branded<string, "User.Name">;

// 2. 중앙화된 브랜드 정의
// types/brands.ts
export const BrandSymbol: unique symbol = Symbol('brand');
export type Brand<T> = { readonly [BrandSymbol]: T };
export type Branded<T, B> = T & Brand<B>;

// 3. 검증 로직과 팩토리 함수 분리
// validators/user.ts
export const createUserId = (raw: string): Result<UserId, ValidationError> => {
  if (!isValidUUID(raw)) {
    return failure(new ValidationError("Invalid UUID format for UserId"));
  }
  return success(raw as UserId);
};

// 4. 에러 처리 표준화
class BrandValidationError extends Error {
  constructor(
    public readonly expectedBrand: string,
    public readonly receivedValue: unknown
  ) {
    super(`Expected ${expectedBrand}, received: ${receivedValue}`);
    this.name = "BrandValidationError";
  }
}

// ❌ 피해야 할 안티패턴들

// 1. 과도한 브랜딩 - 모든 원시 타입을 브랜딩하지 마세요
type OverBrandedUser = {
  id: Branded<string, "UserId">;
  name: Branded<string, "UserName">; // 필요 이상의 브랜딩
  age: Branded<number, "UserAge">;   // 단순한 숫자까지 브랜딩
  isActive: Branded<boolean, "UserActiveStatus">; // 불필요
};

// 2. 브랜드 누출 - 브랜드 속성이 런타임에 노출되지 않도록 주의
const wrongUsage = (userId: UserId) => {
  // ❌ 잘못된 사용 - 브랜드 속성에 접근하려 함
  console.log(userId.__brand); // undefined가 출력됨
  
  // ✅ 올바른 사용 - 값 자체를 사용
  console.log(userId); // 실제 문자열 값이 출력됨
};

// 3. 타입 단언 남용 - 검증 없이 브랜드 타입으로 변환
const dangerousConversion = (raw: string): UserId => {
  return raw as UserId; // ❌ 위험 - 검증 없이 변환
};

const safeConversion = (raw: string): Result<UserId, Error> => {
  return UserIdSchema.safeParse(raw).success
    ? success(raw as UserId)
    : failure(new Error("Invalid user ID"));
};
```

## 장점과 주의사항


### 장점

1. **컴파일 타임 안전성** : 잘못된 타입 전달을 사전에 방지
2. **코드 가독성 향상** : 함수 시그니처만 봐도 어떤 종류의 값을 받는지 명확
3. **런타임 오버헤드 없음** : 컴파일 후에는 일반 타입과 동일
4. **도메인 모델링** : 비즈니스 로직을 타입 레벨에서 표현 가능


### 한계와 주의사항

1. **초기 학습 비용** : 팀원들이 패턴을 이해하고 적용하는 데 시간 필요
2. **보일러플레이트 코드** : 생성 함수들을 만들어야 하는 추가 작업
3. **타입 어설션 남용 위험** : `as` 키워드를 잘못 사용할 수 있음
4. **과도한 적용** : 모든 primitive 타입에 적용하면 오히려 복잡성 증가


### 팀 도입 시 권장사항

1. **점진적 도입** : 핵심 도메인부터 시작해서 점차 확장
2. **네이밍 컨벤션 정립** : 일관된 생성 함수 명명 규칙 수립
3. **문서화**: 어떤 경우에 Branded Type을 사용할지 가이드라인 작성
4. **코드 리뷰** : 올바른 패턴 사용 여부를 리뷰 체크리스트에 포함
