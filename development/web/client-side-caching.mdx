---
title: 웹 클라이언트 측 캐싱
description: 현대 웹 애플리케이션에서 클라이언트 측 캐싱의 중요성, 계층, 전략을 심층 분석합니다
---


## 섹션 1: 캐싱 스펙트럼: 원칙과 계층

현대 웹 애플리케이션의 성능, 복원력, 효율성은 정교한 클라이언트 측 캐싱 전략에 크게 의존합니다. 클라이언트 측 캐싱은 단순히 정적 자산을 저장하는 것을 넘어, 동적 데이터를 관리하고 오프라인 경험을 지원하며 서버 부하를 극적으로 줄이는 다계층 아키텍처로 발전했습니다. 이 보고서는 HTTP 프로토콜 수준의 캐싱부터 최신 애플리케이션 상태 관리 라이브러리에 이르기까지, 클라이언트 측 캐싱의 모든 계층을 심층적으로 분석하고 비교하여 현대 웹 서비스 아키텍처를 위한 포괄적인 프레임워크를 제공합니다.


### 1.1. 클라이언트 측 캐싱의 "이유": 성능, 복원력, 효율성

클라이언트 측 캐싱(또는 브라우저 캐싱)은 웹 리소스(HTML, CSS, JavaScript, 이미지, API 응답 등)의 사본을 서버가 아닌 사용자의 로컬 장치에 일시적으로 저장하는 기술입니다. 이는 서버 측 캐싱과 대조됩니다. 서버 측 캐싱은 서버 자체의 메모리나 디스크에 데이터를 저장하여 반복적인 계산이나 데이터베이스 쿼리를 줄이는 데 중점을 둡니다. 클라이언트 측 캐싱은 다음과 같은 핵심적인 이점을 제공함으로써 현대 웹 애플리케이션의 필수 요소로 자리 잡았습니다.

애플리케이션 성능 향상: 가장 중요한 이점은 네트워크 왕복(round-trip)을 제거하여 대기 시간(latency)과 페이지 로드 시간을 극적으로 단축하는 것입니다. 로컬 캐시에서 데이터를 검색하는 것은 원격 서버에서 다운로드하는 것보다 훨씬 빠릅니다. 로컬 캐시 접근 시간은 1밀리초 미만일 수 있는 반면, 원격 접근은 수십에서 수백 밀리초가 소요될 수 있어 성능 차이가 극명합니다.

서버 부하 및 비용 절감: 자주 요청되는 콘텐츠를 클라이언트 캐시에서 제공함으로써 원본 서버에 도달하는 요청 수가 줄어듭니다. 이는 서버의 작업 부하를 감소시키고, 대역폭 소비를 줄이며, 결과적으로 인프라 비용을 절감하는 효과를 가져옵니다. 단일 캐시 인스턴스는 수십만 IOPS(초당 입출력 작업)를 처리하여 여러 데이터베이스 인스턴스를 대체할 수 있습니다.

향상된 복원력 및 오프라인 기능: 캐시된 리소스는 네트워크 연결이 불안정하거나 서버가 일시적으로 다운되었을 때도 애플리케이션이 부분적으로 또는 완전히 기능하도록 합니다. 이는 점진적 웹 앱(Progressive Web Apps, PWA)의 핵심 원칙이며, 사용자에게 끊김 없는 경험을 제공합니다.

예측 가능한 성능: 트래픽 급증 시에도 클라이언트 캐시가 요청을 분산 처리함으로써 데이터베이스 핫스팟(hotspot) 발생을 완화하고 일관된 사용자 경험을 보장합니다.


### ### 1.2. 다계층 모델: 클라이언트 측 캐싱 스택의 아키텍처 개요

현대 클라이언트 측 캐싱은 단일 기술이 아닌, 각각 다른 목적에 최적화된 여러 메커니즘이 계층적으로 작동하는 "캐싱 스택(caching stack)"으로 이해해야 합니다. 이 스택은 요청 처리 흐름에 따라 다음과 같이 구성됩니다.

계층 1: HTTP 캐시 (브라우저 캐시): 가장 기본적인 방어선으로, 서버가 전송하는 HTTP 헤더에 의해 제어됩니다. 주로 변경되지 않는 정적 자산(JS, CSS, 이미지, 폰트)을 다시 다운로드하는 문제를 해결합니다.

계층 2: 서비스 워커 캐시: 애플리케이션과 네트워크 사이에 위치하는 프로그래밍 가능한 프록시입니다. 개발자에게 캐싱 로직에 대한 완전한 제어권을 부여하며, 오프라인 우선(offline-first) 전략과 애플리케이션 "셸(shell)" 캐싱을 가능하게 합니다.

계층 3: 브라우저 스토리지 (영구 데이터): LocalStorage, SessionStorage, IndexedDB, 그리고 강력한 WASM SQLite를 포함합니다. 구조화된 애플리케이션 데이터, 사용자 설정 등을 저장하고 복잡한 오프라인 기능을 구현하는 데 사용됩니다.

계층 4: 애플리케이션 상태 캐시 (인메모리): Tanstack Query, SWR, Zustand, Redux, GraphQL 클라이언트와 같은 라이브러리에 의해 관리됩니다. 사용자 세션 동안 API 응답과 같은 "서버 상태"를 JavaScript 메모리에 캐싱하여 불필요한 데이터 가져오기를 방지하고 데이터의 생명주기를 관리합니다.

이러한 캐싱 스택의 발전은 웹 자체의 진화 과정을 반영합니다. 초기 웹은 문서를 보여주는 것이 중심이었기 때문에, 정적 파일을 HTTP 헤더로 캐싱하는 것만으로도 충분했습니다. 목표는 동일한 파일을 반복해서 다운로드하지 않는 것이었습니다. 그러나 단일 페이지 애플리케이션(SPA)의 등장으로 단순한 자산 캐싱 이상의 것이 필요해졌습니다. 애플리케이션은 오프라인에서도 작동해야 했고, 더 안정적인 네트워크 처리가 요구되었습니다. 이는 개발자에게 프로그래밍 방식의 제어를 제공하는 서비스 워커와 Cache API의 탄생으로 이어졌습니다.

SPA가 점점 더 데이터 중심으로 변하면서, API에서 가져온 상태를 관리하는 것이 주요 과제가 되었습니다. API 응답을 단순히 LocalStorage에 저장하는 것은 비효율적이며 데이터 동기화 문제를 야기했습니다. 이로 인해 원격 데이터의 생명주기(가져오기, 캐싱, 백그라운드 재검증, 가비지 컬렉션)를 이해하는 인메모리 "서버 상태" 관리 라이브러리(Tanstack Query, SWR 등)가 필요하게 되었습니다. 따라서 클라이언트 측 캐싱 스택은 단순히 도구의 집합이 아니라, 웹의 복잡성 증가와 상태 관리의 중심이 서버에서 클라이언트로 이동해 온 역사를 보여주는 증거입니다.


## 섹션 2: 기본 계층: HTTP 캐싱

HTTP 캐싱은 웹 성능의 기반을 이루는 프로토콜 수준의 메커니즘입니다. 서버와 클라이언트 간의 명시적인 계약을 통해 작동하며, 올바르게 구성될 경우 네트워크 트래픽을 크게 줄일 수 있습니다. 이 섹션에서는 HTTP 캐싱을 제어하는 핵심 헤더와 전략을 심층적으로 분석합니다.


### 2.1. 신선도 제어: Cache-Control 지시어 심층 분석

Cache-Control은 캐싱 정책을 지정하는 가장 중요하고 강력한 HTTP 헤더입니다. 이 헤더는 다양한 지시어(directive)를 조합하여 캐시의 동작을 세밀하게 제어합니다.

`max-age=<seconds>`: 캐시된 응답이 "신선(fresh)"하다고 간주되는 최대 시간을 초 단위로 지정합니다. 이 시간이 지나면 응답은 "오래된(stale)" 상태가 됩니다. 버전이 지정된 정적 자산의 경우, max-age를 1년(31536000)과 같이 길게 설정하는 것이 일반적입니다.

no-cache: 이름과 달리 캐싱을 금지하는 것이 아닙니다. 리소스를 캐시에 저장할 수는 있지만, 사용하기 전에 반드시 원본 서버에 유효성을 재검증(revalidation)해야 함을 의미합니다. 이 과정에서 리소스가 변경되지 않았다면 서버는 304 Not Modified 응답을 보내 전체 다운로드를 피할 수 있습니다. HTML 문서와 같이 항상 최신 상태를 유지해야 하는 리소스에 적합합니다.

no-store: 가장 강력한 제한 지시어입니다. 브라우저나 중간 프록시 등 어떤 캐시에도 리소스를 저장해서는 안 됨을 명시합니다. 은행 잔고와 같은 매우 민감한 정보에 사용됩니다.

public vs. private: 응답이 공유 캐시(예: CDN)에 저장될 수 있는지, 아니면 최종 사용자의 브라우저 캐시(사설 캐시)에만 저장되어야 하는지를 제어합니다. private은 사용자별 개인화된 콘텐츠가 다른 사용자에게 노출되는 것을 방지하기 위해 필수적입니다.

must-revalidate: max-age와 함께 사용되어 캐시의 동작을 더 엄격하게 만듭니다. 리소스가 오래된 상태가 되면, 캐시는 반드시 서버에 재검증을 요청해야 하며, 네트워크 연결이 끊어진 경우에도 오래된 복사본을 제공해서는 안 됩니다.

서버가 Cache-Control 헤더를 명시적으로 제공하지 않을 경우, 브라우저는 자체적인 추론에 따라 리소스를 캐싱할 수 있습니다. 이를 휴리스틱 캐싱(heuristic caching)이라고 하며, Last-Modified 헤더의 시간을 기준으로 캐시 수명을 결정합니다. 하지만 이는 예측 불가능한 동작을 유발할 수 있으므로, 항상 명시적인 Cache-Control 헤더를 사용하는 것이 강력히 권장됩니다.


### 2.2. 유효성 검증 모델: ETag vs. Last-Modified

max-age가 만료되거나 no-cache가 설정된 리소스는 오래된(stale) 것으로 간주됩니다. 이때 브라우저는 전체 리소스를 다시 다운로드하는 대신, 자신이 가진 사본이 여전히 유효한지 서버에 물어볼 수 있습니다. 이 유효성 검증 과정은 대역폭을 크게 절약합니다.

Last-Modified / If-Modified-Since: 전통적인 유효성 검증 메커니즘으로, 리소스의 최종 수정 시간을 기반으로 합니다. 클라이언트는 If-Modified-Since 헤더에 자신이 가진 리소스의 Last-Modified 시간을 담아 서버에 요청합니다. 서버는 이 시간 이후 리소스가 변경되지 않았다면 304 Not Modified 응답을 보냅니다. 정적 파일에는 간단하지만, 분산 시스템에서는 서버 간 시간 동기화 문제로 인해 신뢰성이 떨어질 수 있습니다.

ETag / If-None-Match: 더 강력하고 현대적인 검증 메커니즘입니다. ETag(Entity Tag)는 서버가 리소스의 특정 버전에 대해 생성하는 고유한 식별자(주로 콘텐츠의 해시값)입니다. 클라이언트는 If-None-Match 헤더에 ETag 값을 담아 요청하며, 서버는 현재 리소스의 ETag와 비교하여 변경 여부를 판단합니다. ETag는 시간 기반 검증의 단점을 해결하며, Last-Modified와 함께 존재할 경우 우선순위를 가집니다.

304 Not Modified 응답: 서버가 이 상태 코드를 반환하면, 이는 "당신이 가진 버전이 최신이니 그대로 사용하라"는 의미입니다. 클라이언트는 전체 응답 본문을 다시 다운로드할 필요 없이 캐시된 버전을 신선한 것으로 갱신하고 즉시 사용할 수 있습니다.

HTTP 캐싱은 근본적으로 서버와 클라이언트 간의 신뢰 계약입니다. 서버는 max-age나 immutable과 같은 지시어를 통해 리소스의 안정성에 대한 약속을 합니다. 클라이언트는 이 약속을 신뢰하여 불필요한 네트워크 요청을 피합니다. 약속 기간이 만료되면, ETag나 Last-Modified를 통한 재검증 절차를 통해 신뢰를 갱신합니다. 이 "계약과 검증" 모델이 HTTP 캐싱의 핵심 루프이며, 이를 통해 웹은 효율적으로 작동합니다.


### 2.3. 전략적 정책: 정적 자산, API 응답, HTML 문서 캐싱

리소스의 유형과 변경 빈도에 따라 각기 다른 캐싱 전략을 적용해야 합니다.

정적 자산 (JS, CSS, 이미지): 가장 공격적인 장기 캐싱의 대상입니다. 파일 내용의 해시값을 파일명에 포함하는 캐시 버스팅(cache busting) 기법과 함께 Cache-Control: public, max-age=31536000, immutable 헤더를 사용하는 것이 최상의 전략입니다. 이렇게 하면 브라우저는 해당 자산을 1년 동안 캐시하며, 파일명이 변경되지 않는 한 절대 서버에 재검증을 요청하지 않습니다.

API 응답 (REST/GraphQL): GET 요청에 대한 응답을 캐싱하면 서버 부하를 크게 줄일 수 있습니다. 데이터의 변동성에 따라 정책이 달라집니다. 일반적으로 짧은 max-age와 ETag를 결합하여 클라이언트가 잠시 동안은 캐시된 데이터를 사용하되, 이후에는 재검증을 통해 신선도를 확인하도록 하는 전략이 유용합니다.

POST 요청은 기본적으로 캐시되지 않지만, Expires나 Cache-Control 헤더를 추가하면 캐시 가능하게 만들 수 있습니다.

HTML 문서: 캐싱하기 가장 까다로운 리소스입니다. HTML 문서는 다른 모든 자산(JS, CSS 등)에 대한 참조를 포함하므로, 사용자가 항상 최신 자산 링크를 받도록 보장해야 합니다. 따라서 Cache-Control: no-cache 또는 max-age=0, must-revalidate를 사용하여 매번 재검증을 강제하는 것이 일반적입니다. 문서 내용이 변경되지 않았다면 서버는 304 Not Modified로 빠르게 응답할 수 있습니다.


### 2.4. 고급 패턴: stale-while-revalidate와 immutable

최신 HTTP 캐싱 표준은 성능과 신선도 사이의 균형을 맞추기 위한 더 정교한 지시어를 제공합니다.

stale-while-revalidate: 이 지시어는 캐시가 오래된(stale) 응답을 사용자에게 즉시 제공하면서, 동시에 백그라운드에서 서버에 재검증 요청을 보내 캐시를 갱신하도록 허용합니다. 이는 캐시 히트의 속도와 최종적 일관성을 모두 제공하는 강력한 패턴입니다. 사용자는 기다림 없이 콘텐츠를 보고, 다음 방문 시에는 갱신된 콘텐츠를 받게 됩니다.

immutable: 이 지시어는 해당 리소스가 수명 동안 절대 변경되지 않음을 브라우저에 명시적으로 알립니다. 이는 버전이 지정된 정적 자산에 완벽하게 부합하며, 사용자가 페이지를 새로고침해도 불필요한 재검증 요청을 방지하여 성능을 더욱 향상시킵니다.


## 섹션 3: 브라우저 스토리지 API: 클라이언트의 영구 데이터

HTTP 캐싱이 네트워크 응답을 저장하는 데 중점을 둔다면, 브라우저 스토리지 API는 임의의 구조화된 애플리케이션 데이터를 클라이언트에 직접 저장하는 메커니즘을 제공합니다. 이 계층은 간단한 키-값 저장소부터 완전한 관계형 데이터베이스에 이르기까지 다양한 도구를 포함하며, 오프라인 애플리케이션의 핵심을 이룹니다.


### 3.1. 웹 스토리지 API: LocalStorage와 SessionStorage - 사용 사례와 안티패턴

웹 스토리지 API는 브라우저에 데이터를 저장하는 가장 간단한 방법을 제공합니다.

핵심 기능: 문자열 형태의 데이터를 키-값 쌍으로 저장하는 동기식(synchronous) API입니다.

핵심 차이점: LocalStorage에 저장된 데이터는 브라우저를 닫았다가 다시 열어도 유지되는 영속성을 가집니다. 반면 SessionStorage에 저장된 데이터는 세션(일반적으로 탭)이 종료되면 자동으로 삭제됩니다.

저장 용량: 일반적으로 오리진(origin)당 약 5-10MB로 제한되며, SessionStorage는 5MB 상한을 갖는 경우가 많습니다.

주요 단점: API가 동기식으로 작동하기 때문에, 대량의 데이터를 읽거나 쓸 때 메인 스레드를 차단(blocking)하여 UI 성능을 저하시킬 수 있습니다. 이는 웹 스토리지의 가장 큰 한계점입니다.

이상적인 사용 사례: 사용자 설정(예: 테마), 기능 플래그(feature flags), 또는 양식 데이터를 임시 저장하는 등 작고 중요하지 않은 데이터를 저장하는 데 적합합니다.

안티패턴: JWT와 같은 민감한 데이터를 저장하는 것은 XSS(Cross-Site Scripting) 공격에 취약하므로 피해야 합니다. 또한 복잡한 애플리케이션 데이터를 위한 주 데이터베이스로 사용하는 것도 성능 문제로 인해 권장되지 않습니다.


### 3.2. 클라이언트 측 데이터베이스: 복잡한 데이터를 위한 IndexedDB 마스터하기

IndexedDB는 웹 스토리지를 넘어 브라우저에 내장된 본격적인 데이터베이스 시스템입니다.

핵심 기능: 대량의 구조화된 데이터, 파일, Blob 등을 저장할 수 있는 저수준의 비동기식(asynchronous), 트랜잭션 기반의 NoSQL 객체 지향 데이터베이스입니다.

주요 특징:

대용량 저장: 웹 스토리지보다 훨씬 큰 용량을 제공하며, 브라우저에 따라 사용 가능한 디스크 공간의 일정 비율(예: 60-80%)까지 사용할 수 있습니다.

트랜잭션: 데이터 무결성을 보장하기 위해 모든 데이터 작업(읽기, 쓰기)은 트랜잭션 내에서 수행됩니다.

인덱스: 특정 속성을 기준으로 인덱스를 생성하여 데이터를 고성능으로 검색할 수 있습니다.

비동기 API: 모든 작업이 비동기적으로 이루어지므로 메인 스레드를 차단하지 않아 UI 반응성을 유지할 수 있습니다.

API 복잡성: 네이티브 API는 데이터베이스 열기, 버전 업그레이드(onupgradeneeded 이벤트 처리), 객체 저장소 생성, 트랜잭션 관리 등 이벤트 기반으로 작동하여 매우 복잡합니다. 따라서 idb나 Dexie.js와 같은 래퍼(wrapper) 라이브러리를 사용하는 것이 강력히 권장됩니다.

이상적인 사용 사례: 오프라인 우선(offline-first) 애플리케이션(PWA) 구축, 클라이언트 측에서 검색/필터링을 위한 대규모 데이터셋 캐싱, 서버 동기화 전 사용자 생성 콘텐츠 저장 등에 매우 유용합니다.


### 3.3. 관계형 데이터베이스의 힘: WASM SQLite와 OPFS(Origin Private File System)

WASM SQLite는 클라이언트 측 데이터 저장의 새로운 패러다임을 제시합니다.

기술 개요: 널리 사용되는 SQLite 데이터베이스 엔진 전체를 웹어셈블리(WebAssembly, WASM)로 컴파일하여 브라우저에서 직접 실행하는 기술입니다. 이는 공식적으로 폐기된 Web SQL의 대체 기술입니다.

OPFS를 통한 영속성: WASM은 자체적으로 영구 저장소에 접근할 수 없으므로, JavaScript VFS(가상 파일 시스템) 계층을 통해 데이터를 저장합니다. 가장 현대적이고 성능이 뛰어난 백엔드는 OPFS(Origin Private File System)입니다. OPFS는 웹 워커(Web Worker)에서 동기식 파일 접근 핸들(createSyncAccessHandle)을 사용하여 거의 네이티브에 가까운 파일 I/O 성능을 제공합니다.

성능 프로필: 일반적으로 Web SQL만큼 빠르거나 더 빠르며, 브라우저 API 추상화 계층의 오버헤드가 없어 복잡한 쿼리나 대규모 데이터셋에서 IndexedDB를 능가하는 성능을 보입니다. 벤치마크에 따르면 순수 인메모리

wa-sqlite보다는 느리지만, WAL(Write-Ahead Logging)을 사용하여 단일 행 CRUD 작업에서는 더 빠를 수 있습니다.

IndexedDB 대비 주요 이점:

조인(join), 복잡한 집계 쿼리 등 완전한 관계형 SQL을 지원합니다.

수많은 애플리케이션에서 검증된, 신뢰성 높은 데이터베이스 엔진입니다.

IndexedDB가 특정 크기 이상에서 성능이 급격히 저하되는 현상 없이 대규모 데이터셋을 더 안정적으로 처리할 수 있습니다.

이상적인 사용 사례: 복잡한 관계형 데이터 모델을 가진 애플리케이션, 데이터 집약적인 분석 도구, 강력한 쿼리 기능이 필요한 로컬 우선(local-first) 애플리케이션, 그리고 Notion과 같은 회사의 고성능 캐시 구현에 적합합니다.


### 3.4. 비교 분석: 성능, 쿼리 기능, 개발자 경험

세 가지 스토리지 메커니즘을 직접 비교하면 다음과 같은 결론을 도출할 수 있습니다.

성능: LocalStorage는 작은 데이터 쓰기에는 빠르지만 메인 스레드를 차단합니다.

IndexedDB는 비동기적이지만 단일 트랜잭션 내 대량 쓰기 시 느릴 수 있고 API 오버헤드가 존재합니다.

WASM SQLite와 OPFS 조합은 복잡한 작업과 대규모 데이터셋에서 최고의 성능을 제공합니다.

쿼리 기능: LocalStorage는 키 기반 조회만 가능합니다. IndexedDB는 키 범위 쿼리와 인덱스를 지원하지만 조인은 불가능합니다.

WASM SQLite는 SQL의 모든 기능을 제공합니다.

개발자 경험: LocalStorage는 매우 간단합니다. IndexedDB는 악명 높을 정도로 복잡합니다. WASM SQLite는 익숙한 SQL 기반 API를 제공하지만, 웹 워커와 영속성 백엔드에 대한 이해가 필요합니다.

WASM SQLite와 OPFS의 등장은 단순한 기술 개선을 넘어선 패러다임의 전환을 의미합니다. 이는 브라우저를 단순한 문서 뷰어가 아닌, 일급의 고성능 파일 시스템을 갖춘 유능한 컴퓨팅 플랫폼으로 취급하는 것입니다. 초기 웹의 클라이언트 스토리지는 쿠키와 LocalStorage 같은 원시적인 형태였습니다. 오프라인 앱의 필요성으로 IndexedDB가 등장했지만, 그 복잡한 NoSQL API는 개발자들에게 큰 학습 곡선을 요구했습니다. 웹어셈블리는

SQLite와 같은 네이티브 라이브러리를 브라우저로 가져왔고, OPFS는 이를 위한 고성능 영속성 계층을 제공함으로써 마지막 퍼즐 조각을 맞췄습니다. 이 조합은 클라이언트와 서버에서 동일한 데이터베이스 기술과 쿼리 언어(SQL)를 사용할 수 있게 하여, 이전에는 불가능했던 강력하고 데이터 집약적인 로컬 우선 애플리케이션의 시대를 열고 있습니다.


## 섹션 4: 프로그래밍 가능한 프록시: 서비스 워커와 Cache API

서비스 워커는 개발자에게 네트워크 요청과 캐싱에 대한 전례 없는 제어권을 부여하는 기술입니다. 이는 PWA와 오프라인 우선 아키텍처의 중추를 형성하며, 애플리케이션의 안정성과 성능을 한 단계 끌어올립니다.


### 4.1. 아키텍처와 생명주기: 네트워크 요청 가로채기

핵심 개념: 서비스 워커는 브라우저가 웹 페이지와 별개의 백그라운드 스레드에서 실행하는 JavaScript 파일로, 네트워크 프록시 역할을 합니다. DOM에 직접 접근할 수 없으며, 모든 작업은 비동기적으로 처리됩니다.

등록 및 생명주기: 서비스 워커는 register, install, activate의 명확한 생명주기를 가집니다. install 이벤트는 일반적으로 애플리케이션의 핵심 자산("앱 셸")을 미리 캐싱하는 데 사용됩니다. activate 이벤트는 이전 버전의 서비스 워커가 사용하던 오래된 캐시를 정리하는 데 사용됩니다.

요청 가로채기: 서비스 워커의 가장 강력한 기능은 fetch 이벤트입니다. 서비스 워커가 제어하는 페이지에서 발생하는 모든 네트워크 요청은 이 이벤트를 트리거하며, 개발자는 요청을 가로채 어떻게 응답할지 프로그래밍 방식으로 결정할 수 있습니다.


### 4.2. Cache API: 세분화된 프로그래밍 방식의 제어

기능: Cache API는 Request / Response 객체 쌍을 위한 영구 저장 메커니즘으로, 서비스 워커 내에서(그리고 메인 스레드에서도) 접근 가능합니다. 이는 브라우저의 표준 HTTP 캐시와는 별개이며, HTTP 캐싱 헤더를 따르지 않습니다.

API: caches.open(), cache.add(), cache.addAll(), cache.put(), caches.match()와 같은 메서드를 통해 캐시를 조작합니다. 개발자는 이를 통해 캐시 항목을 자유롭게 추가, 검색, 삭제할 수 있어 매우 유연한 캐싱 로직 구현이 가능합니다.


### 4.3. 오프라인 우선 캐싱 패턴

서비스 워커의 fetch 이벤트 핸들러 내에서 다양한 캐싱 전략을 구현할 수 있습니다.

Cache First (캐시 우선): 요청이 발생하면 먼저 Cache API를 확인합니다. 일치하는 응답이 있으면 네트워크 요청 없이 즉시 반환합니다. 캐시에 없는 경우에만 네트워크로 요청을 보냅니다. 정적 자산과 앱 셸에 이상적인 전략으로, 매우 빠른 로딩과 오프라인 지원을 보장합니다.

Network First (네트워크 우선): 먼저 네트워크로 리소스를 요청합니다. 요청이 성공하면 응답을 클라이언트에 전달하고 캐시를 업데이트합니다. 네트워크 요청이 실패하면(오프라인 상태 등) 캐시에 저장된 응답으로 대체(fallback)합니다. 신선도가 중요하지만 오프라인 지원도 필요한 동적 콘텐츠에 적합합니다.

Stale-While-Revalidate (백그라운드 갱신): 캐시에서 즉시 응답을 제공하여 사용자에게 빠른 경험을 제공하고(stale), 동시에 백그라운드에서 네트워크 요청을 보내 캐시를 최신 버전으로 갱신합니다(revalidate). 이는 사용자 경험과 데이터 신선도 사이의 훌륭한 균형을 제공합니다.

Cache Then Network (캐시 후 네트워크): 캐시된 응답을 페이지에 즉시 보여주고, 동시에 네트워크 요청도 보냅니다. 네트워크 요청이 완료되면 페이지의 데이터를 최신 정보로 업데이트합니다. 사용자에게 데이터를 빠르게 보여주면서도 최종적으로는 최신 데이터를 보장하는 데 유용합니다.

서비스 워커는 애플리케이션과 네트워크의 관계를 근본적으로 역전시킵니다. 기존 웹 애플리케이션이 네트워크 가용성에 종속적이었던 반면, 서비스 워커는 애플리케이션이 자체적인 안정성 모델을 정의할 수 있도록 합니다. 즉, 네트워크를 기능의 전제 조건이 아닌 데이터 동기화를 위한 선택적 향상 기능으로 취급하게 됩니다. fetch 이벤트를 가로챔으로써 애플리케이션은 더 이상 네트워크와 직접 통신하지 않고 서비스 워커와 통신합니다. 서비스 워커는 로컬

Cache를 첫 번째 진실의 원천(source of truth)으로 삼고, 네트워크는 여러 응답 소스 중 하나로 간주합니다. 이 아키텍처적 전환은 네트워크를 강력한 의존성에서 최종적 일관성(eventual consistency)을 위한 도구로 변모시키며, 진정한 오프라인 우선 PWA를 가능하게 합니다.


## 섹션 5: 애플리케이션 계층: 인메모리 서버 상태 관리

이 섹션에서는 가장 현대적인 캐싱 계층인 애플리케이션의 런타임 메모리 내에서 API로부터 가져온 데이터의 생명주기를 관리하는 기술을 다룹니다. 기존의 클라이언트 상태 관리 도구에서 벗어나, 서버 상태 관리에 특화된 라이브러리로의 패러다임 전환을 중점적으로 분석합니다.


### 5.1. 패러다임 전환: 클라이언트 상태와 서버 상태의 분리

현대 애플리케이션의 상태는 두 가지로 명확히 구분될 수 있습니다.

클라이언트 상태(Client State): UI 상태(예: 모달의 열림 여부), 양식 입력 값, 테마 설정 등 오직 클라이언트에만 존재하는 데이터입니다. Redux, Zustand, React Context와 같은 라이브러리가 이 상태를 효과적으로 관리합니다.

서버 상태(Server State): 원격 서버에 존재하는 데이터의 복사본입니다. 이 데이터는 비동기적으로 가져와야 하며, 클라이언트가 모르는 사이에 다른 사용자에 의해 변경될 수 있어 "오래된(stale)" 상태가 될 수 있습니다. 이 상태를 관리하는 것이 서버 상태 라이브러리의 핵심 과제입니다.

Redux와 같은 전통적인 클라이언트 상태 관리 도구를 서버 상태 관리에 사용하는 것은 여러 문제를 야기합니다. 비동기 데이터를 처리하기 위해 액션, 리듀서, 미들웨어(Thunk, Saga) 등 방대한 보일러플레이트 코드가 필요하며, 캐싱, 동기화, 재요청, 무효화 로직을 모두 수동으로 구현해야 합니다. Redux는 본질적으로 비동기 서버 데이터의 복잡한 생명주기를 관리하도록 설계되지 않았습니다.


### 5.2. stale-while-revalidate 라이브러리: Tanstack Query와 SWR

이 라이브러리들은 전역 상태 관리 도구가 아니라, 서버 상태를 위한 특화된 캐시입니다. 이름에서 알 수 있듯이,

stale-while-revalidate 캐싱 전략을 핵심 철학으로 삼고 있습니다.

Tanstack Query의 핵심 메커니즘 (대표 예시):

QueryClient와 QueryCache: 모든 쿼리 데이터의 중앙 저장소입니다. 데이터는 인메모리(RAM)에 저장되며, 페이지가 새로고침되면 사라지는 세션 기반입니다.

useQuery 훅: 데이터를 가져오고, 캐싱하며, 구독하는 주된 API입니다. 데이터를 식별하기 위해 고유한 queryKey가 필요합니다.

staleTime: 캐시된 데이터가 "신선하다(fresh)"고 간주되는 시간(밀리초)입니다. 이 시간 동안에는 백그라운드 재요청이 발생하지 않아 불필요한 네트워크 요청을 방지합니다.

gcTime (구 cacheTime): 비활성 상태의 쿼리 데이터가 가비지 컬렉션되기 전까지 캐시에 남아있는 시간입니다. 덕분에 사용자가 잠시 다른 페이지에 갔다가 돌아왔을 때 데이터를 빠르게 다시 보여줄 수 있습니다.

자동 재요청(Automatic Refetching): 창 포커스, 네트워크 재연결, 컴포넌트 마운트 시 지능적으로 데이터를 다시 가져와 서버와 데이터를 동기화합니다.


### 5.3. 미니멀리스트 상태 관리: Zustand를 이용한 비동기 데이터 캐싱

Zustand의 역할: Zustand는 주로 클라이언트 상태 관리를 위한 라이브러리지만, 단순함과 훅 기반 API 덕분에 간단한 비동기 데이터 캐싱에도 활용될 수 있습니다.

구현: 개발자는 스토어 내에서 비동기 액션을 만들어 데이터를 가져온 후 set() 함수로 상태를 업데이트할 수 있습니다. 이는 Tanstack Query에 비해 수동적인 접근 방식입니다.

비교: Zustand는 자동 재요청, staleTime 관리, 쿼리 무효화와 같은 정교한 기능이 부족합니다. 따라서 클라이언트 상태 관리에 사용하는 것이 최선이며, 데이터 가져오기 라이브러리와 함께 사용하는 것이 일반적입니다.


### 5.4. GraphQL 접근법: Relay와 Apollo Client의 정규화된 캐싱

GraphQL 캐싱의 과제: GraphQL 응답은 계층적 구조를 가지며 중복 데이터를 포함할 수 있습니다. 응답 전체를 그대로 캐싱하는 것은 비효율적이며 데이터 불일치를 유발합니다.

정규화된 캐싱(Normalized Caching): 이 문제의 해결책은 계층적 응답을 평탄화하여 클라이언트 메모리 내에 정규화된, 테이블과 유사한 구조로 저장하는 것입니다. 고유 ID를 가진 각 객체는 한 번만 저장되며, 이를 통해 데이터의 단일 진실 공급원(Single Source of Truth)을 만듭니다.

작동 방식 (Relay 예시):

Relay는 전역 데이터 ID로 키가 지정된 Record의 집합인 Store를 사용합니다.

쿼리 응답이 도착하면, Relay는 쿼리와 응답을 병렬로 순회하며 데이터를 정규화하고 Store를 업데이트합니다.

만약 뮤테이션(mutation)이 특정 객체(예: 사용자 이름 변경)를 업데이트하면, Store에 있는 해당 레코드가 업데이트됩니다. 이 레코드를 구독하는 모든 컴포넌트(프래그먼트를 통해)는 자동으로 새로운 데이터로 다시 렌더링되어 애플리케이션 전체에서 UI 일관성을 보장합니다.

핵심 이점: 이 접근법은 데이터 일관성 문제를 우아하게 해결합니다. 단일 데이터 조각에 대한 업데이트가 UI에 나타나는 모든 곳에 자동으로 반영되므로, REST 기반 캐싱으로는 해결하기 어려운 문제를 해결할 수 있습니다.

서버 상태 라이브러리의 등장은 프론트엔드 아키텍처에 "서버 상태 관리자"라는 새로운 추상화 계층이 공식화되었음을 의미합니다. 이 계층은 애플리케이션이 소유하지 않고 완전히 제어할 수도 없는 데이터를 모델링하기 때문에 "클라이언트 상태 관리자"와는 근본적으로 다릅니다. 초기 SPA에서는 모든 상태를 Redux와 같은 단일 전역 스토어에 저장했지만, 서버 데이터는 비동기적이고, 오래될 수 있으며, 재요청이 필요하다는 특성을 가집니다. Tanstack Query와 같은 라이브러리는 바로 이 문제를 해결하기 위해 탄생했으며, 가져오기, 캐싱, 동기화의 복잡성을 추상화합니다. 따라서 현대적인 아키텍처의 모범 사례는 API 데이터를 위해 전용 서버 상태 관리자를 사용하고, UI 상태를 위해 별도의 간단한 클라이언트 상태 관리자(예: Zustand)를 사용하는 것입니다. 이러한 관심사의 분리는 더 단순하고 유지보수하기 쉬우며 성능이 뛰어난 애플리케이션으로 이어집니다.


## 섹션 6: 통합 프레임워크: 종합 및 전략적 비교

이 섹션에서는 앞서 논의된 지식들을 종합하여, 다양한 캐싱 메커니즘을 직접적으로 비교 분석하고, 캐싱의 보편적이고 어려운 과제들을 해결하는 전략을 제시합니다.


### 6.1. 클라이언트 측 캐싱 메커니즘 비교 분석

아래 표는 이 보고서에서 논의된 주요 클라이언트 측 캐싱 기술들을 핵심 속성에 따라 비교하여, 아키텍트와 개발자가 특정 요구사항에 가장 적합한 도구를 선택하는 데 도움을 주기 위해 설계되었습니다. 이 표는 각 기술의 장단점과 이상적인 사용 시나리오를 한눈에 파악할 수 있는 강력한 의사결정 도구 역할을 합니다. 예를 들어, "대규모의 구조화된 오프라인 데이터"가 요구사항이라면 이 표는 즉시 IndexedDB나 WASM SQLite를 가리키는 반면, "자주 변경되는 API 데이터의 생명주기를 인메모리에서 관리"하는 것이 목표라면 Tanstack Query나 SWR이 적합함을 보여줍니다.

메커니즘 데이터 유형 영속성 저장 용량 API 유형 제어 세분성 성능 프로필 오프라인 기능 주요 사용 사례
HTTP 캐시 정적 자산, 응답 세션/디스크 (브라우저 관리) 브라우저 의존적, 큼 선언적 (헤더) 낮음 (리소스 수준) 매우 빠름 (디스크/메모리) 제한적 (신선할 경우) 버전 관리된 정적 자산(JS, CSS, 이미지) 캐싱
LocalStorage 문자열 (키-값) 영구적 (삭제 전까지) 약 5-10 MB 동기식 중간 (키 수준) 작은 데이터에 빠름, 메인 스레드 차단 가능 사용자 설정, 기능 플래그 저장
SessionStorage 문자열 (키-값) 세션 기반 약 5 MB 동기식 중간 (키 수준) 작은 데이터에 빠름, 메인 스레드 차단 가능 (세션 동안) 임시 양식 데이터, 탭 특정 상태 저장
IndexedDB 구조화된 객체, Blob 영구적 (삭제 전까지) 큼 (GB 단위, 디스크의 %) 비동기식 높음 (객체/인덱스 수준) LS보다 느린 쓰기, 인덱스 사용 시 빠른 쿼리 우수 복잡한 오프라인 앱, 대규모 데이터셋 (PWA)
WASM SQLite 관계형 데이터 영구적 (OPFS 통해) 큼 (GB 단위, 디스크의 %) 비동기식 (SQL) 매우 높음 (SQL 쿼리) 고성능, 특히 복잡한 쿼리에서 우수 로컬 우선 앱, 클라이언트 측 분석, 관계형 데이터
서비스 워커 캐시 Request/Response 쌍 영구적 (삭제 전까지) 큼 (GB 단위, 디스크의 %) 비동기식 매우 높음 (프로그래밍 방식) 매우 빠름 (캐시에서) 우수 (핵심 기술) 오프라인 우선, 앱 셸 캐싱, 커스텀 네트워크 로직
앱 상태 라이브러리 (예: Tanstack Query) 모든 JS 객체 인메모리 (세션 기반) RAM 의존적 선언적 (훅) 높음 (쿼리 키 수준) 극도로 빠름 (RAM) 없음 (기본적으로) 서버 상태 관리, 중복 API 호출 방지

Sheets로 내보내기


### 6.2. 두 가지 어려운 문제: 캐시 무효화와 이름 짓기 (캐시 버스팅)

컴퓨터 과학에서 가장 어려운 두 가지 문제는 캐시 무효화와 이름 짓기라는 말이 있습니다. 클라이언트 측 캐싱에서도 이 두 가지는 핵심적인 과제입니다.

캐시 무효화(Cache Invalidation): 캐시에 저장된 데이터가 원본 소스에서 변경되었을 때, 캐시된 데이터를 최신 상태로 갱신하거나 삭제하는 프로세스입니다.

전략:

Time-to-Live (TTL): 가장 간단한 전략으로, 데이터에 만료 시간을 설정합니다. HTTP의 max-age가 대표적인 예입니다. 데이터 신선도가 덜 중요할 때 유용하지만, 변경되지 않은 데이터가 불필요하게 제거되거나 만료 전까지 오래된 데이터가 제공될 수 있습니다.

이벤트 기반/수동 무효화: 가장 정확한 방법입니다. 데이터가 변경되는 시점(예: POST 또는 PUT 요청 성공 후)에 명시적으로 캐시를 무효화합니다. Tanstack Query의 queryClient.invalidateQueries가 대표적인 예이며, 서비스 워커에서도 메시지를 통해 구현할 수 있습니다.

Write-Through Caching: 데이터를 캐시와 데이터베이스에 동시에 쓰는 방식입니다. 일관성은 보장되지만 쓰기 작업에 지연 시간이 추가됩니다.

캐시 버스팅(Cache Busting): 주로 HTTP 캐시에 저장된 정적 자산을 위한 무효화 기법입니다. 파일 내용이 변경되었을 때 브라우저가 강제로 새 버전을 다운로드하도록 하는 것을 목표로 합니다.

기법:

해시 기반 파일명: 가장 강력하고 권장되는 방법입니다. 파일 내용의 해시값을 파일명에 포함시켜(main.a1b2c3d4.js), 내용이 조금이라도 변경되면 파일명이 바뀌게 됩니다. 이는 Webpack이나 Vite와 같은 빌드 도구에서 자동으로 처리됩니다.

쿼리 문자열 매개변수: 파일 URL 뒤에 버전이나 타임스탬프를 추가하는 방식입니다(style.css?v=2). 구현은 간단하지만 일부 프록시나 CDN이 쿼리 문자열을 무시하고 캐시된 버전을 제공할 수 있어 신뢰성이 떨어집니다.

파일 경로 버전 관리: 파일 경로에 버전을 포함시키는 방식입니다(/v2/style.css). 해시 기반 파일명과 유사한 신뢰성을 제공합니다.

캐시 버스팅과 캐시 무효화는 캐시된 데이터의 생명주기를 관리한다는 점에서 동일한 목표를 가지지만, 작동하는 계층과 대상 데이터가 다릅니다. 캐시 버스팅은 변경 불가능한(immutable) 정적 자산을 대상으로 하는 사전 예방적, 빌드 타임 전략입니다. 반면, 캐시 무효화는 변경 가능한(mutable) 동적 데이터를 대상으로 하는 사후 대응적, 런타임 전략입니다. 정적 CSS 파일은 빌드 시 내용이 고정되므로, 내용이 바뀔 때마다 파일명을 바꾸는 캐시 버스팅이 적합합니다. 반면, 사용자의 프로필 데이터는 런타임에 변경될 수 있으므로, URL은 그대로 두고 해당 URL과 연결된 캐시 데이터를 런타임에 무효화하는 전략이 필요합니다. 이 두 개념을 혼동하면(예: 버전 없는 정적 자산에 짧은 TTL을 적용) "오래된 CSS" 문제나 비효율적인 애플리케이션으로 이어지기 쉽습니다.


### 6.3. 보안 태세: 캐시 포이즈닝부터 저장된 데이터의 XSS까지

클라이언트 측 캐싱은 편리하지만, 여러 보안 취약점을 야기할 수 있습니다.

웹 캐시 포이즈닝(Web Cache Poisoning): 공격자가 캐시(특히 CDN과 같은 공유 캐시)를 속여 악의적인 응답을 저장하게 하고, 이 응답이 다른 사용자들에게 제공되도록 하는 공격입니다. 주로 캐시 키에 포함되지 않는 헤더(예: X-Forwarded-Host)를 악용하여 발생합니다.

저장된 데이터를 통한 XSS: 사용자 입력 데이터를 LocalStorage나 IndexedDB에 저장한 후, 적절한 정제(sanitization) 없이 DOM에 렌더링할 경우, 영구적인 XSS(Cross-Site Scripting) 공격으로 이어질 수 있습니다.

민감 정보 노출: 토큰이나 개인 정보와 같은 민감 데이터를 클라이언트 측에 저장하는 것은 위험합니다. 특히 LocalStorage는 영구적으로 저장되고 JavaScript로 접근 가능하여 취약합니다. 데이터를 저장하기 전에 암호화하는 것이 하나의 완화책이 될 수 있지만, 완벽한 해결책은 아닙니다.

보안 모범 사례:

가능한 한 민감 정보는 클라이언트에 저장하지 마십시오. 세션 토큰은 HttpOnly 속성이 설정된 보안 쿠키를 사용하십시오.

사용자 입력을 저장하거나 렌더링하기 전에 항상 유효성을 검사하고 정제하십시오.

사용자별 콘텐츠에는 Cache-Control: private을 사용하여 공유 캐시에 저장되는 것을 방지하십시오.

매우 민감한 정보에는 Cache-Control: no-store를 사용하십시오.


## 섹션 7: 아키텍처 청사진과 미래 전망

이 마지막 섹션에서는 지금까지 논의된 원칙들을 일반적인 웹 아키텍처에 적용하고, 기술 선택을 위한 의사결정 프레임워크를 제공하며, 클라이언트 측 캐싱의 미래를 조망합니다.


### 7.1. 고성능 단일 페이지 애플리케이션(SPA)을 위한 청사진

현대적인 SPA(예: React 기반)를 위한 종합적인 계층적 캐싱 아키텍처는 다음과 같이 구성될 수 있습니다.

앱 셸(App Shell): 서비스 워커를 사용하여 기본 index.html, 핵심 JS/CSS 번들, 폰트 등을 Cache First 전략으로 캐싱합니다. 이를 통해 즉각적인 로딩과 오프라인 기능을 활성화할 수 있습니다.

정적 자산: 모든 JS/CSS 청크, 이미지 등에 대해 해시 기반 파일명을 사용하고 Cache-Control: public, max-age=31536000, immutable 헤더를 적용하여 장기간 캐싱합니다.

API 데이터: Tanstack Query와 같은 라이브러리를 사용하여 모든 서버 상태를 관리합니다. 합리적인 staleTime과 gcTime 기본값을 설정하고, useMutation을 사용하여 데이터 변경 시 관련 쿼리를 자동으로 무효화합니다.

영구 상태: 페이지 새로고침 후에도 유지되어야 하거나 오프라인에서 사용 가능한 복잡한 데이터(예: 장문의 문서 초안)는 IndexedDB 또는 WASM SQLite에 저장합니다.

UI 상태: 일시적인 UI 상태(예: 모달 상태)는 Zustand나 React Context와 같은 간단한 클라이언트 상태 관리자를 사용합니다.


### 7.2. 최신 JAMstack 아키텍처를 위한 캐싱 전략

JAMstack 사이트는 사전 렌더링된 정적 파일을 CDN을 통해 제공하므로 본질적으로 캐시에 매우 친화적입니다.

CDN 캐싱: 가장 중요한 캐싱 계층입니다. CDN은 정적 자산을 immutable 헤더와 함께 공격적으로 캐싱하고, HTML 파일은 no-cache 또는 stale-while-revalidate 정책으로 캐싱하여 업데이트가 신속하게 전파되도록 구성해야 합니다.

즉각적인 캐시 무효화: Vercel이나 Netlify와 같은 JAMstack 호스팅 플랫폼의 핵심 기능은 새로운 배포 시 CDN 캐시를 즉시 퍼지(purge)하여 원자적 배포(atomic deploys)를 보장하는 것입니다.

동적 콘텐츠: JAMstack 사이트의 동적인 부분은 클라이언트 측 JavaScript를 통해 API에서 데이터를 가져와 처리합니다. 이 부분에서 Tanstack Query/SWR과 같은 애플리케이션 계층 캐싱이 성능 병목 현상을 방지하는 데 필수적입니다.


### 7.3. 의사결정 프레임워크: 프로젝트에 적합한 캐싱 도구 선택하기

아키텍트는 특정 데이터에 대한 캐싱 전략을 선택할 때 다음 질문들을 통해 적절한 도구를 결정할 수 있습니다.

데이터가 정적인가, 동적인가?

정적: 버전 관리(해시 파일명)가 되는가? -> 장기 HTTP 캐싱 (immutable)을 사용한다.

데이터가 동적인가?

서버 상태인가, 클라이언트 상태인가?

서버 상태: 앱 전체에서 일관성을 유지해야 하는가? -> 서버 상태 라이브러리(Tanstack Query 등)를 사용한다.

클라이언트 상태: UI 상태인가? -> 간단한 상태 관리자(Zustand, Context)를 사용한다.

애플리케이션이 오프라인에서 작동해야 하는가?

그렇다 -> 서비스 워커를 사용하여 앱 셸과 주요 데이터를 캐싱한다.

데이터가 세션을 넘어 영구적으로 저장되어야 하는가?

데이터가 크고 구조적인가? -> IndexedDB 또는 WASM SQLite를 사용한다.

데이터가 작고 비판적이지 않은가? -> LocalStorage를 사용한다.


### 7.4. 클라이언트 측 캐싱의 미래: 새로운 동향과 기술

클라이언트 측 캐싱은 계속해서 진화하고 있으며, 다음과 같은 기술들이 미래를 주도할 것으로 예상됩니다.

웹어셈블리(WebAssembly): WASM의 지속적인 발전은 SQLite를 넘어 더 많은 서버 측 기술을 브라우저로 가져올 것입니다. 이는 더 강력한 클라이언트 측 처리와 캐싱을 가능하게 할 것입니다.

JSPI (JavaScript Promise Integration): WASM과 비동기 API의 통합을 개선하기 위한 제안으로, Asyncify와 같은 해결책 없이도 WASM SQLite와 같은 기술을 더 간단하고 빠르게 만들 수 있습니다.

선언적 캐싱: React 서버 컴포넌트의 cache 함수나 Tanstack Query의 훅과 같이, 개발자로부터 명령형 캐싱 로직을 추상화하는 선언적 API가 계속해서 주류가 될 것입니다.

스마트 CDN과 엣지 컴퓨팅: CDN은 Cloudflare Workers와 같이 프로그래밍 가능한 엣지 컴퓨팅 플랫폼으로 진화하고 있습니다. 이는 클라이언트 측과 서버 측 캐싱의 경계를 모호하게 만들며, 동적 로직을 사용자에게 더 가까운 곳에서 실행하여 성능을 극대화할 것입니다.

현대 캐싱 아키텍처의 궁극적인 목표는 "성능의 환상"을 만드는 것입니다. 다양한 캐싱 메커니즘을 지능적으로 계층화함으로써, 애플리케이션은 네트워크 상태와 무관하게 사용자에게 즉각적이고 항상 사용 가능한 것처럼 느껴지게 할 수 있습니다. 사용자가 처음 SPA를 방문하면 서비스 워커가 앱 셸을 캐시하고, 재방문 시에는 즉시 앱 셸을 제공하여 로딩 시간을 거의 0에 가깝게 만듭니다. 앱이 데이터를 필요로 할 때 Tanstack Query는 메모리에서 오래된 데이터를 즉시 렌더링하면서 백그라운드에서 최신 데이터를 가져옵니다. 사용자가 오프라인 상태가 되어도 서비스 워커와 인메모리 캐시 덕분에 앱은 계속 작동합니다. 이 모든 것은 개별 자산을 캐싱하는 것을 넘어, 사용자 경험을 최우선으로 하여 애플리케이션의 상태를 조율하는 것입니다. 네트워크는 느리고 신뢰할 수 없는 의존성으로 취급되며, 가능할 때마다 사용자로부터 그 존재를 숨기는 것이 현대 클라이언트 측 아키텍처의 정수입니다.

