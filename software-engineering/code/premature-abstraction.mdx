---
title: 섣부른 추상화
---

# 성급한 추상화의 함정과 해결책

소프트웨어 개발에서 "성급한 추상화는 모든 악의 근원"이라고 불린다. 이는 도널드 크누스의 유명한 말 "성급한 최적화는 모든 악의 근원"을 패러디한 것으로, 추상화의 타이밍이 얼마나 중요한지를 보여준다. 특히 TypeScript와 Next.js 환경에서 개발하는 우리들은 강력한 타입 시스템과 컴포넌트 기반 아키텍처 덕분에 추상화에 대한 유혹을 더 자주 받게 된다. 하지만 **잘못된 추상화는 중복 코드보다 훨씬 비싸다** 는 사실을 명심해야 한다.


## 성급한 추상화란 무엇인가?

성급한 추상화(premature abstraction)는 실제 요구사항을 충분히 이해하기 전에 추상적인 솔루션을 도입하는 것을 의미한다. 이는 **예상되는 미래 요구사항** 에 기반해 추상화를 만들거나, **충분한 구체적인 예시 없이** 일반화된 솔루션을 만드는 것을 포함한다.


### 핵심 특징들

**예측 기반 설계**: 현재 요구사항보다는 가정된 미래 요구사항에 기반해 추상화를 만든다.
**불충분한 증거**: 여러 구체적인 사용 사례 없이 추상화를 시도한다.
**복잡성 증가**: 즉각적인 가치 제공 없이 간접성의 계층을 추가한다.
**잘못된 추상화 위험**: 실제 요구사항이 나타났을 때 맞지 않는 추상화를 만들 위험이 있다.


## 전문가들의 통찰


### Martin Fowler의 "Rule of Three"

Martin Fowler는 Don Roberts로부터 받은 조언을 이렇게 전했다:

> "어떤 일을 처음 할 때는 그냥 하면 된다. 비슷한 일을 두 번째 할 때는 중복에 움찔하겠지만, 그래도 중복해서 한다. 세 번째로 비슷한 일을 할 때, 그때 리팩토링을 한다."

**왜 세 번을 기다려야 할까?** 성급한 리팩토링은 잘못된 추상화를 선택할 위험이 있고, 새로운 요구사항이 등장했을 때 결국 다시 리팩토링해야 할 더 나쁜 코드가 될 수 있기 때문이다.


### Kent Beck의 학습 곡선

Kent Beck은 개발자의 성장 과정을 이렇게 설명했다:

> "먼저 추상화의 가치를 배우고, 그 다음 추상화의 비용을 배우고, 그러면 엔지니어링할 준비가 된다."

이는 대부분의 개발자가 거치는 여정을 보여준다:

1. **가치 학습**: 추상화가 어떻게 중복을 줄이고 코드 구조를 개선하는지 이해
2. **비용 학습**: 추상화가 복잡성을 증가시키고 코드 이해를 어렵게 만들 수 있음을 인식
3. **엔지니어링 준비**: 언제, 어떻게 추상화를 적절히 적용할지 아는 단계


### Sandi Metz의 핵심 원칙

Rails 커뮤니티의 영향력 있는 인물 Sandi Metz는 이렇게 말했다:

> "중복은 잘못된 추상화보다 훨씬 저렴하다."

그녀는 잘못된 추상화의 전형적인 패턴을 설명했다:

1. 개발자 A가 중복을 보고 새로운 추상화를 추출
2. 시간이 지나면서 기존 추상화에 "거의 완벽하게" 맞는 새로운 요구사항이 등장
3. 개발자 B가 기존 추상화를 유지하려고 하지만 매개변수와 조건부 로직을 추가
4. 이 과정이 반복되어 코드가 이해할 수 없게 됨


### Dan Abramov의 "Clean Code 이별하기"

React 핵심 개발자 Dan Abramov는 영향력 있는 블로그 포스트에서 이렇게 경고했다:

> "'깨끗한 코드'에 집착하고 중복을 제거하는 것은 많은 개발자들이 거치는 단계다. 코드에 자신이 없을 때, 측정 가능한 무언가에 자존심과 전문적 자부심을 걸고 싶어한다."

그의 핵심 메시지는 **"깨끗한 코드가 당신을 안내하게 하라. 그러고 나서 놓아버려라"**였다.


### Kent C. Dodds의 AHA 프로그래밍

Kent C. Dodds는 DRY(Don't Repeat Yourself)와 WET(Write Everything Twice) 접근법의 대안으로 AHA(Avoid Hasty Abstractions) 원칙을 개발했다:

> "잘못된 추상화보다는 중복을 선호하라. 변경을 위해 먼저 최적화하라."

그의 실용적인 조언은 이렇다:

> "중복 코드의 사용 사례를 이해할 때까지 코드 중복을 받아들인다. 그 코드가 여러 곳에서 실행된 후에야 공통점들이 추상화를 위해 소리치게 될 것이고, 그때 올바른 추상화를 제공할 마음가짐이 될 것이다."


## TypeScript와 Next.js 환경에서의 구체적인 예시


### 1. 과도한 React 컴포넌트 추상화

**잘못된 예시: 만능 Input 컴포넌트**

```typescript
// 나쁜 예: 과도하게 추상화된 Input 컴포넌트
<Input 
  label="Full Name" 
  name="username" 
  id="username"
  tooltip={true}
  validation={true}
  async={true}
  debounce={300}
  transform="uppercase"
  theme="dark"
  size="large"
  // ... 15개 이상의 props
/>
```

**문제점들**:

- 컴포넌트가 15개 이상의 props를 가진 "공포 영화"가 됨
- 새로운 요구사항이 생길 때마다 추상화가 깨짐
- 복잡한 조건부 로직으로 인해 해독 불가능한 내부 코드
- 테스트와 유지보수가 어려움

**더 나은 해결책: 원자적 컴포넌트**

```typescript
// 좋은 예: 원자적이고 조합 가능한 컴포넌트
<Field name="username">
  <Label>Full Name</Label>
  <TextInput />
  <FieldMessage />
</Field>
```


### 2. TypeScript 타입 추상화의 함정

**잘못된 예시: 성급한 제네릭 Repository 패턴**

```typescript
// 나쁜 예: 과도하게 추상화된 제네릭 repository
interface GenericRepository<T, K> {
  findAll(): Promise<T[]>;
  findById(id: K): Promise<T>;
  create(entity: T): Promise<T>;
  update(id: K, entity: Partial<T>): Promise<T>;
  delete(id: K): Promise<void>;
  // ... 많은 제네릭 메서드들
}

class UserRepository implements GenericRepository<User, string> {
  // 이 특정 사용 사례에 맞지 않는 메서드들을 
  // 강제로 구현해야 함
}
```

**문제점들**:

- 사용하지 않는 메서드들의 불필요한 구현 강요
- 도메인 특화 작업을 고려하지 않음
- 인위적인 제약 조건 생성
- 패턴이 나타나기 전의 성급한 추상화

**더 나은 접근법: 도메인 특화 인터페이스**

```typescript
// 좋은 예: 도메인 특화 인터페이스
interface UserService {
  getUsers(): Promise<User[]>;
  getUserById(id: string): Promise<User>;
  createUser(userData: CreateUserData): Promise<User>;
  updateUserProfile(id: string, updates: UserProfileUpdate): Promise<User>;
  // 도메인 특화 메서드들:
  activateUser(id: string): Promise<void>;
  getUsersByRole(role: Role): Promise<User[]>;
}
```


### 3. Next.js 아키텍처의 과도한 엔지니어링

**잘못된 예시: 과도하게 설계된 폴더 구조**

```
// 나쁜 예: 성급한 마이크로서비스 형태의 구조
src/
├── components/
│   ├── atoms/
│   ├── molecules/
│   ├── organisms/
│   ├── templates/
│   └── pages/
├── services/
│   ├── api/
│   ├── business/
│   └── domain/
├── utils/
├── hooks/
├── contexts/
├── types/
└── constants/
```

**문제점들**:

- 간단한 애플리케이션에 대한 과도한 엔지니어링
- 불필요한 복잡성 추가
- 개발 속도 저하
- 새로운 개발자에게 탐색하기 어려움

**더 나은 접근법: 간단하게 시작하기**

```
// 좋은 예: 간단하고 확장 가능한 구조
src/
├── components/
├── pages/
├── api/
├── lib/
└── types/
```


### 4. 상태 관리 추상화의 함정

**잘못된 예시: 과도하게 추상화된 Redux 패턴**

```typescript
// 나쁜 예: 과도하게 추상화된 Redux slice
const createGenericSlice = <T>(name: string, initialState: T) => ({
  name,
  initialState,
  reducers: {
    setLoading: (state: any, action: any) => {
      state.loading = action.payload;
    },
    setError: (state: any, action: any) => {
      state.error = action.payload;
    },
    setData: (state: any, action: any) => {
      state.data = action.payload;
    },
    // ... 많은 제네릭 reducer들
  }
});
```

**문제점들**:

- 타입 안전성 상실
- 도메인 특화 로직 처리 불가
- 불필요한 추상화 레이어 생성
- 특정 사용 사례에 대한 확장 어려움

**더 나은 접근법: 특화된 슬라이스**

```typescript
// 좋은 예: 도메인 특화 slice
const userSlice = createSlice({
  name: 'user',
  initialState: {
    users: [] as User[],
    loading: false,
    error: null as string | null,
    selectedUserId: null as string | null,
  },
  reducers: {
    fetchUsersStart: (state) => {
      state.loading = true;
      state.error = null;
    },
    fetchUsersSuccess: (state, action) => {
      state.users = action.payload;
      state.loading = false;
    },
    selectUser: (state, action) => {
      state.selectedUserId = action.payload;
    },
    // 도메인 특화 reducer들
  }
});
```


## 성급한 추상화가 야기하는 문제들


### 코드 복잡성 급증

성급한 추상화는 **인지 부하를 증가**시킨다. 개발자가 추상화의 목적을 이해하기 위한 충분한 맥락을 갖기 전에 불필요한 복잡성을 도입하기 때문이다.


### 유지보수성 저하

잘못된 추상화는 시간이 지남에 따라 더 많은 조건부 로직과 매개변수를 축적한다. 이는 **라자냐 코드** 문제를 일으킨다 - 너무 많은 레이어로 인해 무엇이 일어나고 있는지 알 수 없게 된다.


### 성능 문제

- **번들 크기**: 과도하게 추상화된 코드는 사용하지 않는 기능을 포함하는 경우가 많다
- **런타임 성능**: 복잡한 추상화는 렌더링 속도를 저하시킬 수 있다
- **메모리 사용량**: 불필요한 추상화는 더 많은 메모리를 소비한다
- **개발 성능**: 복잡한 디버깅으로 인한 개발 속도 저하


## 관련 소프트웨어 개발 원칙들


### YAGNI (You Aren't Gonna Need It) 원칙

YAGNI는 Extreme Programming(XP)의 Ron Jeffries가 만든 원칙이다. Martin Fowler는 YAGNI와 관련된 세 가지 비용을 식별했다:

**구축 비용**: 분석, 프로그래밍, 테스팅에 소요되는 노력
**지연 비용**: 다른 기능을 구축할 기회를 놓치는 것
**운반 비용**: 다른 기능을 구현하기 어렵게 만드는 지속적인 복잡성

Microsoft의 연구에 따르면, 신중하게 분석된 기능이라도 실제로 의도된 지표를 개선하는 것은 1/3에 불과하다고 한다.


### Rule of Three의 역사적 맥락

Rule of Three는 Roberts와 Johnson의 "Evolving Frameworks"(1996) 연구에서 나온 것으로, 공통 추상화를 시도하기 전에 세 개의 애플리케이션을 구축할 것을 권장했다.

**근거**: "잘못된 추상화를 리팩토링하는 것보다 중복된 코드에서 좋은 추상화를 만드는 것이 더 쉽다."


### KISS 원칙 (Keep It Simple, Stupid)

1960년대 Lockheed의 Skunk Works에서 Kelly Johnson이 만든 이 원칙은 설계와 개발에서 단순함을 핵심 목표로 삼아야 한다는 것이다. KISS는 불필요한 추상화를 포함한 불필요한 복잡성에 직접적으로 반대한다.


### DRY 원칙의 미묘한 차이

Andy Hunt와 Dave Thomas가 "The Pragmatic Programmer"(1999)에서 공식화한 DRY 원칙은 **"모든 지식은 시스템 내에서 단일하고 명확하며 권위 있는 표현을 가져야 한다"**고 말한다.

중요한 통찰은 **"진정한 중복"(같은 개념)과 "우연한 중복"(같은 코드, 다른 개념)을 구분**하는 것이다.


## 실제 사례 연구들


### Airbnb의 대규모 리팩토링 성공 사례

Airbnb는 2024년에 3,500개의 React 테스트 파일을 Enzyme에서 React Testing Library로 성공적으로 마이그레이션했다. 원래 1.5년으로 추정되었던 프로젝트를 AI 지원 리팩토링을 통해 6주 만에 완료했다.

**핵심 교훈**: 때로는 점진적 개선보다 완전한 교체가 올바른 접근법이다.


### Netflix의 추상화 단순화

Netflix는 복잡한 반응형 프로그래밍 추상화를 제거하고 가상 스레드를 도입하여 동시성 모델을 단순화했다. 수년간의 복잡한 반응형 패턴 이후 단순화된 접근법을 채택했다.

**핵심 통찰**: 때로는 올바른 추상화가 추상화를 하지 않는 것이다.


### Shopify의 모듈러 모놀리스 여정

Shopify는 대규모 Rails 모놀리스를 모듈러 컴포넌트로 리팩토링하면서 성급한 마이크로서비스 추출을 피했다. 그들은 대규모 리팩토링의 "사람 문제" 측면을 문서화했다.

**핵심 교훈**: 아키텍처 변경에는 기술적 변경뿐만 아니라 조직적 변경도 필요하다.


### 성과 측정 가능한 영향

- **성능 개선**: Shopify의 Admin은 과도하게 추상화된 컴포넌트를 리팩토링한 후 30% 성능 향상
- **개발 속도**: 잘못된 추상화를 제거한 후 회사들이 2-3배 빠른 기능 개발 보고
- **자동화 성공률**: Airbnb의 테스트 마이그레이션에서 적절한 도구를 사용하여 75% 자동화 성공률 달성


## 성급한 추상화를 피하는 방법과 리팩토링 전략


### 예방 전략

**Rule of Three 따르기**: 세 개의 유사한 인스턴스가 있을 때까지 추상화를 미룬다.
**단계별 리팩토링**: 패턴으로 리팩토링하되, 패턴으로 시작하지 않는다.
**추상화 단순하게 유지**: 추상화가 복잡성을 증가시키지 않고 줄이도록 한다.
**논리적 근거 문서화**: 추상화가 만들어진 이유를 설명한다.


### "인라인과 전문화" 전략

잘못된 추상화를 다룰 때:

1. **추상화 인라인**: 추상화된 코드를 각 호출자에게 다시 복사
2. **사용하지 않는 코드 제거**: 각 특정 사용 사례에 필요하지 않은 부분을 삭제
3. **패턴 식별**: 진정한 공통 패턴을 찾는다
4. **신중하게 재추상화**: 새롭고 집중된 추상화를 만든다


### 조합 우선 전략

복잡한 상속 계층보다 조합 패턴을 선호한다:

```typescript
// 좋은 예: 조합
const UserProfile = ({ user }) => (
  <div>
    <Avatar user={user} />
    <UserInfo user={user} />
    <UserActions user={user} />
  </div>
);

// 복잡한 상속보다
class BaseProfile extends Component {
  // 복잡한 상속 계층
}
```


## 아키텍처 패턴들의 양날의 검


### Repository 패턴의 함정

Repository 패턴은 데이터 액세스 로직을 비즈니스 로직에서 추상화하는 목적으로 사용되지만, 종종 **제네릭 Repository 안티패턴**으로 이어진다.

**문제점**: 모든 가능한 데이터 시나리오를 처리하려는 과도하게 제네릭한 repository 생성
**해결책**: 필요할 때만 특정 데이터 액세스 클래스 구현


### Factory 패턴의 오남용

Factory 패턴은 객체 생성을 캡슐화하지만, **"FactoryFactory"** 같은 악명 높은 안티패턴으로 이어질 수 있다.

**언제 유익한가**: 같은 인터페이스의 여러 구현이 런타임에 선택되어야 할 때
**더 간단한 대안**: 간단한 객체의 경우 직접 인스턴스화, 의존성의 경우 생성자 주입


### Observer 패턴의 복잡성

Observer 패턴은 상태 변경에 대한 알림을 위해 일대다 의존성을 정의하지만, **성급한 이벤트 시스템**으로 이어질 수 있다.

**문제점**: 간단한 직접 통신을 위한 이벤트 시스템 생성, 디버깅 복잡성, 불필요한 분리
**언제 유익한가**: 진정한 일대다 알림 시나리오, 모델 변경에 기반한 UI 컴포넌트 업데이트


## 올바른 추상화 결정을 위한 지침


### 세 가지 규칙 테스트

1. **지금 당장 여러 구현이 있는가?**
2. **곧 다른 구현이 필요할 것이 확실한가?**
3. **추상화가 현재 코드를 이해하기 쉽게 만드는가?**

이 중 적어도 두 개에 "예"라고 답할 수 없다면, 추상화가 성급할 수 있다.


### 추상화 고려 시 질문들

- 이 추상화가 오늘 실제 문제를 해결하는가?
- 이 추상화가 여러 호출자에 의해 사용될 것인가?
- 이 추상화가 코드를 이해하기 쉽게 만드는가?
- 이 유연성이 필요한 이유의 구체적인 예시가 있는가?


## 팀 차원의 모범 사례


### 개발 문화 조성

**코드 리뷰 집중**: 리뷰 과정에서 추상화 필요성에 집중
**아키텍처 리뷰**: 추상화 수준의 정기적인 평가
**리팩토링 문화**: 성급한 복잡성보다 단순화 장려
**패턴 교육**: 패턴을 언제 사용할지뿐만 아니라 언제 사용하지 말지도 교육


### 조직적 요인

**시니어 개발자 모델링**: 시니어 개발자가 좋은 추상화 관행을 모델링
**실수 인정 안전성**: 추상화 실수를 인정할 수 있는 심리적 안전성 조성
**개발자 교육 투자**: 추상화 트레이드오프에 대한 개발자 교육
**비즈니스 목표 연계**: 리팩토링 노력을 비즈니스 목표와 연계


## 결론

성급한 추상화는 단순한 기술적 문제가 아니라 전 세계 소프트웨어 조직에 영향을 미치는 시스템적 문제다. 가장 성공적인 회사들은 좋은 추상화의 이점을 활용하면서도 성급한 추상화를 적극적으로 방지하는 관행과 문화를 개발했다.

핵심 통찰은 **추상화 결정이 이론적 미래 요구사항이 아닌 실제 사용 패턴과 비즈니스 요구사항에 의해 주도되어야 한다**는 것이다. 연구 결과는 **"잘못된 추상화보다 중복이 훨씬 저렴하다"**는 원칙을 강력히 뒷받침하며, 잘못된 추상화를 다룰 때 앞으로 나아가는 가장 빠른 방법이 종종 뒤로 가는 것(신중한 인라인화와 실제 요구사항의 재평가)임을 보여준다.

TypeScript와 Next.js로 개발하는 우리에게는 **Rule of Three를 따르고, YAGNI 원칙을 지키며, 중복을 두려워하지 않는 것**이 더 maintainable하고 이해하기 쉬운 코드를 만드는 길이다. 기억하자: 완벽한 추상화를 만들려고 하지 말고, 현재 문제를 해결하는 간단한 솔루션을 만들어라. 패턴이 명확해지면 자연스럽게 리팩토링할 수 있을 것이다.
