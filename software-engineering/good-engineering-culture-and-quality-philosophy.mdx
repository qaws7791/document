---
title: Good Engineering Culture and Quality Philosophy
description: 이 글은 Google Testing Blog에서 다루는 핵심 철학을 공부하며 정리한 내용입니다.
---


## 1.1. 테스트는 왜 필요한가?


### 1.1.1. 테스트의 경제학: 비용 대비 효과 분석

소프트웨어 엔지니어링에서 테스트는 공짜가 아닙니다. 모든 테스트에는 명확한 '비용'과 그에 상응하는 '혜택(Benefit)'이 존재합니다. 구글의 엔지니어링 문화에서 테스트는 맹목적으로 작성해야 하는 의무 사항이 아니라, 철저한 투자 대비 수익(ROI) 분석의 대상입니다.

테스트의 비용은 크게 세 가지로 나뉩니다. 첫째, 테스트를 작성하는 데 드는 초기 비용(생성 비용)입니다. 둘째, 코드가 변경될 때마다 테스트를 수정하고 관리해야 하는 유지보수 비용입니다. 셋째, 테스트를 실행하는 데 소요되는 컴퓨팅 자원과 시간, 즉 실행 비용입니다. 여기에 더해 테스트가 실패했을 때 이를 분석하는 인지적 비용까지 포함해야 합니다. 반면, 테스트의 혜택은 버그가 프로덕션 환경에 배포되는 것을 막아주는 '위험 회피'와, 리팩토링 시 기존 기능이 유지됨을 보장하는 '개발 속도 향상'입니다.

경제적인 테스트 전략의 핵심은 '가치 있는 테스트'에 집중하는 것입니다. 단순히 코드 커버리지(Coverage) 수치를 높이기 위해 작성된 테스트나, 내부 구현 세부 사항(Implementation Details)에 지나치게 의존하여 변경 시마다 깨지는 테스트는 비용만 높고 혜택은 낮은 '부채'가 됩니다. 반면, 비즈니스 로직의 핵심 경로를 검증하고, 자주 변경되지 않는 공개 인터페이스(Public API)를 테스트하는 것은 높은 ROI를 보장합니다. 따라서 테스트를 작성할 때는 "이 테스트가 실패했을 때 나에게 유의미한 정보를 주는가?"를 끊임없이 자문해야 합니다.


#### [문제 상황: 낮은 가치의 테스트로 인한 비용 낭비]

웹 프론트엔드 개발에서 흔히 발생하는 실수는 컴포넌트의 단순한 상태 변화나 이미 검증된 라이브러리의 기능을 중복해서 테스트하는 것입니다. 아래 코드는 단순히 데이터가 전달되는지 확인하거나, 프레임워크가 보장하는 기본 기능을 테스트하여 유지보수 비용만 높이는 사례입니다.

```typescript
// Bad Case: 비용 대비 효과가 낮은 테스트

// UserProfile 컴포넌트 (구현부)
interface UserProfileProps {
  name: string;
  age: number;
}

const UserProfile = ({ name, age }: UserProfileProps) => {
  return (
    <div>
      <span id="name-display">{name}</span>
      <span id="age-display">{age}</span>
    </div>
  );
};

// 테스트 코드 (가치가 낮은 테스트)
describe('UserProfile', () => {
  it('should set the name and age correctly', () => {
    // 단순히 Props가 전달되어 렌더링되는지는 리액트와 브라우저가 보장하는 영역에 가깝다.
    // 단순 UI 렌더링 테스트는 비즈니스 로직이 없으므로 버그 검출 효과가 미미하다.
    const props = { name: 'Alice', age: 30 };
    const wrapper = render(<UserProfile {...props} />);
    
    expect(wrapper.find('#name-display').text()).toBe('Alice');
    expect(wrapper.find('#age-display').text()).toBe('30');
  });
  
  it('should create an instance', () => {
     const wrapper = render(<UserProfile name="Bob" age={25} />);
     expect(wrapper).toBeTruthy();
  });
});
```

위 테스트는 `name`과 `age`가 화면에 나온다는 단순 사실만 확인합니다. 만약 디자인 요구사항이 변경되어 HTML 구조가 바뀌면(예: `span`이 `div`로 변경되거나 ID가 변경됨), 비즈니스 로직은 그대로임에도 테스트가 실패하여 불필요한 수정 비용이 발생합니다.


#### [해결 과정: 고가치 테스트로 전환]

비용 대비 효과를 높이기 위해, 단순 렌더링보다는 **사용자 상호작용에 따른 상태 변화** 나 **데이터 가공 로직** 과 같은 '동작(Behavior)'을 검증하는 테스트로 전환해야 합니다.

```typescript
// Good Case: 비즈니스 로직과 동작 중심의 고가치 테스트

// 사용자의 나이에 따라 등급을 계산하여 표시하는 로직이 추가된 컴포넌트
const UserProfileEnhanced = ({ name, age }: UserProfileProps) => {
  const isSenior = age >= 65;
  const displayColor = isSenior ? 'gold' : 'black';

  return (
    <div style={{ color: displayColor }} role="status">
      {name} ({isSenior ? 'Senior Member' : 'Regular Member'})
    </div>
  );
};

// 테스트 코드 (동작 및 비즈니스 로직 검증)
describe('UserProfileEnhanced', () => {
  it('should classify user as Senior Member if age is 65 or older', () => {
    // 경계값 분석을 통해 버그가 발생하기 쉬운 지점을 공략하여 테스트 가치를 높임
    const { getByRole } = render(<UserProfileEnhanced name="Charlie" age={65} />);
    
    // 구현 세부 사항(ID, 태그)보다는 사용자 관점의 텍스트나 역할을 확인
    expect(getByRole('status')).toHaveTextContent('Senior Member');
  });

  it('should classify user as Regular Member if age is under 65', () => {
    const { getByRole } = render(<UserProfileEnhanced name="Dave" age={64} />);
    
    expect(getByRole('status')).toHaveTextContent('Regular Member');
  });
});
```

이렇게 변경된 테스트는 `65`세라는 경계값 로직이 올바르게 작동하는지 검증하므로 버그를 예방하는 가치가 높습니다. 또한 `role` 기반의 쿼리를 사용하여 HTML 구조가 변경되더라도 테스트가 쉽게 깨지지 않으므로 유지보수 비용이 낮아집니다.


### 1.1.2. 엔트로피의 역병: 소프트웨어 무질서를 막는 방어선

물리학의 열역학 제2법칙과 마찬가지로, 소프트웨어 시스템 또한 시간이 지날수록 무질서도(엔트로피)가 증가하는 경향이 있습니다. 새로운 기능이 추가되고, 버그 수정이 반복되며, 코드가 복잡해짐에 따라 시스템은 점차 이해하기 어렵고 수정하기 위험한 상태로 변해갑니다. 구글 엔지니어링 팀은 이를 '엔트로피의 역병(The Plague of Entropy)'이라고 부릅니다.

테스트는 이 엔트로피의 증가를 억제하는 가장 강력한 방어선입니다. 개발자가 코드를 작성할 때는 엔트로피가 낮지만, 버그가 발생하고 이를 수정하기 위해 계획되지 않은 코드가 덕지덕지 붙는 순간 엔트로피는 급격히 증가합니다. 버그는 개발자의 주의를 분산시키고, 새로운 기능을 개발하는 대신 과거의 코드를 뒤적거리게 만듭니다. 이는 프로젝트의 불확실성을 높이고 속도를 저하시킵니다.

자동화된 테스트 스위트(Test Suite)는 코드가 변경될 때마다 기존 기능이 의도대로 동작하는지 즉시 확인함으로써 무질서가 확산되는 것을 막습니다. 이는 일종의 '래칫(Ratchet)' 역할을 하여, 코드 품질이 일정 수준 이하로 떨어지지 않도록 고정해줍니다. 엔트로피를 관리하지 못하면, 결국 시스템은 유지보수가 불가능한 상태인 '기술적 파산'에 이르게 됩니다.


#### [문제 상황: 보호 장치 없는 코드 확장]

웹 애플리케이션에서 공통 유틸리티 함수를 수정해야 하는 상황을 가정해 봅시다. 이 함수는 여러 페이지에서 사용되고 있지만, 테스트 코드가 전혀 없습니다.

```typescript
// utils/dateFormatter.ts
// 레거시 코드: 날짜를 포맷팅하는 함수.
// 여러 곳에서 사용 중이지만 테스트가 없어 수정 시 사이드 이펙트 예측 불가.
export function formatDate(date: Date | string): string {
  const d = new Date(date);
  // 엔트로피 증가: 예외 처리가 미흡하고 로직이 혼재되어 있음
  return `${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`;
}
```

개발자 A가 이 함수를 수정하여 '시간' 정보까지 포함하도록 변경하려 합니다. 하지만 테스트가 없기 때문에, 이 변경이 기존에 날짜만 필요로 했던 수십 개의 다른 페이지를 깨뜨릴지 확신할 수 없습니다. 두려움 때문에 개발자 A는 기존 함수를 수정하는 대신 `formatDateWithTime`이라는 중복 함수를 만들게 되고, 이는 코드베이스의 엔트로피를 더욱 높이는 결과를 낳습니다.


#### [해결 과정: 테스트를 통한 엔트로피 통제]

엔트로피를 낮추기 위해 기능을 확장하기 전, 기존 동작을 보장하는 테스트를 먼저 작성(Characterization Test)하고 안전하게 리팩토링합니다.

```typescript
// 1단계: 기존 동작을 고정하는 테스트 작성 (엔트로피 증가 방지)
describe('formatDate', () => {
  it('should format date as YYYY-M-D for valid input', () => {
    const date = new Date('2023-05-01T10:00:00Z');
    // 기존의 불안정한 동작(월/일이 한 자리일 때 0이 안 붙음)이라도 일단 테스트로 고정
    expect(formatDate(date)).toBe('2023-5-1');
  });
});

// 2단계: 리팩토링 및 기능 확장 (안전한 변경)
export function formatDate(date: Date | string, includeTime = false): string {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0'); // 0 padding 추가로 개선
  const day = String(d.getDate()).padStart(2, '0');
  
  const dateStr = `${year}-${month}-${day}`;
  
  if (!includeTime) {
    return dateStr;
  }
  
  const hours = String(d.getHours()).padStart(2, '0');
  const minutes = String(d.getMinutes()).padStart(2, '0');
  return `${dateStr} ${hours}:${minutes}`;
}

// 3단계: 테스트 업데이트 및 확장
describe('formatDate', () => {
  it('should format date as YYYY-MM-DD by default (Improvements applied)', () => {
    const date = new Date('2023-05-01T10:00:00');
    // 리팩토링을 통해 0 padding이 적용되었음을 검증
    expect(formatDate(date)).toBe('2023-05-01');
  });

  it('should include time when includeTime flag is true', () => {
    const date = new Date('2023-05-01T10:30:00');
    expect(formatDate(date, true)).toBe('2023-05-01 10:30');
  });
});
```

테스트라는 안전장치가 마련됨으로써, 개발자는 중복 코드를 생성하는 대신 기존 코드를 개선(0 padding 추가)하고 확장할 수 있게 되었습니다. 이것이 테스트가 시스템의 무질서를 막는 원리입니다.


### 1.1.3. 품질은 테스트로 만들어지지 않는다 (개발과 테스트의 융합)

"품질은 테스트로 만들어지지 않는다(Quality cannot be tested in)."는 말은 소프트웨어 품질 관리의 가장 오래된 격언 중 하나입니다. 이는 제품이 완성된 후 QA 팀이 아무리 많은 테스트를 수행하고 버그를 찾아내더라도, 이미 잘못 설계되고 구현된 소프트웨어의 본질적인 품질을 높일 수는 없음을 의미합니다. 마치 자동차를 다 만든 뒤에 검사를 통해 결함을 발견하면, 이를 수정하기 위해 엄청난 비용과 해체 작업이 필요한 것과 같습니다.

구글은 이 문제를 해결하기 위해 **개발과 테스트의 경계를 허무는 전략** 을 취합니다. 코드를 작성하는 행위와 테스트하는 행위는 분리될 수 없습니다. 개발자가 코드를 조금 작성하고 즉시 테스트하고, 다시 코드를 작성하는 반복적인 과정 자체가 개발 프로세스여야 합니다.

이 원칙 하에서 테스트의 주체는 전문 테스터가 아닌 **개발자(Software Engineer)** 자신이 됩니다. 개발자가 자신이 작성한 코드에 대한 테스트를 직접 작성할 때, 코드는 테스트하기 쉬운(Testable) 구조로 설계될 수밖에 없습니다. 테스트하기 쉬운 코드는 일반적으로 결합도(Coupling)가 낮고 응집도(Cohesion)가 높은 좋은 아키텍처를 가집니다. 즉, 테스트는 단순한 검증 도구가 아니라, 더 나은 설계를 이끌어내는 도구입니다.


#### [문제 상황: 테스트와 개발의 분리로 인한 설계 결함]

개발자가 기능 구현에만 집중하고 테스트를 나중으로 미룰 때, 테스트하기 매우 어려운 '거대한 진흙 덩어리(Big Ball of Mud)' 코드가 탄생합니다.

```typescript
// Bad Case: 테스트를 고려하지 않은 강결합 코드
import axios from 'axios';

class OrderProcessor {
  async processOrder(orderId: string) {
    // 1. 외부 API 직접 호출 (테스트 시 실제 네트워크 요청 발생)
    const order = await axios.get(`/api/orders/${orderId}`);
    
    // 2. 전역 상태 또는 싱글톤 직접 의존
    if (globalThis.config.isMaintenanceMode) {
      throw new Error("System maintenance");
    }

    // 3. 복잡한 비즈니스 로직과 DB 업데이트가 혼재
    if (order.data.status === 'pending') {
      await axios.post('/api/inventory/reduce', { items: order.data.items });
      return 'Success';
    }
  }
}
```

위 코드는 `axios`를 직접 import하여 사용하고 전역 객체에 의존하기 때문에, 단위 테스트를 작성하려면 네트워크 요청을 모킹(Mocking)하는 복잡한 설정이 필요하거나 실제 서버가 필요합니다. 이는 개발자가 테스트를 '나중에 할 일'로 치부했을 때 발생하는 전형적인 패턴입니다.


#### [해결 과정: 개발과 테스트의 융합 (DI 활용)]

개발 시점에 테스트를 함께 고려한다면, 외부 의존성을 주입(Dependency Injection)받도록 설계하여 테스트 용이성을 확보했을 것입니다.

```typescript
// Good Case: 테스트 용이성을 고려한 설계 (의존성 주입)

// 인터페이스 정의로 의존성 분리
interface ApiClient {
  getOrder(id: string): Promise<any>;
  reduceInventory(items: any[]): Promise<void>;
}

interface SystemConfig {
  isMaintenanceMode: boolean;
}

class OrderProcessor {
  // 생성자를 통해 의존성을 주입받음 (테스트 시 Mock 주입 가능)
  constructor(
    private api: ApiClient,
    private config: SystemConfig
  ) {}

  async processOrder(orderId: string) {
    if (this.config.isMaintenanceMode) {
      throw new Error("System maintenance");
    }

    const order = await this.api.getOrder(orderId);

    if (order.status === 'pending') {
      await this.api.reduceInventory(order.items);
      return 'Success';
    }
  }
}

// 테스트 코드 (개발자가 즉시 검증 가능)
describe('OrderProcessor', () => {
  it('should create an order successfully', async () => {
    // 가짜(Mock) 객체를 주입하여 네트워크 없이 로직 검증
    const mockApi = {
      getOrder: async () => ({ status: 'pending', items: [] }),
      reduceInventory: async () => {}, // Spy를 심어 호출 여부 확인 가능
    };
    const mockConfig = { isMaintenanceMode: false };

    const processor = new OrderProcessor(mockApi, mockConfig);
    const result = await processor.processOrder('123');

    expect(result).toBe('Success');
  });
});
```

이처럼 테스트를 개발 프로세스의 일부로 통합하면, 코드는 자연스럽게 모듈화되고 유연해집니다. 품질은 후반부의 검사가 아니라, 이러한 설계 과정에서 만들어집니다.

---


## 1.2. 구글의 테스트 조직과 역할


### 1.2.1. SWE(개발자), SET(테스트 개발자), TE(테스트 엔지니어)의 역할 구분

구글은 테스트 문제를 해결하기 위해 엔지니어링 역할을 세분화했습니다. 이는 단순히 '개발하는 사람'과 '테스트하는 사람'을 나누는 것이 아니라, 품질에 대한 책임을 분산하고 각자의 전문성을 극대화하기 위함입니다.

1. **SWE (Software Engineer)** : 전통적인 개발자입니다. 하지만 구글의 SWE는 기능 구현뿐만 아니라 해당 기능에 대한 **단위 테스트(Unit Test) 작성과 품질에 대한 1차적인 책임** 을 집니다. "내가 짠 코드는 내가 검증한다"는 원칙 하에, SWE는 테스트 코드 작성에 상당한 시간을 할애합니다.
2. **SET (Software Engineer in Test)** : 테스트 인프라와 도구를 만드는 개발자입니다. 이들은 제품 기능을 직접 테스트하기보다는, SWE들이 테스트를 더 쉽고 빠르게 작성할 수 있도록 프레임워크를 개발하고, 리팩토링을 돕고, 코드의 테스트 용이성(Testability)을 높이는 데 주력합니다. SET는 개발자와 동일한 코딩 능력을 갖추고 있지만, 그 초점이 '테스트 자동화'와 '생산성'에 맞춰져 있습니다.
3. **TE (Test Engineer)** : 사용자 관점의 전문가입니다. SWE와 SET가 코드와 모듈 단위의 품질에 집중한다면, TE는 전체 시스템의 통합, 사용자 시나리오, 리스크 분석, 탐색적 테스트(Exploratory Testing)에 집중합니다. 이들은 "사용자가 이 제품을 어떻게 오용할 수 있는가?", "시스템이 극한 상황에서 어떻게 동작하는가?"와 같은 거시적인 품질 문제를 다룹니다.

이러한 역할 구분은 웹 개발 환경에서도 유효합니다. 프론트엔드 개발자(SWE)는 컴포넌트 단위 테스트를 작성하고, 플랫폼 엔지니어(SET)는 CI/CD 파이프라인과 E2E 테스트 환경을 구축하며, QA 엔지니어(TE)는 실제 사용자 흐름과 엣지 케이스를 검증하는 구조로 적용될 수 있습니다.


### 1.2.2. QA에서 엔지니어링 생산성(Engineering Productivity)으로의 진화

과거의 소프트웨어 산업에서 QA(Quality Assurance)는 개발 마지막 단계에서 버그를 잡는 '게이트키퍼' 역할을 수행했습니다. 하지만 구글은 이러한 방식이 병목 현상을 유발하고 혁신을 저해한다고 판단했습니다. 이에 따라 QA 조직을 **엔지니어링 생산성(Engineering Productivity, EngProd)** 조직으로 재정의했습니다.

EngProd의 목표는 단순히 '제품을 테스트하는 것'이 아니라, **'개발자가 더 빠르고 안전하게 제품을 개발하고 배포할 수 있도록 돕는 것'** 입니다. 이는 테스트 자동화 도구 개발, 빌드 시스템 최적화, 코드 분석 도구 제공, 릴리스 프로세스 자동화 등을 포함합니다.

웹 개발의 맥락에서 이는 다음과 같은 변화를 의미합니다:

* **과거 (QA):** 개발자가 기능을 완성하면 QA 팀이 수동으로 브라우저를 클릭하며 버그를 찾음. 배포 주기가 길어짐.
* **현재 (EngProd):** 코드가 커밋되는 즉시 자동화된 테스트가 실행되고, 프리뷰(Preview) 환경이 생성되며, 성능 지표(Lighthouse 점수 등)가 자동으로 측정됨. 개발자는 피드백을 즉시 받고 수정할 수 있음.

이러한 진화는 테스트를 '나중의 일'에서 '개발의 일부'로, 그리고 '비용'에서 '생산성 향상의 도구'로 변화시킵니다.


### 1.2.3. 개발자가 주도하는 품질 책임 ("You build it, you break it")

구글 엔지니어링 문화의 핵심 중 하나는 "You build it, you break it(네가 만들었으면, 네가 고장 낸 것이다)"이라는 책임 의식입니다. 이는 별도의 QA 팀이 모든 버그를 잡아줄 것이라는 안일한 기대를 제거합니다. 개발자가 자신의 코드에 대해 온전한 주인의식(Ownership)을 가질 때 비로소 높은 품질이 달성됩니다.

이 원칙이 작동하기 위해서는 시스템적 뒷받침이 필요합니다. 구글은 **프리서밋(Presubmit) 체크** 라는 시스템을 통해 이를 강제합니다. 개발자가 코드를 저장소에 병합(Merge)하기 전, 시스템은 자동으로 연관된 모든 테스트를 실행합니다. 테스트가 하나라도 실패하면 코드는 병합될 수 없습니다. 즉, "빌드를 깨뜨리는 것"이 원천적으로 차단되거나, 깨뜨리더라도 즉시 해당 개발자에게 책임이 돌아갑니다.


#### [문제 상황: 공유 컴포넌트 수정의 두려움]

대규모 웹 프로젝트에서 공통 UI 라이브러리(예: 버튼 컴포넌트)를 수정해야 하는 상황입니다. 이 버튼은 수백 개의 페이지에서 사용됩니다.

```typescript
// shared/Button.tsx
// 이 컴포넌트를 수정하면 수백 페이지에 영향이 감.
// 개발자는 자신의 수정이 다른 페이지를 깨뜨릴까 두려워 수정을 기피하거나,
// 별도의 DuplicateButton을 만들게 됨.
export const Button = ({ onClick, label }: Props) => {
  return <button onClick={onClick} className="btn-primary">{label}</button>;
};
```

책임 소재가 불분명할 경우, 개발자는 "QA 팀이 알아서 확인하겠지"라고 생각하며 위험한 변경을 하거나, 반대로 변경을 극도로 꺼리게 됩니다.


#### [해결 과정: 자동화된 책임 시스템]

"You build it, you break it" 원칙을 적용하면, 개발자는 변경에 대한 확신을 가질 수 있습니다.

1. **책임의 도구화** : 모든 페이지와 컴포넌트는 소유자(Owner)와 테스트를 가집니다.
2. **자동화된 영향도 분석** : `Button.tsx`를 수정하고 PR(Pull Request)을 올리면, CI 시스템이 이 버튼을 사용하는 모든 페이지의 테스트를 자동으로 실행합니다.
3. **피드백**: 만약 `CheckoutPage`의 테스트가 실패하면, 시스템은 버튼을 수정한 개발자에게 알립니다. 개발자는 `CheckoutPage`를 고치거나 버튼 수정 방식을 변경해야 합니다.

이 시스템 하에서 개발자는 다음과 같이 자신 있게 코드를 수정할 수 있습니다.

```typescript
// shared/Button.tsx (수정)
// 아이콘 지원 추가
export const Button = ({ onClick, label, icon }: Props) => {
  return (
    <button onClick={onClick} className="btn-primary">
      {icon && <span className="icon">{icon}</span>}
      {label}
    </button>
  );
};
```

테스트가 통과한다면, 개발자는 자신의 변경이 시스템 전체를 망가뜨리지 않았다는 확신을 갖고 배포할 수 있습니다. 품질의 책임이 개발자에게 있지만, 시스템이 그 책임을 질 수 있도록 돕는 것입니다.

---


## 1.3. 혁신과 테스트


### 1.3.1. 실패를 빨리 하는 방법 (Failing Fast)

혁신은 수많은 시도와 실패를 통해 이루어집니다. 하지만 실패의 비용이 높다면 누구도 새로운 시도를 하지 않을 것입니다. 따라서 혁신을 위해서는 **'실패의 비용을 낮추는 것'** , 즉 **'최대한 빨리 실패하는 것(Failing Fast)'** 이 중요합니다.

소프트웨어 엔지니어링에서 '빨리 실패하기'는 피드백 루프(Feedback Loop)를 단축하는 것을 의미합니다. 버그가 배포된 후 사용자에게 발견되는 것(가장 느린 실패)과, 코드를 작성하는 순간 IDE에서 빨간 줄로 발견되는 것(가장 빠른 실패) 사이에는 천문학적인 비용 차이가 존재합니다.

구글은 이를 위해 단위 테스트 실행 시간을 밀리초 단위로 유지하고, CI 파이프라인을 최적화합니다. 웹 개발에서도 마찬가지입니다. 타입스크립트와 같은 정적 타입 시스템은 코드를 실행하기도 전에 실패를 알려주는 훌륭한 'Fail Fast' 도구입니다.


#### [문제 상황: 느린 실패로 인한 비용 증가]

런타임에만 에러를 확인할 수 있는 환경에서는 개발자가 코드를 수정하고, 브라우저를 새로고침하고, 특정 버튼을 클릭해서 에러를 확인하는 데 수십 초가 걸립니다.

```javascript
// JavaScript 예시 (느린 실패)
function calculateTotal(items) {
  // items가 배열인지, 각 item이 price를 가지고 있는지 코드를 실행해봐야만 알 수 있음.
  // 오타가 있어도 실행 시점까지 모름.
  return items.reduce((sum, item) => sum + item.priice, 0); // 오타: priice
}
```

이러한 오타는 사용자가 장바구니에서 결제 버튼을 누르는 순간에야 발견될 수도 있습니다.


#### [해결 과정: 빠른 실패 구현]

TypeScript와 엄격한 단위 테스트를 도입하여 실패 시점을 앞당깁니다.

```typescript
// TypeScript 예시 (컴파일 타임 실패 - 가장 빠름)
interface Item {
  price: number;
  name: string;
}

function calculateTotal(items: Item[]): number {
  // TypeScript 컴파일러가 즉시 에러를 표시함:
  // Property 'priice' does not exist on type 'Item'. Did you mean 'price'?
  return items.reduce((sum, item) => sum + item.priice, 0); 
}

// 단위 테스트 (로직 검증 실패 - 그 다음으로 빠름)
describe('calculateTotal', () => {
  it('should return 0 for empty items', () => {
    expect(calculateTotal([])).toBe(0);
  });
  
  it('should sum up prices', () => {
    const items = [{ price: 100, name: 'A' }, { price: 200, name: 'B' }];
    expect(calculateTotal(items)).toBe(300);
  });
});
```

컴파일러와 단위 테스트를 통해 개발자는 코드를 작성한 직후 즉시 실패를 경험하고 수정할 수 있습니다. 이는 개발자가 더 과감하게 리팩토링하고 새로운 기능을 시도할 수 있는 안전망이 됩니다.


### 1.3.2. 프리토타이핑(Pretotyping): '올바른 것'을 만들기 위한 테스트

많은 엔지니어들이 "제품을 올바르게 만드는 것(Building it right)"에 집중합니다. 버그 없이 완벽하게 작동하고, 확장성 있으며, 테스트 커버리지가 100%인 코드를 작성하려고 노력합니다. 하지만 구글은 이보다 더 중요한 질문을 던집니다. **"우리가 올바른 제품을 만들고 있는가(Building the right it)?"**

아무리 기술적으로 완벽한 제품이라도 아무도 사용하지 않는다면 그것은 실패입니다. **프리토타이핑(Pretotyping)** 은 'Pretending(가장하다)'과 'Prototyping(프로토타이핑)'의 합성어로, 실제 제품을 만들기 전에 아주 적은 비용으로 아이디어 자체를 검증하는 기법입니다. 이는 코드를 작성하기 전 단계의 '가장 앞단에 있는 테스트'라고 볼 수 있습니다.

실제 코드를 한 줄도 작성하지 않고, 가짜 버튼(Painted Door)을 만들거나 수동으로 동작을 흉내 내어 사용자의 반응을 살피는 것이 프리토타이핑입니다.


#### [문제 상황: 과잉 엔지니어링된 기능의 실패]

팀이 웹 애플리케이션에 '고급 AI 기반 추천 시스템'을 도입하기로 결정했습니다. 엔지니어들은 3개월 동안 복잡한 머신러닝 모델을 연동하고, 완벽한 UI를 구현하고, 수백 개의 테스트 코드를 작성하여 배포했습니다. 하지만 배포 후 데이터를 분석해보니, 해당 기능을 클릭하는 사용자는 1%도 되지 않았습니다. 3개월의 엔지니어링 시간은 낭비되었습니다.


#### [해결 과정: 프리토타이핑을 통한 검증]

본격적인 개발 전에 프리토타이핑을 통해 수요를 먼저 테스트했어야 합니다.

1. **가설 설정** : "사용자들은 AI 추천 기능을 원할 것이다."
2. **프리토타입 제작** : 복잡한 백엔드 로직 없이, 프론트엔드에 'AI 추천 받기' 버튼만 추가합니다.
3. **구현 (최소 비용)** :

```typescript
// features/AiRecommendation/PretotypeButton.tsx
export const AiRecommendationButton = () => {
  const handleClick = () => {
    // 실제 로직 없음. 사용자의 관심(클릭)만 추적.
    analytics.track('CLICK_AI_RECOMMENDATION');
    alert("준비 중인 기능입니다. 많은 관심 감사합니다!");
  };

  return (
    <button onClick={handleClick} className="btn-fancy">
      ✨ AI에게 추천 받기
    </button>
  );
};
```

4. **데이터 분석 및 결정** : 1주일 간 데이터를 수집한 결과, 클릭률이 매우 높다면 그때서야 실제 엔지니어링 자원을 투입하여 기능을 구현합니다. 클릭률이 낮다면, 코드를 작성하지 않고 아이디어를 폐기함으로써 낭비를 막습니다.

이처럼 테스트의 범위는 코드 품질을 넘어 제품의 가치 검증까지 확장되어야 합니다. '올바른 것'을 만들고 있다는 확신이 있을 때, '올바르게 만드는' 엔지니어링 노력도 빛을 발하기 때문입니다.


# 2장. 코드 헬스(Code Health): 테스트하기 좋은 코드가 좋은 코드다


## 2.1. 가독성과 유지보수성


### 2.1.1. 인지 부하(Cognitive Load) 줄이기: 클린 코드의 원칙

코드는 컴퓨터가 실행하기 위해 작성되지만, 실제로는 사람이 읽기 위해 존재합니다. 개발자가 코드를 수정할 때 뇌는 변수의 상태, 조건문의 분기, 루프의 인덱스 등 수많은 정보를 단기 기억에 저장해야 합니다. 사람이 한 번에 기억할 수 있는 정보의 양(청크)은 5~7개로 제한적입니다. 이 한계를 초과하는 복잡한 코드는 개발자에게 과도한 **인지 부하(Cognitive Load)** 를 유발합니다.

인지 부하가 높은 코드는 버그의 온상입니다. 개발자가 로직을 완전히 파악하지 못한 채 수정할 가능성이 높기 때문입니다. 따라서 '코드 헬스'의 첫 번째 목표는 코드를 읽는 사람의 인지 부하를 최소화하는 것입니다. 이를 위해 함수는 작게 유지하고, 한 번에 하나의 일만 수행하며(단일 책임 원칙), 추상화 수준을 일관되게 유지해야 합니다.


#### [문제 상황: 인지 부하가 높은 복잡한 조건문]

다음은 피자의 상태를 확인하여 '환상적인 피자'인지 판단하는 함수입니다. 복잡한 조건문이 한 줄에 얽혀 있어, 이 코드를 읽는 개발자는 모든 연산자의 우선순위와 각 변수의 의미를 머릿속으로 시뮬레이션해야 합니다.

```typescript
// Bad Case: 인지 부하를 유발하는 복잡한 불리언 표현식
interface PizzaConfig {
  hasCheese: boolean;
  pepperoniCount: number;
  sausageCount: number;
  hasSpecialSauce: boolean;
  mushrooms: string[];
}

function isPizzaFantastic(config: PizzaConfig): boolean {
  // 개발자는 이 표현식을 이해하기 위해 멈춰 서야 함.
  // OR(||)와 AND(&&)가 섞여 있고, 배열 길이 체크 등이 혼재됨.
  return (
    (!config.hasCheese || config.pepperoniCount > 0 || config.sausageCount > 0) &&
    (config.hasSpecialSauce || config.mushrooms.includes('portobello')) &&
    config.hasCheese
  );
}
```

이 코드는 `isPizzaFantastic`이 `true`가 되기 위한 조건을 파악하기 위해 종이와 펜이 필요할 정도로 복잡합니다.


#### [해결 과정: 의미 있는 단위로 분해]

인지 부하를 줄이기 위해 복잡한 로직을 **의미 있는 이름을 가진 중간 변수** 나 **헬퍼 함수** 로 추출합니다.

```typescript
// Good Case: 추상화를 통한 인지 부하 감소

function isPizzaFantastic(config: PizzaConfig): boolean {
  // 치즈가 없으면 환상적일 수 없음 (Guard Clause로 빠른 반환)
  if (!config.hasCheese) {
    return false;
  }

  // 각 조건을 의미 있는 변수로 추출하여 추상화
  const hasGoodMeat = config.pepperoniCount > 0 || config.sausageCount > 0;
  const hasGoodVeggies = config.hasSpecialSauce || config.mushrooms.includes('portobello');
  
  // 코드가 자연어처럼 읽힘: "고기가 훌륭하고, 야채도 훌륭해야 한다."
  return hasGoodMeat && hasGoodVeggies;
}
```

이제 개발자는 `hasGoodMeat`가 구체적으로 어떤 조건인지 궁금할 때만 세부 구현을 들여다보면 됩니다. 전체 흐름을 파악하는 데 드는 정신적 노력이 획기적으로 줄어듭니다.


### 2.1.2. 코드는 위에서 아래로 읽혀야 한다 (제어 흐름 단순화)

코드를 읽는 것은 책을 읽는 것과 비슷해야 합니다. 시선이 위에서 아래로 자연스럽게 흐르는 것이 이상적입니다. 하지만 `if-else` 중첩(Nesting)이 깊어지거나, 실행 흐름이 이리저리 점프하는 코드는 독자의 집중력을 깨뜨립니다.

**제어 흐름(Control Flow)** 을 단순화하는 가장 효과적인 방법은 **조기 반환(Early Return)** 또는 **가드 절(Guard Clause)** 패턴을 사용하는 것입니다. 예외적인 상황이나 에러 케이스를 함수 초입에서 먼저 처리하고 반환해 버리면, 함수의 나머지 부분에서는 '정상적인 상황(Happy Path)'에만 집중할 수 있습니다. 이는 들여쓰기 깊이를 줄여주고, 개발자가 머릿속에 담아두어야 할 조건(Context)의 수를 줄여줍니다.


#### [문제 상황: 깊은 중첩으로 인한 가독성 저하]

아래 코드는 사용자 권한과 입력값을 검증하고 데이터를 처리하는 로직입니다. `if-else`가 중첩되면서 핵심 로직인 `saveData`가 어디서 호출되는지 찾기 어렵습니다.

```typescript
// Bad Case: 화살촉 모양의 중첩 코드 (Arrow Code)
function processUserData(user: User | null, data: string) {
  if (user !== null) {
    if (user.isActive) {
      if (user.role === 'admin') {
        if (data.length > 0) {
          saveData(data); // 핵심 로직이 깊숙이 숨어 있음
          return 'Saved';
        } else {
          return 'Empty data';
        }
      } else {
        return 'No permission';
      }
    } else {
      return 'User inactive';
    }
  } else {
    return 'No user';
  }
}
```


#### [해결 과정: 가드 절을 활용한 평탄화]

부정적인 조건(예외 상황)을 먼저 처리하여 함수를 종료시킵니다. 이를 통해 핵심 로직은 들여쓰기 없이 최상위 레벨에 위치하게 됩니다.

```typescript
// Good Case: 가드 절을 사용하여 평탄화된 코드
function processUserData(user: User | null, data: string) {
  // 예외 상황들을 먼저 쳐냄
  if (!user) return 'No user';
  if (!user.isActive) return 'User inactive';
  if (user.role !== 'admin') return 'No permission';
  if (data.length === 0) return 'Empty data';

  // 핵심 로직: 모든 검증을 통과한 "정상 흐름"
  saveData(data);
  return 'Saved';
}
```

이 구조는 코드를 읽는 사람에게 "이 조건들이 만족되지 않으면 더 볼 필요가 없다"는 명확한 신호를 주며, 핵심 로직을 강조합니다.


### 2.1.3. 식별자 명명 규칙과 자기 문서화된 코드 (Self-documenting Code)

"컴퓨터 과학에서 난제는 딱 두 가지다. 캐시 무효화(Cache Invalidation)와 이름 짓기(Naming Things)."라는 유명한 말이 있습니다. 그만큼 좋은 이름을 짓는 것은 어렵지만 중요합니다. 변수, 함수, 클래스의 이름은 그 자체로 주석 없이도 코드의 의도를 명확히 전달해야 합니다. 이를 **자기 문서화된 코드(Self-documenting Code)** 라고 합니다.

좋은 이름은 '무엇을(What)' 하는지 설명해야지, '어떻게(How)' 구현되었는지를 설명해서는 안 됩니다. 또한, 불필요한 접두사나 헝가리안 표기법을 피하고, 문맥상 명확한 정보는 중복해서 적지 않아야 합니다. 코드를 읽는 사람이 이름을 보고 내용을 추측했을 때, 그 추측이 빗나가지 않아야 좋은 이름입니다.


#### [문제 상황: 모호하거나 중복된 이름]

아래 코드는 이름만 보고는 어떤 데이터인지, 어떤 동작을 하는지 파악하기 어렵습니다.

```typescript
// Bad Case: 나쁜 네이밍
interface D { // D가 뭐지? Data?
  n: string; // n은 name? number?
  d: Date;
}

// 함수 이름이 구현 상세(List)를 노출하고, 매개변수 이름이 모호함
function getInfoList(val: D[]): string[] {
  return val.map(v => v.n);
}

// 문맥상 중복된 정보
const userUserData = { // user.userData? 중복됨
  userName: 'John',    // user.userName? 중복됨
  userAge: 30
};
```


#### [해결 과정: 의도를 드러내는 네이밍]

이름을 통해 '무엇을 하는지' 명확히 하고, 문맥 중복을 제거합니다.

```typescript
// Good Case: 명확한 네이밍
interface User {
  name: string;
  registeredAt: Date;
}

// 구현(List)보다는 의도(Names)를 드러냄
function extractUserNames(users: User[]): string[] {
  return users.map(user => user.name);
}

// 객체 이름을 통해 문맥이 형성되므로 속성명에서 'user' 제거
const user = {
  name: 'John', // user.name으로 접근하므로 자연스러움
  age: 30
};
```

주석 없이 코드만 읽어도 `extractUserNames(users)`가 무엇을 리턴할지 명확히 알 수 있습니다.

---


## 2.2. 의존성 관리와 결합도


### 2.2.1. 싱글톤(Singleton)은 병적인 거짓말쟁이다 (전역 상태의 위험성)

싱글톤 패턴은 애플리케이션 전체에서 인스턴스가 하나만 존재하도록 보장하는 패턴입니다. 하지만 테스트 관점에서 싱글톤은 "병적인 거짓말쟁이(Pathological Liar)"입니다. 왜냐고요? 함수의 시그니처(API)만 봐서는 이 함수가 어떤 외부 상태에 의존하는지 알 수 없게 만들기 때문입니다.

테스트하기 좋은 코드는 **명시적인 의존성(Explicit Dependency)** 을 가집니다. 함수가 `Database`가 필요하면 인자로 `Database`를 받아야 합니다. 하지만 싱글톤을 사용하면 함수 내부에서 몰래 `Database.getInstance()`를 호출하여 전역 상태를 가져옵니다. 이는 테스트 시 가짜(Mock) 데이터베이스로 교체하는 것을 불가능하게 만들거나 매우 어렵게 만듭니다. 또한, 전역 상태는 테스트 간의 격리(Isolation)를 깨뜨려, A 테스트가 변경한 상태가 B 테스트의 실패 원인이 되는 '플래키 테스트(Flaky Test)'를 유발합니다.


#### [문제 상황: 싱글톤으로 인한 숨겨진 의존성]

```typescript
// Bad Case: 싱글톤 사용
class AuthStore {
  private static instance: AuthStore;
  public user: User | null = null;

  static getInstance() {
    if (!this.instance) this.instance = new AuthStore();
    return this.instance;
  }
}

// 이 함수는 인자가 없어서 순수해 보이지만, 
// 내부에서 전역 싱글톤을 참조하는 거짓말을 하고 있음.
function getWelcomeMessage() {
  const user = AuthStore.getInstance().user; // 숨겨진 의존성!
  if (user) return `Welcome, ${user.name}`;
  return 'Please log in';
}
```

이 함수를 테스트하려면 테스트 전에 `AuthStore`의 상태를 초기화하고, 테스트가 끝난 후 다시 되돌려 놓는(Tear Down) 번거로운 작업이 필요합니다. 만약 초기화를 깜빡하면 다른 테스트에 영향을 줍니다.


#### [해결 과정: 의존성 주입으로 명시화]

싱글톤 대신 필요한 객체를 인자로 전달받도록 변경합니다.

```typescript
// Good Case: 명시적 의존성 주입
class AuthStore {
  public user: User | null = null;
}

// 의존성을 명시적으로 드러냄
function getWelcomeMessage(authStore: AuthStore) {
  const user = authStore.user;
  if (user) return `Welcome, ${user.name}`;
  return 'Please log in';
}

// 테스트
it('should welcome logged in user', () => {
  // 테스트용으로 독립적인 Store 인스턴스 생성 (전역 상태 오염 없음)
  const mockStore = new AuthStore();
  mockStore.user = { name: 'Alice' };
  
  expect(getWelcomeMessage(mockStore)).toBe('Welcome, Alice');
});
```

이제 테스트는 독립적이며, 함수 시그니처만 봐도 무엇이 필요한지 명확히 알 수 있습니다.


### 2.2.2. 'new' 연산자의 올바른 위치와 객체 그래프 생성의 분리

테스트하기 어려운 코드의 대표적인 특징은 비즈니스 로직 한가운데서 `new` 연산자를 사용하여 객체를 직접 생성하는 것입니다. 클래스 A가 클래스 B를 내부에서 `new B()`로 생성하면, A와 B는 강하게 결합(Tight Coupling)됩니다. A를 테스트할 때 B를 가짜 객체(Test Double)로 대체할 방법이 사라집니다.

이를 해결하기 위해 **객체 생성(Construction)** 과 **객체 사용(Application Logic)** 을 분리해야 합니다. 비즈니스 로직을 담당하는 클래스에서는 `new`를 사용하지 않고, 생성된 객체를 주입받아 사용하기만 해야 합니다. 모든 `new` 연산자는 애플리케이션의 시작점(Entry Point)이나 팩토리(Factory), 또는 DI 컨테이너 설정 부분으로 밀어내야 합니다.


#### [문제 상황: 내부 생성으로 인한 강결합]

```typescript
// Bad Case: 내부에서 직접 의존성 생성
import { PostgresDB } from './db';

class UserService {
  private db: PostgresDB;

  constructor() {
    // UserService는 PostgresDB 구현체에 강하게 결합됨.
    // 테스트 시 실제 DB 연결을 피할 방법이 없음.
    this.db = new PostgresDB(); 
  }

  async getUser(id: string) {
    return this.db.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}
```


#### [해결 과정: 생성자 주입을 통한 분리]

`new` 연산자를 `UserService` 외부로 뺍니다. `UserService`는 `Database` 인터페이스에만 의존하게 합니다.

```typescript
// Good Case: 의존성 주입
interface Database {
  query(sql: string): Promise<any>;
}

class UserService {
  // 이미 생성된 DB 인스턴스를 받음 (누가 생성했는지는 관심 없음)
  constructor(private db: Database) {}

  async getUser(id: string) {
    return this.db.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

// 애플리케이션 시작점 (메인/팩토리)
// 실제 런타임:
const realDb = new PostgresDB();
const service = new UserService(realDb);

// 테스트 환경:
// 가짜 DB를 주입하여 테스트 가능
const mockDb = { query: async () => ({ id: '1', name: 'Test' }) };
const testService = new UserService(mockDb);
```


### 2.2.3. 데메테르의 법칙(Law of Demeter): 필요한 것만 요청하라

데메테르의 법칙은 "낯선 이와 대화하지 말라(Don't talk to strangers)"는 원칙으로, 객체 간의 결합도를 낮추기 위한 가이드라인입니다. 코드에서는 보통 `a.getB().getC().doSomething()`과 같이 점(dot)이 여러 개 찍히는 체이닝(Chaining)을 피하라는 것으로 해석됩니다.

객체가 자신이 직접 필요로 하지 않는 객체를 탐색(Navigation)하여 필요한 것을 찾는 방식은 "건초더미에서 바늘 찾기"와 같습니다. 이는 코드의 결합도를 높이고, 테스트를 작성할 때 불필요한 중간 객체들(Mock)까지 모두 설정해야 하는 고통을 줍니다. 객체는 자신이 직접 사용할 의존성만 요청해야 합니다.


#### [문제 상황: 기차 충돌 (Train Wreck) 코드]

```typescript
// Bad Case: 과도한 탐색
class OrderService {
  processOrder(context: AppContext) {
    // 필요한 건 wallet인데, context -> user -> wallet 순으로 탐색
    const wallet = context.getUser().getWallet();
    wallet.deduct(100);
  }
}
```

이 코드를 테스트하려면 `MockContext`가 `MockUser`를 리턴하고, `MockUser`가 `MockWallet`을 리턴하도록 설정해야 합니다. 테스트 준비 과정(Setup)이 매우 복잡해집니다.


#### [해결 과정: 직접 필요한 객체 주입]

`OrderService`가 정말 필요한 것은 `Wallet`입니다. `AppContext` 전체가 아닙니다.

```typescript
// Good Case: 필요한 객체만 요청
class OrderService {
  // Wallet을 직접 받거나, User를 받도록 변경
  processOrder(wallet: Wallet) {
    wallet.deduct(100);
  }
}
```

이제 테스트는 `MockWallet` 하나만 준비하면 됩니다. 코드는 더 간결해지고 결합도는 낮아졌습니다.

---


## 2.3. 의존성 주입(Dependency Injection)


### 2.3.1. 생성자 주입 vs 세터(Setter) 주입

의존성 주입(DI)에는 크게 생성자 주입(Constructor Injection)과 세터 주입(Setter Injection) 두 가지 방식이 있습니다. 구글은 명확하게 **생성자 주입** 을 선호합니다.

생성자 주입의 가장 큰 장점은 **객체의 불변성(Immutability)** 과 **완전성(Completeness)** 을 보장한다는 것입니다. 객체가 생성되는 시점에 필요한 모든 의존성을 주입받으므로, 객체는 생성되자마자 '완전한 상태'가 됩니다. 또한 의존성을 `readonly`나 `final`로 선언하여 변경되지 않음을 보장할 수 있습니다. 반면 세터 주입은 객체 생성 후에 의존성을 주입하므로, 의존성이 주입되지 않은 '불완전한 상태'로 객체가 존재할 수 있는 위험이 있습니다. 이는 `NullPointerException`과 같은 런타임 에러의 원인이 됩니다.


#### [문제 상황: 세터 주입의 위험성]

```typescript
// Bad Case: 세터 주입
class EmailSender {
  private client?: SmtpClient;

  setClient(client: SmtpClient) {
    this.client = client;
  }

  send(msg: string) {
    // client가 세팅되었는지 매번 확인해야 함.
    // 개발자가 setClient 호출을 깜빡하면 런타임 에러 발생.
    if (!this.client) throw new Error("Client not set!");
    this.client.send(msg);
  }
}
```


#### [해결 과정: 생성자 주입 사용]

```typescript
// Good Case: 생성자 주입
class EmailSender {
  // 생성 시점에 반드시 client가 있어야 함을 강제.
  // readonly로 불변성 보장.
  constructor(private readonly client: SmtpClient) {}

  send(msg: string) {
    // null 체크 불필요. client는 언제나 존재함.
    this.client.send(msg);
  }
}
```


### 2.3.2. 수동 DI와 프레임워크(Guice 등)의 활용

의존성 주입을 위해 반드시 거창한 프레임워크가 필요한 것은 아닙니다. 작은 규모의 프로젝트나 간단한 경우에는 **수동 DI(Manual DI)** , 즉 직접 생성자에 인자를 넣어주는 방식이 가장 명확하고 좋습니다. 이를 'Pure DI'라고도 합니다.

하지만 프로젝트 규모가 커지고 의존성 그래프가 복잡해지면, 객체 생성 코드가 너무 방대해집니다. 이때 DI 프레임워크(Java의 Guice, TypeScript의 InversifyJS, NestJS의 DI 시스템 등)를 활용하면 객체의 생성과 연결을 자동화할 수 있습니다.

중요한 점은 **비즈니스 로직 코드에 DI 프레임워크의 흔적을 남기지 않는 것** 입니다. 클래스는 `@Inject` 같은 데코레이터 외에는 프레임워크에 대해 몰라야 하며, 단순히 인터페이스에 의존해야 합니다. 그래야 나중에 프레임워크를 걷어내거나 테스트 시 수동으로 Mock을 주입하기 쉽습니다.


#### [TypeScript(NestJS) 예시]

```typescript
// 프레임워크를 사용하더라도 클래스 자체는 POJO(Plain Old Java/JS Object) 형태를 유지
@Injectable()
export class ProductService {
  // 생성자 주입을 사용하면, NestJS가 없어도 테스트 코드에서 new ProductService(mockRepo)로 사용 가능
  constructor(private repo: ProductRepository) {}
}
```


### 2.3.3. 정적(Static) 메서드가 테스트 용이성을 해치는 이유

정적 메서드(Static Method)는 절차지향적 프로그래밍의 유산입니다. 유틸리티 함수(`Math.abs()` 등)와 같이 상태가 없고(Stateless) 부작용(Side-effect)이 없는 순수 함수라면 정적 메서드로 사용해도 무방합니다. 하지만 **비즈니스 로직이나 외부 시스템과 상호작용하는 코드를 정적 메서드로 만들면 테스트 용이성에 치명적** 입니다.

정적 메서드는 런타임에 교체할 수 있는 방법(Polymorphism)이 없습니다. 클래스 A가 `StaticClass.doSomething()`을 호출하고 있다면, 테스트 시 `doSomething`을 가짜 동작으로 바꿔치기(Mocking)하는 것이 매우 어렵습니다(별도의 복잡한 도구 필요). 이는 객체지향의 핵심인 '다형성'을 포기하는 것과 같습니다.


#### [문제 상황: 정적 메서드에 대한 강한 의존]

```typescript
// Bad Case
class Logger {
  static log(msg: string) {
    // 파일 시스템이나 네트워크에 로그 전송 (테스트 시 곤란함)
    console.log(`[Real Logger] ${msg}`);
  }
}

class PaymentService {
  process() {
    // 정적 메서드 직접 호출. Mocking 불가.
    // 테스트 실행 시마다 콘솔에 로그가 찍히거나 실제 로깅 서버로 요청이 감.
    Logger.log('Payment processed');
  }
}
```


#### [해결 과정: 인스턴스 메서드로 전환]

정적 메서드를 인스턴스 메서드로 바꾸고, 인터페이스를 통해 의존성을 주입받도록 리팩토링합니다.

```typescript
// Good Case
interface ILogger {
  log(msg: string): void;
}

class ConsoleLogger implements ILogger {
  log(msg: string) { console.log(msg); }
}

class PaymentService {
  constructor(private logger: ILogger) {}

  process() {
    this.logger.log('Payment processed');
  }
}

// 테스트
const mockLogger = { log: jest.fn() }; // Mocking 가능
const service = new PaymentService(mockLogger);
service.process();
expect(mockLogger.log).toHaveBeenCalled();
```

---


## 2.4. 코드 리팩토링과 정리


### 2.4.1. YAGNI(You Aren't Gonna Need It) 원칙과 죽은 코드 제거

개발자는 미래를 예측하려는 본능이 있습니다. "나중에 이런 기능이 필요할지도 몰라"라며 현재 필요하지 않은 추상화 계층을 추가하거나 유틸리티 함수를 미리 만들어둡니다. 하지만 YAGNI 원칙에 따르면, **"지금 당장 필요하지 않다면 만들지 말아야"** 합니다.

미래를 대비한 코드는 현재의 복잡도를 높이고, 테스트해야 할 범위를 늘리며, 정작 그 미래가 왔을 때는 요구사항이 달라져 쓸모없게 되는 경우가 많습니다. 더 나아가, 사용되지 않는 코드(Dead Code)는 코드베이스에 남아 유지보수 비용을 발생시킵니다. 개발자는 이 코드가 중요한 로직인지 알 수 없어 삭제를 주저하게 되고, 이는 시스템의 엔트로피를 높입니다. 사용되지 않는 코드는 과감하게 삭제해야 합니다. 버전 관리 시스템(Git)이 있으니까요.


#### [문제 상황: 과도한 조기 추상화]

중복 코드가 보인다고 해서 무조건 추상화(DRY)하는 것이 항상 정답은 아닙니다. 두 코드가 우연히 비슷하게 생겼지만 변경되는 이유가 다르다면, 섣불리 합치는 것보다 중복을 허용하는 것이 낫습니다.

```typescript
// Bad Case: 과도한 조기 추상화
// 두 개의 비슷한 기능을 발견하고 성급하게 추상화함

// "사용자 알림"과 "관리자 알림"이 현재는 비슷하지만, 미래에는 다르게 발전할 수 있음
interface NotificationOptions {
  type: 'user' | 'admin';
  title: string;
  message: string;
  priority?: 'low' | 'medium' | 'high';
  channels?: ('email' | 'sms' | 'push')[];
  adminLevel?: number; // admin 전용이지만 공통 인터페이스에 포함됨
  userSegment?: string; // user 전용이지만 공통 인터페이스에 포함됨
}

// 복잡한 추상화로 인해 테스트도 어려워짐
class NotificationService {
  send(options: NotificationOptions) {
    // type에 따라 분기하는 복잡한 로직
    if (options.type === 'admin') {
      if (!options.adminLevel) throw new Error('Admin level required');
      // 관리자 로직
    } else {
      if (!options.userSegment) throw new Error('User segment required');
      // 사용자 로직
    }
    // 실제로는 두 로직이 거의 공유되지 않음에도 억지로 합쳐놓음
  }
}
```

위 코드는 '미래를 대비'하기 위해 너무 많은 옵션을 추가하여 복잡도만 높였습니다.


#### [해결 과정: 필요할 때 추상화하기]

**"Rule of Three"**: 동일한 패턴이 세 번 반복될 때까지 기다렸다가 추상화하는 것이 좋은 경험 법칙입니다.

```typescript
// Good Case: 단순하고 독립적인 구현
class UserNotificationService {
  sendToUser(title: string, message: string, segment: string) {
    // 사용자 알림 전용 로직
    // 필요한 매개변수만 명확하게 받음
    const payload = { title, message, segment, timestamp: Date.now() };
    return this.emailClient.send(payload);
  }
}

class AdminNotificationService {
  sendToAdmin(title: string, message: string, adminLevel: number) {
    // 관리자 알림 전용 로직
    // 관리자 전용 요구사항이 추가되어도 UserNotification에 영향 없음
    const payload = { title, message, adminLevel, urgent: adminLevel > 5 };
    return this.slackClient.send(payload);
  }
}

// 두 서비스는 독립적으로 진화할 수 있음
// 공통점이 많아지면 그때 가서 Base 클래스를 추출해도 늦지 않음
```

이제 각 서비스는 자신의 책임만 가지며, 테스트도 훨씬 간단해집니다.


#### [실무 적용: 죽은 코드 발견 및 제거 도구]

사용되지 않는 코드를 발견하고 제거하기 위한 도구들:

```typescript
// 1. TypeScript의 'noUnusedLocals'와 'noUnusedParameters' 설정 활용
// tsconfig.json
{
  "compilerOptions": {
    "noUnusedLocals": true,        // 사용하지 않는 지역 변수 경고
    "noUnusedParameters": true     // 사용하지 않는 매개변수 경고
  }
}

// 2. ESLint 규칙 활용
// .eslintrc.js
module.exports = {
  rules: {
    'no-unused-vars': ['error', {
      argsIgnorePattern: '^_',  // _로 시작하는 매개변수는 무시 (의도적 미사용)
      varsIgnorePattern: '^_'
    }],
  }
};

// 3. 번들 분석 도구로 미사용 코드 탐지
// webpack.config.js
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  optimization: {
    usedExports: true,  // Tree shaking 활성화
  },
  plugins: [
    new BundleAnalyzerPlugin()  // 번들에 포함된 코드 시각화
  ]
};
```

**실제 사례:** 구글의 한 팀은 Sensenmann과 유사한 자동화 시스템을 도입하여 6개월간 **50만 라인의 죽은 코드를 삭제**했고, 빌드 시간이 **30% 단축**되었습니다. 웹 프로젝트에서도 `depcheck`, `npm-prune`, `ts-prune`과 같은 도구를 주기적으로 실행하여 미사용 패키지와 export를 정리하는 것이 좋습니다.

```bash
# 미사용 의존성 찾기
npx depcheck

# 미사용 TypeScript exports 찾기
npx ts-prune

# 사용하지 않는 npm 패키지 제거
npm prune
```

필요성이 확실해질 때까지 기다렸다가 리팩토링하는 것이 훨씬 경제적입니다.


### 2.4.2. 코드 크러프트(Cruft) 청소: 보이스카웃 규칙 적용

'코드 크러프트(Code Cruft)'는 코드베이스에 쌓이는 기술적 부채, 낡은 주석, 사용되지 않는 변수, 복잡한 로직 등의 찌꺼기를 의미합니다. 이를 한 번에 대청소하려고 하면 일정에 쫓겨 실패하기 쉽습니다.

대신 **보이스카웃 규칙(Boy Scout Rule)** 을 적용해야 합니다. "머물렀던 자리를 왔을 때보다 더 깨끗하게 치우고 떠나라"는 원칙입니다. 기능을 수정하거나 버그를 고칠 때, 그 주변의 코드를 아주 조금만 더 깨끗하게 만드세요. 변수 이름을 명확하게 바꾸거나, 긴 함수를 쪼개거나, 오타를 수정하는 작은 행동들이 모여 시스템 전체의 건강(Code Health)을 유지합니다.


#### [실무 사례: 점진적 개선의 힘]

버그를 수정하러 갔다가 주변 코드도 함께 개선한 실제 사례를 살펴봅시다.

```typescript
// Before: 버그 수정 전 발견한 코드 (Cruft가 쌓인 상태)
function processOrder(o: any) {  // 타입이 any로 정의됨
  // TODO: 나중에 리팩토링 필요 (작성된 지 2년 지난 주석)
  let t = 0;  // 변수명이 불명확
  for (let i = 0; i < o.items.length; i++) {
    const item = o.items[i];
    t = t + item.price * item.quantity;  // 연산자 스타일 불일치
    if (item.discount) {
      t -= item.discount;
    }
  }

  // 사용되지 않는 변수
  const tempVar = 'unused';

  return t;  // 버그 발견: 배송비가 누락됨!
}
```

**보이스카웃 규칙 적용:** 버그를 고치러 왔지만, 주변 코드도 함께 정리합니다.

```typescript
// After: 버그 수정 + 주변 코드 개선
interface OrderItem {
  price: number;
  quantity: number;
  discount?: number;
}

interface Order {
  items: OrderItem[];
  shippingCost: number;
}

function calculateOrderTotal(order: Order): number {
  // 1. 타입 정의로 안전성 확보
  // 2. 함수명을 더 명확하게 변경 (processOrder → calculateOrderTotal)
  // 3. 무의미한 주석 제거

  let subtotal = 0;  // 변수명 개선 (t → subtotal)

  // 4. for 루프를 reduce로 리팩토링하여 가독성 향상
  subtotal = order.items.reduce((sum, item) => {
    const itemTotal = item.price * item.quantity;
    const discountedTotal = item.discount ? itemTotal - item.discount : itemTotal;
    return sum + discountedTotal;
  }, 0);

  // 5. 버그 수정: 배송비 추가
  const total = subtotal + order.shippingCost;

  // 6. 사용되지 않는 변수 제거
  return total;
}
```

**개선 포인트:**

* 원래 목적: 배송비 누락 버그 수정 (1줄 추가)
* 보이스카웃 청소: 타입 추가, 변수명 개선, 주석 제거, 로직 리팩토링
* 추가 시간: 약 5분
* 효과: 다음 개발자가 이 코드를 수정할 때 이해 시간 10분 절약


#### [Git 커밋 전략: 개선 사항 분리]

보이스카웃 규칙을 적용할 때는 커밋을 분리하는 것이 좋습니다.

```bash
# 1단계 커밋: 리팩토링 (기능 변경 없음)
git add -p  # 리팩토링 부분만 선택
git commit -m "refactor: improve calculateOrderTotal readability

- Add TypeScript interfaces for type safety
- Rename variables for clarity (t → subtotal)
- Remove unused code and outdated comments
- Refactor loop to functional style"

# 2단계 커밋: 버그 수정
git add -p  # 버그 수정 부분만 선택
git commit -m "fix: add missing shipping cost to order total

Previously, calculateOrderTotal did not include shipping cost,
resulting in incorrect invoice amounts.

Fixes #1234"
```

이렇게 분리하면 코드 리뷰어가 "무엇이 버그 수정이고 무엇이 리팩토링인지" 명확히 이해할 수 있습니다.


#### [Pre-commit Hook으로 자동화]

보이스카웃 규칙의 일부를 자동화할 수 있습니다.

```javascript
// .husky/pre-commit 또는 package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",           // 자동으로 코드 스타일 수정
      "prettier --write",       // 포매팅 통일
      "git add"
    ]
  }
}
```

이 설정은 커밋할 때마다 자동으로:

* 사용되지 않는 import 제거
* 일관된 들여쓰기 적용
* 세미콜론, 따옴표 스타일 통일

등을 수행하여 개발자가 신경 쓰지 않아도 코드가 깨끗해집니다.

**핵심 원칙:** "코드베이스를 대청소하려는 욕심보다는, 매일매일 조금씩 청소하는 습관이 지속 가능한 품질을 만든다."


### 2.4.3. 대규모 코드 삭제 시스템 (Sensenmann 프로젝트)

구글은 수십억 라인의 코드를 관리하는 거대한 모노레포(Monorepo)를 운영합니다. 이곳에서 죽은 코드(Dead Code)는 엄청난 빌드 시간과 리소스를 잡아먹는 괴물입니다. 이를 해결하기 위해 구글은 **'Sensenmann(독일어로 '저승사자')'** 라는 프로젝트를 운영합니다.

이 시스템은 자동으로 코드베이스를 분석하여 더 이상 사용되지 않는 라이브러리나 테스트를 찾아내고, 이를 삭제하는 코드 변경(CL)을 자동으로 생성하여 개발자에게 리뷰를 요청합니다. 사람이 일일이 찾아서 지우기에는 너무 방대하기 때문에, 자동화된 도구를 통해 코드의 '다이어트'를 지속적으로 수행하는 것입니다.

웹 프로젝트에서도 ESLint의 `no-unused-vars` 규칙이나, Webpack/Rollup의 Tree Shaking 기능을 활용하여 번들 사이즈를 줄이는 것이 Sensenmann의 정신을 따르는 것입니다. 사용하지 않는 코드는 단순히 지저분한 것을 넘어, 사용자에게 전송되는 파일 크기를 늘려 성능을 저하시키는 직접적인 원인이 됩니다.


# 3장. 단위 테스트(Unit Testing)의 정석


## 3.1. 좋은 단위 테스트의 속성


### 3.1.1. 테스트는 명확하고, 완전하며, 간결해야 한다 (DAMP vs DRY)

소프트웨어 개발에서 중복을 제거하는 DRY(Don't Repeat Yourself) 원칙은 널리 알려져 있습니다. 하지만 테스트 코드에서는 이 원칙을 기계적으로 적용해서는 안 됩니다. 오히려 테스트 코드는 **DAMP(Descriptive And Meaningful Phrases)** 원칙을 따라야 합니다. 즉, 다소 중복이 발생하더라도 **명확하고(Descriptive) 의미 있는(Meaningful)** 코드가 되어야 합니다.

테스트 코드는 제품 코드와 달리 복잡한 로직을 포함해서는 안 되며, 그 자체로 **명세서(Documentation)** 역할을 해야 합니다. 테스트를 읽는 사람이 `setUp` 메서드나 헬퍼 함수를 이리저리 따라가며 "이 테스트 데이터가 어디서 왔지?"를 고민하게 해서는 안 됩니다. 테스트 본문(Body) 안에 **준비(Arrange), 실행(Act), 검증(Assert)** 의 모든 맥락이 드러나는 것이 이상적입니다.


#### [문제 상황: 과도한 DRY로 인해 가독성이 떨어진 테스트]

아래 테스트는 중복을 줄이기 위해 `beforeEach`에서 모든 데이터를 설정하고 있습니다. 하지만 `should activate user` 테스트를 읽을 때, `testUser`가 어떤 상태인지 알기 위해 위로 스크롤해야 하며, `activeUser`라는 변수가 테스트와 어떤 관련이 있는지 파악하기 어렵습니다.

```typescript
// Bad Case: DRY 원칙의 오남용
describe('UserService', () => {
  let service: UserService;
  let testUser: User;
  
  // 모든 테스트가 공유하는 거대한 설정
  beforeEach(() => {
    service = new UserService();
    testUser = { id: '1', status: 'inactive', name: 'Test', email: 'test@test.com' };
  });

  it('should activate user', () => {
    // testUser가 초기화된 상태를 기억해야 함
    service.activate(testUser);
    expect(testUser.status).toBe('active');
  });
  
  it('should update email', () => {
     service.updateEmail(testUser, 'new@test.com');
     expect(testUser.email).toBe('new@test.com');
  });
});
```


#### [해결 과정: DAMP 원칙을 적용하여 명확성 확보]

테스트 데이터 생성 로직이 중복되더라도, 각 테스트 함수 내에서 데이터를 명시적으로 생성하거나 빌더 패턴을 사용하여 테스트의 의도를 드러냅니다.

```typescript
// Good Case: DAMP 원칙 적용 (각 테스트가 독립적이고 명확함)

// 헬퍼 함수: 필요한 데이터만 덮어쓸 수 있도록 하여 간결성 유지
const createUser = (overrides?: Partial<User>): User => ({
  id: '1', status: 'inactive', name: 'Test', email: 'test@test.com',
  ...overrides
});

describe('UserService', () => {
  it('should activate user', () => {
    // Arrange: 테스트에 필요한 상태(inactive)를 명시적으로 드러냄
    const user = createUser({ status: 'inactive' });
    const service = new UserService();

    // Act
    service.activate(user);

    // Assert
    expect(user.status).toBe('active');
  });

  it('should update email', () => {
    const user = createUser({ email: 'old@test.com' });
    const service = new UserService();

    service.updateEmail(user, 'new@test.com');

    expect(user.email).toBe('new@test.com');
  });
});
```

이제 각 테스트는 독립적이며, 읽는 즉시 어떤 상태에서 무엇을 검증하는지 완벽하게 이해할 수 있습니다.


### 3.1.2. 테스트 이름 짓기: 시나리오와 기대 결과를 포함하라

테스트 함수의 이름은 실패 리포트에서 가장 먼저 보게 되는 정보입니다. `test1`, `checkUser`, `authTest`와 같이 모호한 이름은 테스트가 실패했을 때 무엇이 문제인지 전혀 알려주지 않습니다. 좋은 테스트 이름은 **테스트 대상(Unit), 상황/조건(Scenario), 기대 결과(Expected Outcome)** 를 포함해야 합니다.

널리 쓰이는 패턴으로는 `test[MethodName]_[Scenario]_[ExpectedBehavior]` 또는 BDD 스타일의 `it('should [ExpectedBehavior] when [Scenario]')`가 있습니다. 이름이 길어지는 것을 두려워하지 마세요. 테스트 이름은 문장처럼 읽혀야 합니다.


#### [문제 상황: 정보가 없는 테스트 이름]

```typescript
// Bad Case
describe('LoginComponent', () => {
  // 무엇을 테스트하는지, 실패 시 원인이 무엇인지 알 수 없음
  it('test login', () => { ... });
  
  // 실패 메시지: "LoginComponent > handle error" (어떤 에러? 어떻게 처리?)
  it('handle error', () => { ... });
});
```


#### [해결 과정: 명확한 네이밍 패턴 적용]

```typescript
// Good Case
describe('LoginComponent', () => {
  // [기대 결과] when [시나리오]
  it('should display success message when valid credentials are provided', () => { ... });
  
  // 실패 메시지: "LoginComponent > should show error toast when network request fails"
  it('should show error toast when network request fails', () => { ... });
});
```

이렇게 작성하면 테스트가 실패했을 때 코드를 열어보지 않고도 "네트워크 에러 처리 로직에 버그가 있구나"라고 즉시 파악할 수 있습니다.


### 3.1.3. 로직 없는 테스트: 테스트 코드에 조건문과 반복문을 피하라

"테스트 코드를 검증하는 테스트는 누가 작성하나요?"라는 재귀적인 질문에 빠지지 않으려면, **테스트 코드에는 로직(Logic)이 없어야 합니다.** `if` 문, `for` 문, `while` 문, 복잡한 연산 등은 테스트 코드의 복잡도를 높이고 버그를 유발할 수 있습니다.

테스트 코드는 선언적(Declarative)이어야 하며, 단순히 **입력과 기대 출력을 나열**하는 형태여야 합니다. 만약 테스트 내에서 데이터를 가공하거나 흐름을 제어하고 싶다면, 이는 테스트가 너무 복잡하거나 제품 코드의 설계가 잘못되었다는 신호일 수 있습니다.


#### [문제 상황: 로직이 포함된 위험한 테스트]

```typescript
// Bad Case: 테스트 안에 로직이 포함됨
it('should calculate total price', () => {
  const items = [{ price: 100 }, { price: 200 }];
  let expectedTotal = 0;
  
  // 테스트 코드 안에 로직(반복문, 연산)이 있음.
  // 만약 이 로직이 틀렸다면? (예: 부가세 계산 누락)
  for (const item of items) {
    expectedTotal += item.price;
  }

  expect(calculateTotal(items)).toBe(expectedTotal);
});
```

이 테스트는 `calculateTotal` 함수가 단순히 덧셈을 하는지 확인하는 것 같지만, 만약 테스트 코드의 `for` 문에 버그가 있다면 잘못된 검증을 하게 됩니다. 또한 읽는 사람이 `expectedTotal`이 얼마인지 계산해봐야 합니다.


#### [해결 과정: 값을 하드코딩하여 로직 제거]

테스트에서는 계산된 결과값을 명시적으로(Hard-coded) 적는 것이 더 좋습니다. 이는 "이 입력에 대해서는 무조건 이 결과가 나와야 한다"는 명세로서의 가치를 높입니다.

```typescript
// Good Case: 로직 제거 및 명시적 값 사용
it('should calculate total price', () => {
  const items = [{ price: 100 }, { price: 200 }];
  
  // 기대값을 명시적으로 작성. (100 + 200 = 300)
  // 복잡한 계산이 필요 없다.
  expect(calculateTotal(items)).toBe(300);
});
```

---


## 3.2. 테스트 더블(Test Doubles)의 활용

테스트 더블(Test Double)은 영화 촬영의 '스턴트 대역(Stunt Double)'에서 유래한 용어로, 실제 객체 대신 테스트에 사용되는 모든 가짜 객체를 통칭합니다. 각 더블은 목적에 따라 구분해서 사용해야 합니다.


### 3.2.1. Mock, Stub, Fake, Dummy, Spy의 정의와 차이점

테스트 더블은 목적에 따라 다섯 가지로 분류됩니다. 각각의 특성을 이해하고 적절히 사용하는 것이 테스트 품질의 핵심입니다.


#### 1. **Dummy** - 채우기용 객체

**정의:** 실제로 사용되지 않지만 매개변수 목록을 채우기 위해 전달되는 객체입니다. 호출되지 않을 것으로 예상되므로 아무 동작도 하지 않습니다.

```typescript
// Dummy 예제: 사용하지 않는 매개변수를 채우기 위한 용도
interface Logger {
  log(message: string): void;
}

class PaymentProcessor {
  constructor(
    private gateway: PaymentGateway,
    private logger: Logger  // 이 테스트에서는 로깅 기능이 중요하지 않음
  ) {}

  process(amount: number): boolean {
    return this.gateway.charge(amount) === 'success';
  }
}

it('should process payment successfully', () => {
  const gateway = new FakePaymentGateway();

  // Dummy: 실제로 호출되지 않지만, 생성자 매개변수 채우기 위해 필요
  const dummyLogger: Logger = {
    log: () => { /* do nothing */ }
  };

  const processor = new PaymentProcessor(gateway, dummyLogger);
  expect(processor.process(100)).toBe(true);
});
```


#### 2. **Stub** - 미리 준비된 답변을 주는 객체

**정의:** 테스트 중 호출되었을 때 미리 준비된(Canned) 값을 반환하는 객체입니다. 실제 로직은 없고 단순히 원하는 상태를 시뮬레이션합니다.

```typescript
// Stub 예제: 외부 API 응답을 하드코딩된 값으로 대체
interface WeatherApi {
  getCurrentTemperature(city: string): Promise<number>;
}

class TemperatureDisplay {
  constructor(private api: WeatherApi) {}

  async showWarning(city: string): Promise<string> {
    const temp = await this.api.getCurrentTemperature(city);
    return temp > 35 ? '폭염 주의!' : '정상';
  }
}

it('should show heatwave warning when temperature is above 35', async () => {
  // Stub: 항상 36도를 반환하도록 설정
  const stubApi: WeatherApi = {
    getCurrentTemperature: async () => 36
  };

  const display = new TemperatureDisplay(stubApi);
  const warning = await display.showWarning('Seoul');

  expect(warning).toBe('폭염 주의!');
});
```

**Stub의 장점:** 외부 시스템(네트워크, 데이터베이스)에 의존하지 않고 빠르고 결정적인 테스트 작성 가능.


#### 3. **Spy** - 몰래 정보를 기록하는 객체

**정의:** 실제 객체처럼 동작하면서, 호출된 횟수나 전달된 인자 등의 정보를 몰래 기록해두는 객체입니다. 테스트 후 이 정보를 검증합니다.

```typescript
// Spy 예제: 이메일 전송 횟수와 내용을 확인
interface EmailService {
  send(to: string, subject: string, body: string): void;
}

class UserRegistration {
  constructor(private emailService: EmailService) {}

  register(email: string) {
    // 사용자 등록 로직...
    this.emailService.send(email, 'Welcome!', 'Thanks for signing up.');
  }
}

it('should send welcome email upon registration', () => {
  // Spy: 실제 동작하지만 호출 정보를 기록
  let callCount = 0;
  let sentTo = '';
  let sentSubject = '';

  const spyEmailService: EmailService = {
    send: (to, subject, body) => {
      callCount++;
      sentTo = to;
      sentSubject = subject;
      // 실제로 이메일을 보내지는 않음
    }
  };

  const registration = new UserRegistration(spyEmailService);
  registration.register('user@example.com');

  // 호출 여부와 인자를 검증
  expect(callCount).toBe(1);
  expect(sentTo).toBe('user@example.com');
  expect(sentSubject).toBe('Welcome!');
});

// Jest를 사용한 Spy (더 간편함)
it('should send welcome email (using Jest spy)', () => {
  const emailService = {
    send: jest.fn()  // Jest의 spy 함수
  };

  const registration = new UserRegistration(emailService);
  registration.register('user@example.com');

  expect(emailService.send).toHaveBeenCalledTimes(1);
  expect(emailService.send).toHaveBeenCalledWith(
    'user@example.com',
    'Welcome!',
    'Thanks for signing up.'
  );
});
```


#### 4. **Mock** - 행위 명세를 강제하는 객체

**정의:** "이 함수가 이 인자로 호출되어야 한다"는 행위(Behavior) 명세를 미리 정의해두고, 그대로 호출되지 않으면 테스트를 실패시키는 객체입니다.

```typescript
// Mock 예제: 정확한 호출 순서와 인자를 강제
interface AuditLog {
  record(event: string, details: any): void;
}

class CriticalOperation {
  constructor(private audit: AuditLog) {}

  execute() {
    this.audit.record('START', { timestamp: Date.now() });
    // ... 중요한 작업 수행
    this.audit.record('END', { success: true });
  }
}

it('should record audit log in correct order', () => {
  // Mock: 정확한 호출 순서와 인자를 검증
  const mockAudit = {
    record: jest.fn()
  };

  const operation = new CriticalOperation(mockAudit);
  operation.execute();

  // 정확히 2번 호출되었는가?
  expect(mockAudit.record).toHaveBeenCalledTimes(2);

  // 첫 번째 호출이 'START'인가?
  expect(mockAudit.record).toHaveBeenNthCalledWith(
    1, 'START', expect.any(Object)
  );

  // 두 번째 호출이 'END'인가?
  expect(mockAudit.record).toHaveBeenNthCalledWith(
    2, 'END', { success: true }
  );
});
```

**주의:** Mock은 구현 세부 사항에 결합될 위험이 있으므로 신중히 사용해야 합니다. (3.2.2 참조)


#### 5. **Fake** - 실제로 동작하는 단순화된 구현

**정의:** 실제 동작하는 구현체를 가지지만, 프로덕션에는 적합하지 않은 단순화된 버전입니다. (예: 인메모리 데이터베이스)

```typescript
// Fake 예제: 인메모리 데이터베이스로 실제 DB 대체
interface UserRepository {
  save(user: User): void;
  findById(id: string): User | null;
}

// 프로덕션: 실제 PostgreSQL 사용
class PostgresUserRepository implements UserRepository {
  save(user: User) { /* SQL 쿼리 실행 */ }
  findById(id: string) { /* SELECT 쿼리 */ return null; }
}

// 테스트: 인메모리 Fake 구현
class FakeUserRepository implements UserRepository {
  private users = new Map<string, User>();

  save(user: User) {
    this.users.set(user.id, user);
  }

  findById(id: string) {
    return this.users.get(id) || null;
  }
}

it('should save and retrieve user', () => {
  // Fake: 실제로 동작하지만 메모리에만 저장
  const repo = new FakeUserRepository();
  const user = { id: '1', name: 'Alice' };

  repo.save(user);
  const retrieved = repo.findById('1');

  expect(retrieved).toEqual(user);
});
```

**Fake의 장점:** Mock이나 Stub보다 실제 동작에 가깝기 때문에 테스트 신뢰도가 높고, 리팩토링에 강합니다. (3.2.3 참조)

---


#### 언제 무엇을 사용할 것인가? (결정 가이드)

| 상황 | 권장 테스트 더블 |
|------|----------------|
| 사용하지 않는 매개변수를 채워야 할 때 | **Dummy** |
| 외부 API/DB의 응답을 통제하고 싶을 때 | **Stub** |
| 함수가 호출되었는지 확인만 하면 될 때 | **Spy** |
| 호출 순서나 정확한 인자 검증이 중요할 때 | **Mock** (신중히) |
| 실제 동작을 유지하면서 빠르게 테스트하고 싶을 때 | **Fake** (최우선 권장) |

**구글의 권장사항:** Fake > Stub > Spy > Mock 순으로 선호. Mock은 최후의 수단으로만 사용.


### 3.2.2. Mock의 남용 금지: 상태 테스트 vs 행위 테스트

단위 테스트는 크게 **상태 기반 테스트(State-based Testing)** 와 **행위 기반 테스트(Interaction-based Testing)** 로 나뉩니다.

* **상태 기반**: 함수 실행 후의 결과값이나 객체의 상태를 검증합니다. (선호됨)
* **행위 기반**: 함수가 내부적으로 특정 함수를 호출했는지 Mock을 통해 검증합니다.

구글은 **Mock의 남용을 경계**합니다. Mock을 과도하게 사용하면 테스트가 **구현 세부 사항(Implementation Detail)에 결합**되기 때문입니다. 예를 들어, "데이터를 저장한다"는 기능을 테스트할 때, `save()` 메서드가 호출되었는지(행위)를 검증하는 것보다, 실제로 데이터베이스(Fake)에 데이터가 들어갔는지(상태)를 검증하는 것이 훨씬 강력하고 리팩토링에 유연합니다.


#### [문제 상황: Mock 남용으로 인한 깨지기 쉬운 테스트]

```typescript
// Bad Case: 구현 상세에 집착하는 행위 테스트
it('should save user', () => {
  const mockDb = { save: jest.fn() };
  const service = new UserService(mockDb);
  
  service.register('Alice');
  
  // save가 호출되었는지만 확인. 
  // 만약 구현이 save() 대신 insert()를 호출하도록 바뀌면?
  // 기능은 여전히 '저장'이지만 테스트는 실패함. (False Positive)
  expect(mockDb.save).toHaveBeenCalledWith('Alice');
});
```


### 3.2.3. Fake를 활용한 테스트 신뢰성 및 속도 향상

가장 이상적인 테스트 더블은 **Fake**입니다. Fake는 실제 로직과 유사하게 동작하므로 상태 기반 테스트를 가능하게 하며, 인메모리에서 동작하므로 매우 빠릅니다. Mock은 "어떻게 호출되는가"를 검증하지만, Fake는 "결과가 무엇인가"를 검증할 수 있게 해 줍니다.


#### [해결 과정: Fake를 활용한 상태 기반 테스트]

```typescript
// Good Case: Fake를 활용한 상태 테스트
class FakeDatabase implements Database {
  private users: string[] = [];
  
  async save(user: string) { this.users.push(user); }
  async findAll() { return this.users; }
}

it('should save user', async () => {
  const fakeDb = new FakeDatabase();
  const service = new UserService(fakeDb);
  
  await service.register('Alice');
  
  // 구현 방식(save 호출 여부)이 아니라 결과 상태(DB에 있는지)를 검증
  const users = await fakeDb.findAll();
  expect(users).toContain('Alice');
});
```

이 테스트는 `UserService`가 내부적으로 `save`를 쓰든, `insert`를 쓰든, 캐시를 먼저 쓰든 상관없이 "사용자가 저장되었는가?"라는 핵심 가치를 검증합니다.

---


## 3.3. 검증(Assertion)과 에러 메시지


### 3.3.1. 테스트 실패는 실행 가능(Actionable)해야 한다

테스트가 실패했을 때, 개발자는 실패 메시지만 보고도 즉시 문제를 파악하고 수정에 착수할 수 있어야 합니다. 이를 **Actionable Failure**라고 합니다. 만약 테스트가 실패했는데 "왜 실패했지?"라며 디버거를 켜야 한다면, 그 테스트는 실패 메시지가 불친절한 것입니다.

나쁜 실패 메시지: `Expected true to be false`
좋은 실패 메시지: `User 'Alice' should be activated, but status is 'inactive'`


### 3.3.2. 좁은 검증(Narrow Assertion) 선호: 필요한 것만 확인하라

너무 넓은 범위의 검증(Broad Assertion)은 테스트를 깨지기 쉽게 만듭니다. 예를 들어, 함수가 반환하는 거대한 객체 전체를 `toEqual`로 비교하면, 테스트와 관련 없는 필드가 하나만 추가되어도 테스트가 실패합니다. 테스트의 의도와 관련된 **핵심 필드만 콕 집어서 검증(Narrow Assertion)** 해야 합니다.


#### [문제 상황: 과도한 전체 비교]

```typescript
// Bad Case: 불필요하게 엄격한 검증
it('should return user info', () => {
  const user = getUser('1');
  // createdAt이나 lastLogin 같은 동적인 필드가 조금만 바뀌어도 실패함
  expect(user).toEqual({
    id: '1',
    name: 'Alice',
    createdAt: '2023-01-01T00:00:00Z', // 테스트와 무관한 필드
    role: 'user'
  });
});
```


#### [해결 과정: 필요한 부분만 검증]

```typescript
// Good Case: 관심 있는 필드만 검증
it('should return user info', () => {
  const user = getUser('1');
  
  // 객체의 부분 매칭(subset matching) 활용
  expect(user).toMatchObject({
    id: '1',
    name: 'Alice'
  });
  // 또는 개별 필드 검증
  expect(user.name).toBe('Alice');
});
```


### 3.3.3. 유창한 검증(Fluent Assertion) 라이브러리 활용 (Truth 등)

가독성을 높이고 Actionable한 에러 메시지를 얻기 위해, 언어의 문법과 유사하게 읽히는 **유창한 검증(Fluent Assertion)** 라이브러리를 사용하는 것이 좋습니다. Java의 `Truth`나 `AssertJ`, JavaScript/TypeScript의 `Chai`나 `Jest`의 `expect` API가 여기에 해당합니다.

이러한 라이브러리들은 단순히 `true/false`를 확인하는 것을 넘어, 컬렉션의 포함 여부, 문자열 패턴 매칭 등을 직관적인 문장 형태로 작성할 수 있게 해주며, 실패 시 "A와 B가 다름" 뿐만 아니라 "어느 부분이 어떻게 다른지" 상세한 정보를 제공합니다.

```typescript
// Jest의 Fluent API 활용 예시
const colors = ['red', 'green', 'blue'];

// Bad (JUnit 스타일)
// 실패 시 메시지: "Expected false to be true" (정보 없음)
expect(colors.includes('yellow')).toBeTruthy();

// Good (Fluent 스타일)
// 실패 시 메시지: "Expected array to contain 'yellow' but found ['red', 'green', 'blue']"
expect(colors).toContain('yellow');
```


# 4장. 통합 및 시스템 테스트 전략


## 4.1. 테스트 피라미드와 크기 분류


### 4.1.1. 소형(Small), 중형(Medium), 대형(Large) 테스트의 정의

구글은 테스트를 '단위(Unit)', '통합(Integration)', '시스템(System)'이라는 모호한 용어 대신, 시스템 자원의 사용 범위와 격리 수준을 기준으로 **소형(Small)**, **중형(Medium)**, **대형(Large)** 으로 명확하게 분류합니다. 이 분류 체계는 테스트의 속도와 결정성(Determinism)을 보장하는 핵심 기준이 됩니다.

1. **소형 테스트 (Small Test)**:
    * **특징**: 단일 프로세스 내에서 실행되며, 외부 시스템(네트워크, DB, 파일 시스템 등)에 접근하지 않습니다. 모든 외부 의존성은 Mock이나 Fake로 대체됩니다.
    * **장점**: 실행 속도가 매우 빠르고(밀리초 단위), 외부 요인에 의한 실패(Flakiness)가 없습니다.
    * **용도**: 단위 테스트에 해당하며, 비즈니스 로직 검증에 사용됩니다.

2. **중형 테스트 (Medium Test)**:
    * **특징**: 여러 모듈 간의 상호작용을 검증합니다. 로컬 머신 내의 파일 시스템이나 로컬 데이터베이스 정도는 접근할 수 있지만, 외부 네트워크 호출은 여전히 제한적입니다(localhost 통신은 허용).
    * **장점**: 모듈 간의 계약(Contract)이 올바른지 확인할 수 있습니다.
    * **용도**: 통합 테스트에 해당하며, 프론트엔드와 백엔드 간의 API 스펙 검증 등에 사용됩니다.

3. **대형 테스트 (Large Test)**:
    * **특징**: 실제 프로덕션 환경과 유사하게 네트워크, 데이터베이스, 외부 API 등을 모두 사용합니다.
    * **장점**: 전체 시스템이 유기적으로 동작하는지 최종 검증할 수 있습니다.
    * **단점**: 실행 속도가 느리고, 네트워크 상태 등에 따라 결과가 달라질 수 있어 불안정(Flaky)합니다.
    * **용도**: E2E(End-to-End) 테스트에 해당합니다.


#### [웹 개발에서의 적용 예시]

* **Small**: React 컴포넌트를 렌더링하고 버튼 클릭 시 상태 변화를 검증 (Jest + React Testing Library). API 호출은 Mocking.
* **Medium**: 실제 브라우저 환경에서 여러 페이지 간의 라우팅을 테스트하거나, 로컬에 띄운 Mock 서버와 통신 (Cypress + Mock API).
* **Large**: 실제 배포된 스테이징 서버와 통신하며 로그인부터 결제까지 전체 시나리오 검증 (Playwright + Real API).


### 4.1.2. 테스트 모래시계(Hourglass) 패턴과 피라미드 형태 유지하기

이상적인 테스트 분포는 **테스트 피라미드(Test Pyramid)** 형태입니다. 바닥을 지탱하는 **소형 테스트가 가장 많고**, 위로 갈수록(중형, 대형) 그 수가 줄어들어야 합니다. 이는 비용과 속도, 유지보수성 측면에서 가장 효율적인 구조입니다.

하지만 많은 프로젝트가 시간이 지나면서 **모래시계(Hourglass) 패턴**이나 **아이스크림 콘(Inverted Pyramid)** 패턴으로 변질됩니다. 소형 테스트(단위 테스트)는 작성하기 귀찮아서 건너뛰고, "화면에 잘 나오는지 보고 싶다"는 이유로 E2E 테스트(대형 테스트)만 잔뜩 늘리는 경우입니다. 또는 단위 테스트와 E2E 테스트는 많지만, 그 사이를 연결하는 중형 테스트(통합 테스트)가 부재한 모래시계 형태가 되기도 합니다.

모래시계 패턴의 문제점은 E2E 테스트가 너무 느리고 불안정하여 개발 속도를 저하시키는 반면, 단위 테스트만으로는 시스템 간의 연결 고리를 검증하지 못한다는 것입니다. 따라서 의도적으로 중형 테스트의 비중을 늘려 피라미드 형태를 복원해야 합니다.


#### [문제 상황: E2E 테스트에만 의존하는 경우]

쇼핑몰 웹사이트를 개발 중입니다. "장바구니 담기" 기능을 테스트하기 위해 Selenium으로 브라우저를 띄우고, 실제 로그인을 하고, 상품 목록을 로딩하고, 담기 버튼을 누르는 E2E 테스트만 작성했습니다.
이 테스트는 실행하는 데 30초가 걸립니다. 어느 날 네트워크가 불안정하여 로그인이 실패하자, 장바구니 기능은 멀쩡한데도 테스트가 실패합니다. 개발자는 "또 네트워크 문제네" 하고 실패를 무시하기 시작합니다.


#### [해결 과정: 피라미드 구조로 재편]

1. **Small**: 장바구니 담기 로직(가격 계산, 수량 증가)은 단위 테스트로 수백 가지 케이스를 1초 안에 검증합니다.
2. **Medium**: 장바구니 컴포넌트와 로컬 Mock API 서버를 연동하여, 버튼 클릭 시 API 요청이 올바른 형식으로 전송되는지 검증합니다.
3. **Large**: 실제 로그인을 포함한 전체 흐름 테스트는 핵심 시나리오(Happy Path) 딱 하나만 남겨둡니다.


### 4.1.3. E2E(End-to-End) 테스트에 대한 과도한 의존 피하기 ("Just Say No")

구글의 엔지니어 Mike Wacker는 "Just Say No to More End-to-End Tests"라는 글을 통해 E2E 테스트의 맹점을 지적했습니다. E2E 테스트는 사용자 관점의 시나리오를 검증한다는 점에서 매력적이지만, **"피드백 루프가 느리고", "실패 원인을 찾기 어려우며(디버깅 비용)", "불안정(Flaky)하다"** 는 치명적인 단점이 있습니다.

E2E 테스트가 실패했을 때, 그것이 프론트엔드 코드 버그인지, 백엔드 서버 문제인지, 데이터베이스 타임아웃인지, 아니면 단순히 네트워크 지연인지 파악하기가 매우 어렵습니다.

따라서 E2E 테스트는 **"도저히 작은 테스트로는 검증할 수 없는 영역"** 에만 제한적으로 사용해야 합니다. 예를 들어, 브라우저 간의 호환성 문제나, 여러 마이크로서비스가 실제로 통합되었을 때의 설정 문제 등입니다. 비즈니스 로직 검증을 E2E 테스트에 맡기는 것은 비효율의 지름길입니다.

---


## 4.2. 외부 시스템과의 상호작용


### 4.2.1. 외부 API 래핑(Wrapping)과 도메인 객체 활용

웹 애플리케이션은 수많은 외부 API(결제, 지도, 소셜 로그인 등)와 상호작용합니다. 이때 외부 라이브러리나 API 클라이언트를 비즈니스 로직에서 직접 사용하면, 외부 시스템의 변경에 취약해지고 테스트가 어려워집니다.

이를 해결하기 위해 **래퍼(Wrapper) 패턴**을 사용하여 외부 API를 우리 도메인에 맞는 형태로 감싸야 합니다. 외부 API의 복잡한 데이터 구조를 그대로 사용하는 대신, 우리 애플리케이션에 필요한 정보만 담은 **도메인 객체(Domain Object)** 로 변환하여 사용합니다.


#### [문제 상황: 외부 라이브러리에 강하게 결합된 코드]

```typescript
// Bad Case: 외부 결제 라이브러리 직접 사용
import { ThirdPartyPaymentSDK } from 'kakao-pay-sdk';

class OrderService {
  async checkout(amount: number) {
    // 외부 라이브러리의 복잡한 설정과 메서드를 직접 호출
    // 테스트 시 SDK 전체를 Mocking해야 함 (매우 어려움)
    const result = await ThirdPartyPaymentSDK.request({
      cid: 'TC0ONETIME',
      partner_order_id: 'partner_order_id',
      partner_user_id: 'partner_user_id',
      item_name: '초코파이',
      quantity: 1,
      total_amount: amount,
      vat_amount: 200,
      tax_free_amount: 0,
      approval_url: '...',
      fail_url: '...',
      cancel_url: '...'
    });
    return result.tid;
  }
}
```


#### [해결 과정: 래퍼와 도메인 객체 도입]

```typescript
// Good Case: 래퍼(인터페이스)를 통한 추상화

// 우리 도메인에 맞는 단순한 인터페이스 정의
interface PaymentProcessor {
  pay(amount: number, itemName: string): Promise<string>; // transaction ID 반환
}

// 외부 SDK는 이 클래스 안에 격리됨
class KakaoPayAdapter implements PaymentProcessor {
  async pay(amount: number, itemName: string) {
    const result = await ThirdPartyPaymentSDK.request({
      // 복잡한 설정은 여기서 처리
      total_amount: amount,
      item_name: itemName,
      // ... 기타 필수값
    });
    return result.tid;
  }
}

// 비즈니스 로직은 이제 단순한 인터페이스에만 의존
class OrderService {
  constructor(private paymentProcessor: PaymentProcessor) {}

  async checkout(amount: number) {
    return this.paymentProcessor.pay(amount, '초코파이');
  }
}

// 테스트 시: 간단한 Mock 구현체 주입 가능
const mockPaymentProcessor = { pay: async () => 'mock-tid' };
```


### 4.2.2. 소유하지 않은 타입(Types You Don't Own)은 Mock하지 말라

"Don't Mock Types You Don't Own"은 테스트의 유지보수성을 위한 중요한 원칙입니다. 서드파티 라이브러리의 클래스나 타입을 직접 Mocking하는 것은 위험합니다. 라이브러리가 업데이트되어 내부 동작이나 시그니처가 바뀌어도, 우리가 만든 Mock은 그대로이기 때문에 테스트는 성공하지만 실제 런타임에서는 실패하는 **거짓 양성(False Positive)** 이 발생할 수 있습니다.

대신, 앞서 언급한 **래퍼(Wrapper)를 만들고 그 래퍼를 Mocking**해야 합니다. 래퍼는 우리가 소유한 코드이므로 변경 사항을 제어할 수 있습니다.


#### [실무 적용: Axios 모킹 대신 API Client 모킹]

`axios`나 `fetch` 자체를 Mocking하는 것(`jest.mock('axios')`)은 좋지 않습니다. 대신 `ApiClient`라는 래퍼 클래스를 만들고, 비즈니스 로직 테스트에서는 `ApiClient`를 Mocking하세요. 그리고 `ApiClient`가 실제로 `axios`를 잘 호출하는지는 별도의 통합 테스트로 검증하거나, `nock` 같은 도구를 이용해 HTTP 레벨에서 테스트하는 것이 좋습니다.


### 4.2.3. 밀폐된 서버(Hermetic Servers)를 활용한 격리 테스트

통합 테스트나 E2E 테스트에서 외부 시스템(예: 결제 서버, OAuth 제공자)을 실제로 호출하는 것은 테스트의 불안정성을 높입니다. 그렇다고 모든 것을 Mock 객체로 대체하면 실제 통신 과정을 검증할 수 없습니다.

이 딜레마를 해결하는 방법이 **밀폐된 서버(Hermetic Servers)** 입니다. 이는 실제 외부 서버와 동일한 API를 제공하지만, 로컬이나 컨테이너 환경에서 독립적으로 실행되는 가짜 서버입니다. 네트워크 통신을 실제로 수행하되, 그 대상이 통제 가능한 로컬 서버이므로 테스트가 빠르고 결정적입니다.


#### [문제 상황: 외부 API 장애로 인한 테스트 실패]

로그인 기능을 테스트하는데, 구글 로그인 API 서버가 잠시 점검 중이라서 우리 CI가 실패합니다. 내 코드는 잘못이 없는데 배포를 못 하는 상황이 발생합니다.


#### [해결 과정: 로컬 Mock 서버(MSW) 활용]

웹 프론트엔드 개발에서는 **MSW(Mock Service Worker)** 가 훌륭한 밀폐된 서버 역할을 합니다.

```typescript
// mocks/handlers.ts (MSW 핸들러 설정)
import { rest } from 'msw';

export const handlers = [
  rest.post('/api/login', (req, res, ctx) => {
    // 실제 서버처럼 동작하는 가짜 응답 정의
    return res(
      ctx.status(200),
      ctx.json({ token: 'fake-jwt-token', user: { name: 'Test User' } })
    );
  }),
];

// 테스트 코드
it('should login successfully', async () => {
  // 테스트 실행 시 실제 네트워크 요청을 MSW가 가로채서 로컬 핸들러로 처리
  // 외부 서버 상태와 무관하게 항상 성공함
  render(<LoginPage />);
  
  userEvent.click(screen.getByText('Login'));
  
  await waitFor(() => {
    expect(screen.getByText('Welcome, Test User')).toBeInTheDocument();
  });
});
```

이 방식을 사용하면 실제 HTTP 요청을 보내는 클라이언트 코드까지 검증하면서도, 외부 서버의 불안정성으로부터 테스트를 격리할 수 있습니다.

---


## 4.3. 테스트 데이터 관리


### 4.3.1. 테스트 데이터 빌더 패턴 활용하기

테스트를 작성할 때 가장 귀찮은 일 중 하나는 테스트에 필요한 객체(Dummy Data)를 생성하는 것입니다. 필수 필드가 많은 객체를 생성할 때마다 모든 필드를 채워 넣는 것은 코드를 장황하게 만듭니다.

**빌더 패턴(Builder Pattern)** 이나 **팩토리 함수(Factory Function)** 를 활용하면 필요한 데이터만 명시하고 나머지는 기본값으로 채워주는 유연한 데이터 생성이 가능합니다. 이는 DAMP 원칙을 지키면서도 테스트의 가독성을 높여줍니다.


#### [문제 상황: 장황한 데이터 생성 코드]

```typescript
// Bad Case
it('should verify active user', () => {
  // 테스트의 관심사는 'isActive: true' 하나인데, 불필요한 필드까지 모두 작성해야 함
  const user: User = {
    id: '1',
    name: 'Kim',
    email: 'kim@example.com',
    address: 'Seoul',
    phone: '010-0000-0000',
    isActive: true, // 정작 중요한 건 여기
    createdAt: new Date(),
    // ... 더 많은 필드들
  };
  
  expect(isValid(user)).toBe(true);
});
```


#### [해결 과정: 빌더 패턴 적용]

```typescript
// Good Case: 팩토리 함수 활용
const buildUser = (overrides?: Partial<User>): User => ({
  id: '1',
  name: 'Default Name',
  email: 'default@example.com',
  isActive: false, // 기본값
  ...overrides // 필요한 값만 덮어쓰기
});

it('should verify active user', () => {
  // 관심 있는 데이터만 명시. 훨씬 간결하고 의도가 명확함.
  const user = buildUser({ isActive: true });
  
  expect(isValid(user)).toBe(true);
});
```


### 4.3.2. 하드코딩된 값 피하기와 상수 관리

테스트 코드에서 매직 넘버(Magic Number)나 하드코딩된 문자열을 남발하면, 나중에 요구사항이 변경되었을 때 수많은 테스트를 일일이 수정해야 합니다.

특히 여러 테스트에서 공통으로 사용되는 **'의미 있는 값'** 들은 상수로 정의하거나, 프로덕션 코드와 공유할 수 있는 설정 파일로 관리하는 것이 좋습니다.


#### [문제 상황: 매직 넘버가 난무하는 테스트]

```typescript
// Bad Case: 매직 넘버와 하드코딩된 값 남발
describe('VIP Customer Discount', () => {
  it('should apply discount for high spenders', () => {
    const customer = { totalPurchase: 1000000 };  // 100만원 (의미 불명확)
    const discount = calculateDiscount(customer);

    expect(discount).toBe(0.15);  // 15% (왜 15%인지 불명확)
  });

  it('should not apply discount for regular customers', () => {
    const customer = { totalPurchase: 500000 };  // 50만원
    const discount = calculateDiscount(customer);

    expect(discount).toBe(0);
  });

  // 만약 VIP 기준이 100만원에서 200만원으로 변경되면?
  // 여러 테스트를 일일이 수정해야 함
});
```

**문제점:**

* `1000000`이라는 숫자가 무슨 의미인지 즉시 파악 불가
* 할인율 `0.15`가 왜 그 값인지 맥락 없음
* 정책 변경 시 여러 파일의 숫자를 모두 찾아 수정해야 함


#### [해결 과정: 상수화를 통한 유지보수성 확보]

```typescript
// Good Case: 의미 있는 상수로 관리
// test/fixtures/constants.ts
export const TEST_CONSTANTS = {
  VIP_THRESHOLD: 1_000_000,      // 100만원 (언더스코어로 가독성 향상)
  VIP_DISCOUNT_RATE: 0.15,       // 15% 할인
  REGULAR_PURCHASE: 500_000,     // 일반 고객 구매액
} as const;

// product/discount.ts (프로덕션 코드)
export const DISCOUNT_POLICY = {
  VIP_THRESHOLD: 1_000_000,
  VIP_RATE: 0.15,
} as const;

// 테스트 코드
import { TEST_CONSTANTS } from '../fixtures/constants';

describe('VIP Customer Discount', () => {
  it('should apply 15% discount for customers over 1M purchase', () => {
    const customer = { totalPurchase: TEST_CONSTANTS.VIP_THRESHOLD };
    const discount = calculateDiscount(customer);

    // 기대값은 리터럴로 명시 (Stroop Effect 방지)
    expect(discount).toBe(0.15);
  });

  it('should not apply discount for regular customers', () => {
    const customer = { totalPurchase: TEST_CONSTANTS.REGULAR_PURCHASE };
    const discount = calculateDiscount(customer);

    expect(discount).toBe(0);
  });
});
```

**개선 효과:**

* 숫자의 의미가 명확해짐 (`VIP_THRESHOLD`로 의도 전달)
* 정책 변경 시 상수 파일 한 곳만 수정
* 테스트 가독성 향상


#### [The Stroop Effect 주의사항]

단, 프로덕션 코드의 상수를 **단언(Assertion)에 그대로 사용하는 것은 위험**합니다.

```typescript
// Dangerous: Stroop Effect 발생 위험
import { DISCOUNT_POLICY } from '@/product/discount';

it('should return correct VIP rate', () => {
  const rate = getVipRate();

  // 만약 DISCOUNT_POLICY.VIP_RATE가 잘못 0.05로 변경되면?
  // 프로덕션 버그인데 테스트가 통과해버림!
  expect(rate).toBe(DISCOUNT_POLICY.VIP_RATE);  // 나쁜 예
});

// Safe: 기대값을 명시적으로 작성
it('should return 15% VIP rate', () => {
  const rate = getVipRate();

  // 프로덕션 상수가 잘못 변경되면 테스트가 실패하여 버그를 잡아냄
  expect(rate).toBe(0.15);  // 좋은 예
});
```

**원칙:** 입력 데이터 생성에는 상수 사용 가능, 하지만 검증(Assertion)에는 리터럴 값 사용.

---


### 4.3.3. 테스트 간 데이터 격리와 공유 상태 제거

모든 테스트는 독립적으로 실행되어야 하며, 실행 순서에 영향을 받지 않아야 합니다. 이를 위해서는 **공유 상태(Shared State)를 철저히 제거**해야 합니다.

전역 변수에 데이터를 저장하거나, 하나의 데이터베이스를 여러 테스트가 동시에 읽고 쓰게 하면 안 됩니다. 각 테스트는 실행 전에 자신만의 깨끗한 데이터 환경(Fresh Fixture)을 보장받아야 합니다.


#### [문제 상황: 공유 상태로 인한 테스트 간섭]

```typescript
// Bad Case: 전역 변수를 여러 테스트가 공유
let sharedCart = { items: [] };

describe('Shopping Cart (Flaky Tests)', () => {
  it('should add item to cart', () => {
    addToCart(sharedCart, 'Apple');
    expect(sharedCart.items).toHaveLength(1);
  });

  it('should calculate total', () => {
    // 이전 테스트에서 추가된 'Apple'이 남아있을 수 있음!
    // 테스트 실행 순서에 따라 결과가 달라짐 (Flaky)
    expect(sharedCart.items).toHaveLength(0);  // 실패할 수 있음
  });
});
```

**문제점:**

* 첫 번째 테스트가 전역 상태를 변경
* 두 번째 테스트가 깨끗한 상태를 기대했지만 오염된 데이터 발견
* 테스트 순서에 따라 통과/실패가 달라짐 (비결정적)


#### [해결 과정: beforeEach로 상태 초기화]

```typescript
// Good Case: 각 테스트마다 독립적인 상태 보장
describe('Shopping Cart (Isolated Tests)', () => {
  let cart: Cart;

  beforeEach(() => {
    // 각 테스트 실행 전 깨끗한 상태로 초기화
    cart = { items: [] };
  });

  it('should add item to cart', () => {
    addToCart(cart, 'Apple');
    expect(cart.items).toHaveLength(1);
  });

  it('should calculate total', () => {
    // beforeEach로 인해 빈 장바구니에서 시작
    expect(cart.items).toHaveLength(0);  // 항상 통과
  });
});
```


#### [데이터베이스 테스트의 격리 전략]

데이터베이스를 사용하는 통합 테스트에서는 트랜잭션 롤백 패턴이 유용합니다.

```typescript
// 데이터베이스 트랜잭션 격리 (Prisma 예시)
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

describe('User Repository (DB Isolation)', () => {
  beforeEach(async () => {
    // 테스트 전 트랜잭션 시작 (실제로는 프레임워크가 자동 처리)
    await prisma.$connect();
  });

  afterEach(async () => {
    // 테스트 후 롤백하여 DB 상태를 원래대로 복원
    await prisma.$executeRawUnsafe('ROLLBACK');
    // 또는 테스트 데이터 명시적 삭제
    await prisma.user.deleteMany({ where: { email: { contains: 'test' } } });
  });

  it('should save user', async () => {
    const user = await prisma.user.create({
      data: { email: 'test@example.com', name: 'Test' }
    });

    expect(user.id).toBeDefined();
    // 테스트 종료 후 자동으로 롤백되어 DB가 깨끗해짐
  });
});
```

**더 나은 방법: 테스트 전용 DB 사용**

```typescript
// 각 테스트 파일마다 격리된 SQLite 인메모리 DB 사용
beforeAll(async () => {
  process.env.DATABASE_URL = 'file::memory:?cache=shared';
  await prisma.$connect();
  await prisma.$executeRawUnsafe('PRAGMA foreign_keys=ON');
});

afterAll(async () => {
  await prisma.$disconnect();
});

// 이제 각 테스트는 완전히 독립적인 DB 인스턴스를 사용
```


#### [빌더 패턴으로 테스트 데이터 격리]

```typescript
// 각 테스트마다 새로운 데이터 생성
const createTestUser = (overrides?: Partial<User>) => ({
  id: uuid(),  // 매번 다른 ID
  email: `test-${Date.now()}@example.com`,  // 충돌 방지
  name: 'Test User',
  ...overrides
});

it('test A', () => {
  const user = createTestUser();  // 독립적인 데이터
  // ...
});

it('test B', () => {
  const user = createTestUser();  // 완전히 다른 독립적인 데이터
  // ...
});
```

**핵심 원칙:**

1. **전역 변수 금지**: 테스트 간 공유되는 mutable 상태는 만들지 않음
2. **beforeEach 활용**: 각 테스트가 깨끗한 환경에서 시작하도록 보장
3. **트랜잭션 롤백**: DB 테스트는 반드시 원래 상태로 복원
4. **병렬 실행 고려**: 테스트가 동시에 실행되어도 서로 간섭하지 않도록 설계


# 5장. 테스트 자동화와 인프라


## 5.1. 지속적 통합(CI)과 리뷰 프로세스


### 5.1.1. 프리서밋(Presubmit) 테스트: 커밋 전 품질 확보

소프트웨어 품질 관리에서 가장 비용 효율적인 전략은 버그를 최대한 빨리 잡는 것입니다. 코드가 메인 브랜치(Main Branch)에 병합(Merge)된 후에 문제를 발견하면, 롤백 비용과 다른 개발자의 작업에 미치는 영향이 막대합니다. 따라서 코드가 제출(Submit/Commit)되기 전에 검증하는 **프리서밋(Presubmit) 테스트**가 필수적입니다.

프리서밋 테스트는 로컬 환경(Git Hook 등)이나 CI 서버에서 풀 리퀘스트(PR) 단계에 실행됩니다. 이때 모든 테스트를 실행하는 것은 시간이 너무 오래 걸릴 수 있습니다. 구글은 이를 해결하기 위해 **변경의 영향 범위(Dependency Graph)를 분석하여, 해당 변경 사항과 연관된 테스트만 선별적으로 실행**하는 전략을 사용합니다. 이는 빠른 피드백 루프를 유지하면서도 안전성을 확보하는 핵심 기술입니다.


#### [문제 상황: 깨진 빌드의 전파]

개발자 A가 공통 컴포넌트를 수정하고 메인 브랜치에 머지했습니다. 로컬에서는 테스트를 돌리지 않았습니다. 이후 개발자 B가 메인 브랜치를 당겨(Pull)와서 작업하려는데, 테스트가 실패하고 빌드가 되지 않습니다. 개발자 B는 자신의 코드가 문제인지 한참을 디버깅하다가, 결국 A의 커밋이 원인임을 밝혀냅니다. 팀 전체의 생산성이 저하되었습니다.


#### [해결 과정: Husky와 CI를 활용한 프리서밋 구축]

웹 개발 환경에서는 `husky`와 `lint-staged`를 활용해 로컬에서 1차 검증을 하고, GitHub Actions 등으로 2차 검증을 수행합니다.

```json
// package.json
{
  "scripts": {
    "prepare": "husky install",
    "test:related": "jest --findRelatedTests" // 변경된 파일과 관련된 테스트만 실행
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "jest --findRelatedTests" // 스테이징된 파일 관련 테스트 실행
    ]
  }
}
```

이렇게 설정하면 개발자가 `git commit`을 하는 순간, 변경된 파일과 관련된 테스트가 자동으로 실행됩니다. 테스트가 실패하면 커밋 자체가 막히므로, 깨진 코드가 저장소에 올라가는 것을 원천 봉쇄합니다.


### 5.1.2. 코드 리뷰의 기술: 존중과 명확한 피드백

코드 리뷰는 버그를 찾는 과정일 뿐만 아니라, 지식을 공유하고 코드 품질 기준을 맞추는 엔지니어링 문화의 핵심입니다. 하지만 잘못된 리뷰 문화는 감정 소모와 생산성 저하를 일으킵니다. 구글은 **"존중(Respect)"** 을 코드 리뷰의 제1원칙으로 삼습니다.

리뷰어는 "너(You)"라는 단어 사용을 지양하고 **"코드(Code)" 자체에 집중**해야 합니다. "너 왜 이렇게 짰어?"가 아니라 "이 코드는 메모리 누수 위험이 있어 보입니다"라고 말해야 합니다. 또한, 단순히 "수정하세요"라고 지시하는 것이 아니라, "왜(Why)" 수정해야 하는지 맥락을 제공하고 대안을 제시해야 합니다. 작성자(Author) 역시 리뷰를 자신에 대한 공격으로 받아들이지 않고, 더 좋은 코드를 만들기 위한 과정으로 받아들이는 태도가 필요합니다.


#### [문제 상황: 모호하고 공격적인 리뷰]

```text
[Bad Review]
"이거 별로네요. 다시 짜세요."
(작성자는 무엇이 문제인지 모르고 기분만 나쁨)

"왜 여기서 map을 안 썼어요?"
(작성자를 심문하는 듯한 말투)
```


#### [해결 과정: 구체적이고 건설적인 리뷰]

```text
[Good Review]
"이 부분은 for 루프보다 map을 사용하는 것이 가독성 면에서 더 좋을 것 같습니다.
어떻게 생각하시나요?"
(제안하는 말투, 이유 설명)

"이 로직은 엣지 케이스(빈 배열)에서 에러가 발생할 수 있습니다.
가드 절(Guard Clause)을 추가하는 건 어떨까요?"
(구체적인 문제 지적과 대안 제시)
```

또한, `Nit`(Nitpick, 사소한 지적) 태그를 사용하여 "고치면 좋지만 필수는 아님"을 명시해주면 작성자의 부담을 덜어줄 수 있습니다.


### 5.1.3. 작고 집중된 변경(Small CL)의 중요성

구글에서는 코드 변경 단위를 CL(Changelist)이라고 부르며, **"CL은 작을수록 좋다"** 고 강조합니다. 한 번의 PR(Pull Request)에 수천 라인의 코드 변경과 여러 개의 기능 구현이 섞여 있다면, 리뷰어는 꼼꼼히 보기 힘들고 버그를 놓칠 확률이 급격히 높아집니다.

이상적인 PR은 **"한 가지 일만 하는(Do One Thing)"** 단위입니다. 예를 들어, '리팩토링'과 '기능 추가'를 하나의 PR에 섞지 마세요. 리팩토링 PR을 먼저 머지하고, 그 기반 위에서 기능 추가 PR을 올리는 것이 안전합니다. 작은 PR은 리뷰가 빠르고, 문제가 생겼을 때 롤백(Revert)하기도 쉽습니다.

---


## 5.2. 플래키 테스트(Flaky Tests)와의 전쟁


### 5.2.1. 비결정적 테스트의 원인 분석 (시간, 순서, 동시성)

플래키 테스트(Flaky Test)란 코드 변경이 없는데도 어떨 때는 성공하고 어떨 때는 실패하는 '변덕스러운 테스트'를 말합니다. 이는 개발자의 신뢰를 무너뜨려 결국 테스트 실패를 무시하게 만듭니다. 플래키 테스트의 주원인은 **비결정적(Non-deterministic) 요소**들입니다.

1. **시간(Time)**: `setTimeout`, `Date.now()` 등에 의존하는 테스트는 실행 속도나 시점에 따라 결과가 달라질 수 있습니다.
2. **순서(Order)**: 테스트끼리 공유하는 전역 상태가 제대로 초기화되지 않으면, 테스트 실행 순서에 따라 성공/실패가 갈립니다.
3. **동시성(Concurrency)과 비동기(Async)**: 네트워크 요청이나 비동기 로직이 완료되기 전에 검증(Assert)을 수행하면 경합 조건(Race Condition)이 발생하여 테스트가 깨집니다.


### 5.2.2. 플래키 테스트 완화 및 격리 전략

플래키 테스트를 발견하면 즉시 **격리(Quarantine)** 하거나 수정해야 합니다. "가끔 실패하니까 다시 돌려보자(Retry)"는 최악의 대처입니다.

비동기 로직으로 인한 플래키함을 잡기 위해서는 **암묵적인 대기(Implicit Wait)** 보다는 **명시적인 대기(Explicit Wait)** 를 사용해야 합니다. "1초 기다리기" 대신 "특정 텍스트가 화면에 나타날 때까지 기다리기"가 훨씬 안정적입니다.


#### [문제 상황: 타임아웃에 의존하는 불안정한 테스트]

```typescript
// Bad Case: 고정된 시간 대기 (Flaky 유발)
it('should show modal', async () => {
  openModal();
  
  // 1초 안에 모달이 뜰 것이라 가정 (네트워크가 느리면 실패)
  await new Promise(r => setTimeout(r, 1000));
  
  expect(screen.getByText('Modal Title')).toBeInTheDocument();
});
```


#### [해결 과정: 조건 충족 대기]

React Testing Library의 `waitFor`와 같은 도구를 사용하여 특정 조건이 만족될 때까지 스마트하게 기다립니다.

```typescript
// Good Case: 조건이 만족될 때까지 대기
it('should show modal', async () => {
  openModal();
  
  // 모달이 뜰 때까지 최대 타임아웃 내에서 폴링(Polling)하며 대기
  // 모달이 0.1초 만에 뜨면 테스트도 0.1초 만에 통과 (속도 향상)
  await waitFor(() => {
    expect(screen.getByText('Modal Title')).toBeInTheDocument();
  });
});
```


### 5.2.3. 수면(Sleep) 금지: 동기화 메커니즘 활용

테스트 코드에서 `sleep(500)`과 같은 코드는 절대 금지입니다. 이는 테스트 속도를 느리게 만들 뿐만 아니라, 컴퓨터 성능에 따라 500ms가 부족할 수도 있어 여전히 플래키할 수 있습니다.

대신 **동기화 메커니즘(Synchronization Mechanism)** 을 활용해야 합니다. UI 테스트 도구(Cypress, Playwright)나 비동기 테스트 라이브러리들은 대부분 자동으로 리트라이(Retry)하거나 요소가 준비될 때까지 기다리는 기능(Auto-waiting)을 제공합니다. 이를 적극 활용하여 시스템의 상태 변화와 테스트의 검증 시점을 일치시켜야 합니다.

---


## 5.3. 커버리지(Coverage)와 지표


### 5.3.1. 코드 커버리지의 함정과 올바른 목표 설정 (80%의 신화)

"코드 커버리지 80% 달성"은 많은 팀의 목표입니다. 하지만 커버리지는 **"테스트되지 않은 코드가 어디인지"를 알려주는 지표일 뿐, "품질이 좋다"는 것을 보증하는 지표는 아닙니다.**

커버리지 100%를 달성했더라도, 검증(Assertion)이 없는 테스트라면 아무런 버그도 잡지 못합니다. 반대로 100%를 맞추기 위해 의미 없는 테스트를 남발하면 유지보수 비용만 증가합니다.

구글은 특정 숫자를 목표로 강제하기보다는, **커버리지 리포트를 코드 리뷰 도구에 통합**하여 개발자가 스스로 "내가 작성한 중요한 로직이 테스트되지 않았구나"를 인지하게 하는 방식을 선호합니다. **절대적인 수치보다 중요한 것은 변경된 코드(Delta)에 대한 커버리지**와, 중요 비즈니스 로직의 테스트 여부입니다.


### 5.3.2. 돌연변이 테스트(Mutation Testing): 테스트의 테스트

커버리지의 허점을 보완하기 위한 강력한 기법으로 **돌연변이 테스트(Mutation Testing)** 가 있습니다. 이는 **"테스트 코드가 얼마나 코드를 잘 검증하고 있는가?"** 를 테스트하는 것입니다.

원리는 간단합니다. 도구가 제품 코드를 임의로 조작(돌연변이 생성)합니다. 예를 들어 `if (a > 0)`을 `if (a < 0)`으로 바꾸거나, `return true`를 `return false`로 바꿉니다. 그리고 테스트를 돌립니다.

* **테스트가 실패(Kill)한다면**: 테스트가 코드를 잘 감시하고 있다는 뜻입니다. (Good)
* **테스트가 여전히 성공(Survive)한다면**: 코드가 망가졌는데도 테스트가 잡아내지 못한 것입니다. 즉, 테스트가 부실하다는 증거입니다. (Bad)

Stryker(JS/TS용)와 같은 도구를 활용하면 내가 짠 테스트가 '물 테스트'인지 '철벽 테스트'인지 검증할 수 있습니다.


#### [문제 상황: 검증력이 없는 테스트]

```typescript
function add(a: number, b: number) {
  return a + b;
}

// 이 테스트는 add 함수가 a - b로 바뀌어도 통과할 수 있음 (입력이 0일 때)
it('should add numbers', () => {
  expect(add(0, 0)).toBe(0); 
});
```

이 경우 돌연변이 테스트 도구가 `+`를 `-`로 바꾸고 테스트를 돌리면, 테스트가 통과해버려 "Mutant Survived" 경고를 줍니다. 개발자는 이를 보고 `expect(add(1, 2)).toBe(3)`과 같은 더 강력한 테스트 케이스를 추가하게 됩니다.


### 5.3.3. 테스트 가치 평가와 비용 분석

모든 테스트가 동등한 가치를 지니지 않습니다. 어떤 테스트는 매일 수십 개의 버그를 잡아내지만, 어떤 테스트는 한 번도 실패하지 않으면서 실행 시간만 잡아먹습니다. 주기적으로 **테스트 스위트의 건강 상태를 점검**해야 합니다.

* **실행 시간 분석**: 너무 느린 테스트는 최적화하거나 Mocking을 통해 소형 테스트로 전환합니다.
* **실패 빈도 분석**: 자주 실패하지만 실제 버그가 아닌 경우(Flaky)는 수정하거나 제거해야 합니다.
* **유지보수 비용**: 코드를 고칠 때마다 수정해야 하는 테스트는 구현 상세에 결합된 나쁜 테스트일 가능성이 높습니다. 리팩토링이 필요합니다.

테스트는 자산(Asset)이지만, 관리되지 않는 테스트는 부채(Liability)입니다. 가치가 낮은 테스트는 과감히 삭제하는 것이 전체 엔지니어링 생산성을 높이는 길입니다.


# 6장. 도메인별 테스트 전략


## 6.1. 웹 및 모바일 테스트


### 6.1.1. UI 테스트의 불안정성 극복과 Page Object 패턴

웹 애플리케이션의 UI는 변경이 잦습니다. CSS 클래스 이름이 바뀌거나, HTML 구조가 조금만 변경되어도 UI 테스트는 깨지기 쉽습니다. 이런 불안정성(Brittleness)을 극복하고 유지보수 비용을 낮추기 위해 **Page Object 패턴**이 필수적으로 사용됩니다.

Page Object 패턴은 **테스트 코드(무엇을 테스트하는가)** 와 **페이지의 세부 구현(어떻게 요소를 찾는가)** 을 분리하는 추상화 계층입니다. 페이지의 HTML 구조나 선택자(Selector) 정보는 Page Object 클래스 내부에 캡슐화됩니다. 테스트 코드는 오직 Page Object가 제공하는 명시적인 메서드(`login()`, `clickSubmit()`)만 호출합니다. 따라서 UI가 변경되더라도 테스트 코드는 수정할 필요 없이 Page Object 내부만 수정하면 됩니다.


#### [문제 상황: UI 변경에 취약한 테스트]

```typescript
// Bad Case: 테스트 코드 내에 선택자(Selector)가 하드코딩됨
it('should login', async () => {
  // CSS 클래스가 변경되면 이 테스트는 깨짐.
  // 만약 로그인 기능을 테스트하는 곳이 100군데라면 100군데 다 고쳐야 함.
  await page.type('.login-form input[name="user"]', 'alice');
  await page.type('.login-form input[name="pass"]', '1234');
  await page.click('#btn-submit-v2'); // ID가 v2로 바뀌어서 수정해야 함
});
```


#### [해결 과정: Page Object 패턴 적용]

```typescript
// Good Case: Page Object를 통한 추상화

// LoginPage.ts (페이지의 구조를 아는 유일한 곳)
class LoginPage {
  constructor(private page: Page) {}

  async login(username: string, pass: string) {
    // 선택자가 변경되면 여기만 수정하면 됨
    await this.page.fill('input[name="user"]', username);
    await this.page.fill('input[name="pass"]', pass);
    await this.page.click('button[type="submit"]'); 
  }
}

// Login.test.ts (비즈니스 시나리오에 집중)
it('should login', async () => {
  const loginPage = new LoginPage(page);
  // UI 구현 상세를 몰라도 됨. 메서드 이름이 동작을 명확히 설명함.
  await loginPage.login('alice', '1234');
});
```


### 6.1.2. 모바일 앱(Android/iOS) 테스트를 위한 밀폐형 환경 구성

모바일 앱 테스트, 특히 UI 테스트는 실행 속도가 느리고 환경 요인(네트워크, 에뮬레이터 상태 등)에 민감합니다. 따라서 외부 의존성을 제거한 **밀폐형(Hermetic) 테스트 환경**을 구축하는 것이 중요합니다.

구글은 실제 백엔드 서버 대신 **가짜 로컬 서버(Fake Server)** 를 앱과 함께 띄우거나, 의존성 주입(DI)을 통해 네트워크 계층을 가짜(Fake) 구현체로 교체합니다. 이를 통해 네트워크 불안정으로 인한 실패를 원천 차단하고, 원하는 데이터 상태(예: 서버 에러, 빈 리스트 등)를 손쉽게 시뮬레이션하여 테스트할 수 있습니다.


#### [실무 적용: 안드로이드의 Espresso와 가짜 데이터]

안드로이드의 UI 테스트 프레임워크인 Espresso를 사용할 때, 실제 API를 호출하는 대신 Dagger/Hilt와 같은 DI 라이브러리를 사용하여 `FakeNetworkModule`을 주입합니다. 이렇게 하면 앱은 로컬 메모리나 파일에서 데이터를 즉시 가져오므로 테스트가 매우 빠르고 안정적(Flake-free)이게 됩니다. iOS의 경우도 XCUITest 실행 시 Mock Server를 로컬호스트에 띄우거나, 네트워크 요청을 가로채는 방식을 사용합니다.


### 6.1.3. 접근성(Accessibility) 및 현지화(Localization) 테스트 자동화

현대적인 웹/앱은 전 세계 사용자를 대상으로 하므로 접근성과 현지화(i18n) 품질이 중요합니다. 이를 수동으로 검사하는 것은 매우 번거롭지만, 자동화 도구를 활용하면 효율적으로 검증할 수 있습니다.

* **접근성(a11y) 테스트**: `axe-core`와 같은 라이브러리를 E2E 테스트나 단위 테스트에 통합합니다. 페이지가 렌더링될 때마다 자동으로 색상 대비, ARIA 속성 누락 등을 검사하여 접근성 표준 준수 여부를 확인합니다.
* **현지화(L10n) 테스트**: 번역 키(Key)가 누락되어 화면에 `user.welcome_msg` 같은 코드가 그대로 노출되는 것을 방지해야 합니다. 스크린샷 테스트(Visual Regression Testing)를 활용하여 각 언어별로 UI가 깨지지 않는지(예: 독일어처럼 텍스트가 긴 경우) 확인하거나, 정적 분석을 통해 소스 코드에 하드코딩된 문자열이 없는지 검사합니다.

---


## 6.2. 성능 및 보안 테스트


### 6.2.1. 분산 파일 시스템 및 인프라 성능 테스트 프레임워크

대규모 시스템에서는 기능뿐만 아니라 성능(Latency, Throughput)이 핵심 요구사항입니다. 하지만 성능 테스트는 설정이 복잡하고 결과 분석이 어렵습니다. 구글은 이를 위해 **통합된 성능 테스트 프레임워크**를 구축하여 사용합니다.

이 프레임워크는 다음 기능을 제공합니다:

1. **선언적 설정**: 코드로 복잡한 로직을 짜는 대신, 설정 파일(Config)에 "읽기 작업 70%, 쓰기 작업 30% 비율로 1000명의 가상 유저 생성"과 같이 시나리오를 정의합니다.
2. **자동화된 베이스라인 비교**: 매일 밤 성능 테스트를 수행하고, 지난주 결과(Baseline)와 비교하여 성능이 급격히 저하(Regression)된 경우 자동으로 경고를 보냅니다.
3. **격리된 환경**: 성능 테스트 중에는 다른 작업의 간섭을 받지 않도록 전용 인프라를 사용하거나 클라우드 자원을 동적으로 할당합니다.

웹 개발에서도 Lighthouse CI 등을 활용하여 PR마다 성능 점수(Core Web Vitals)를 측정하고, 기준 점수 미달 시 배포를 막는 방식으로 적용할 수 있습니다.


### 6.2.2. 퍼징(Fuzzing)을 통한 보안 취약점 발견 (OSS-Fuzz)

**퍼징(Fuzzing)** 은 무작위의, 유효하지 않은, 예상치 못한 데이터를 프로그램 입력값으로 대량 주입하여 충돌(Crash), 메모리 누수, 보안 취약점을 찾아내는 기법입니다. 개발자가 미처 생각하지 못한 엣지 케이스(Edge Case)를 기계적으로 찾아내는 데 탁월합니다.

구글은 **OSS-Fuzz** 프로젝트를 통해 수많은 오픈소스 소프트웨어를 지속적으로 퍼징하고 있습니다. 웹 애플리케이션에서도 입력 폼이나 API 엔드포인트에 무작위 데이터를 전송하여 SQL 인젝션, XSS 취약점, 서버 에러(500) 등을 유발하는지 검사할 수 있습니다. 이는 보안 전문가가 수행하는 모의 해킹(Penetration Testing)을 자동화하는 첫걸음입니다.


### 6.2.3. 재현 불가능한 버그(Unreproducible Bugs) 최소화 전략

"제 컴퓨터에서는 되는데요(It works on my machine)"라는 말과 함께 사라지는 '재현 불가능한 버그'는 개발자의 악몽입니다. 주로 경쟁 상태(Race Condition), 메모리 오염, 비동기 타이밍 이슈 등이 원인입니다.

이를 최소화하기 위한 전략은 다음과 같습니다:

1. **방어적 프로그래밍(Defensive Programming)**: 함수 입력값에 대한 전제 조건(Precondition)을 엄격하게 검사(Assert)하여, 잘못된 데이터가 시스템 깊숙이 침투하기 전에 조기에 실패하도록 합니다.
2. **로그 강화**: 에러 발생 시점의 스택 트레이스뿐만 아니라, 에러 발생 직전의 시스템 상태와 사용자 행동 흐름을 파악할 수 있도록 로그에 맥락(Context) 정보를 충분히 남깁니다.
3. **카오스 엔지니어링(Chaos Engineering)**: 테스트 환경에서 네트워크 지연, 패킷 손실, 서버 다운 등의 장애 상황을 인위적으로 주입하여 시스템이 예상치 못한 상황에서도 복구 가능한지 검증합니다.

---


## 6.3. 언어별 특수 고려사항


### 6.3.1. C++: 메모리 안전성 및 데이터 레이스 탐지 (Sanitizers)

C++과 같이 메모리를 직접 관리하는 언어는 메모리 누수(Memory Leak)나 버퍼 오버플로우(Buffer Overflow) 같은 치명적인 버그에 취약합니다. 구글은 컴파일 타임과 런타임에 이러한 문제를 잡아내기 위해 **Sanitizers** 도구 모음(AddressSanitizer, ThreadSanitizer, MemorySanitizer)을 적극 활용합니다.

* **AddressSanitizer (ASan)**: 메모리 접근 오류를 탐지합니다.
* **ThreadSanitizer (TSan)**: 멀티스레드 환경에서 데이터 경쟁(Data Race) 상태를 탐지합니다.

이러한 도구들은 일반적인 테스트만으로는 발견하기 힘든, 특정 타이밍에만 발생하는 동시성 버그나 미세한 메모리 오염을 잡아주어 시스템의 안정성을 비약적으로 높여줍니다.


### 6.3.2. Java: 체크 예외(Checked Exception) 처리 및 Mock 프레임워크

Java의 **체크 예외(Checked Exception)** 는 개발자가 예외 처리를 강제로 하도록 유도하지만, 실무에서는 무의미한 `try-catch` 블록을 양산하거나 예외를 무시(Swallow)하게 만드는 부작용이 있습니다. 구글은 체크 예외를 지양하고, 대부분을 **언체크 예외(Unchecked Exception, RuntimeException)** 로 래핑하여 처리하는 것을 권장합니다. 이를 통해 코드의 가독성을 높이고, 정말 중요한 예외 처리 로직에 집중할 수 있게 합니다.

또한 Mockito와 같은 Mock 프레임워크를 사용할 때도 주의가 필요합니다. 과도한 Mocking은 테스트를 구현 상세에 결합시키므로, 가능한 실제 객체(Real Object)나 가벼운 Fake 객체를 사용하는 것이 Java 생태계에서도 권장되는 모던 테스트 방식입니다.


### 6.3.3. Python/JavaScript: 동적 언어에서의 스텁 및 시간 시뮬레이션

Python이나 JavaScript 같은 동적 언어는 런타임에 객체의 속성을 자유롭게 변경할 수 있어 테스트 더블(Stub)을 만들기 쉽습니다. 하지만 이는 양날의 검입니다. 존재하지 않는 메서드를 호출하거나 오타를 내도 테스트 실행 전까지 모를 수 있습니다.

따라서 동적 언어에서는 **타입 시스템(TypeScript, Type Hints)** 의 도입이 테스트의 첫 번째 방어선이 됩니다.

또한, `setTimeout`이나 `Date` 객체를 다루는 비동기/시간 의존적 코드를 테스트할 때는, 실제 시간을 기다리는 대신 **가짜 타이머(Fake Timer)** 를 사용해야 합니다. Jest의 `useFakeTimers()` 등을 활용하면 1시간 뒤에 실행될 로직도 테스트 코드에서는 0초 만에 검증할 수 있어, 테스트 속도와 결정성을 모두 확보할 수 있습니다.

```typescript
// JavaScript/TypeScript 시간 시뮬레이션 예시
jest.useFakeTimers();

it('should execute callback after 1 hour', () => {
  const callback = jest.fn();
  setTimeout(callback, 1000 * 60 * 60); // 1시간
  
  // 실제로 1시간을 기다리지 않고 타이머를 즉시 감아버림(Fast-forward)
  jest.runAllTimers();
  
  expect(callback).toHaveBeenCalled();
});
```


# 7장. 결론: 지속 가능한 엔지니어링을 향하여


## 7.1. 소프트웨어 수명 주기와 테스트의 역할

소프트웨어 엔지니어링과 단순한 프로그래밍의 가장 큰 차이는 '시간'이라는 차원에 있습니다. 프로그래밍이 코드를 작성하는 순간에 집중한다면, 소프트웨어 엔지니어링은 코드가 작성된 이후 수년, 혹은 수십 년 동안 지속되어야 하는 제품의 전체 수명 주기(Lifecycle)를 고려합니다.

이 긴 시간 동안 소프트웨어는 필연적으로 변화합니다. 요구사항은 바뀌고, 라이브러리는 업데이트되며, 인프라는 교체됩니다. 이러한 변화 속에서도 소프트웨어가 무너지지 않고 지속 가능하도록(Sustainable) 지탱해주는 유일한 기둥이 바로 테스트입니다.

테스트 코드는 미래의 나, 그리고 미래의 동료를 위한 타임캡슐과 같습니다. 잘 작성된 테스트는 "이 코드는 원래 이렇게 동작해야 합니다"라는 의도를 명확히 전달하며, 누군가 실수로 그 의도를 훼손하려 할 때 즉시 경고를 보냅니다. 테스트가 없는 코드는 '레거시(Legacy)'이며, 레거시는 수정하기 두려운 부채가 됩니다. 반면, 견고한 테스트 스위트를 갖춘 코드는 언제든 리팩토링하고 개선할 수 있는 살아있는 자산이 됩니다.

따라서 테스트는 개발의 부산물이 아니라, 소프트웨어의 수명을 연장시키는 핵심 엔진입니다.


## 7.2. 도구보다 중요한 것은 팀의 문화와 사고방식

구글이 사용하는 수많은 첨단 도구(자동화된 코드 리뷰 시스템, 대규모 빌드 시스템, AI 기반 테스트 생성기 등)보다 더 중요한 것은 이를 사용하는 엔지니어들의 **문화(Culture)** 와 **사고방식(Mindset)** 입니다.

아무리 좋은 도구가 있어도, 팀원들이 "테스트는 QA 팀의 일이다", "바쁘니까 테스트는 나중에 짜자", "빌드가 깨져도 내 알 바 아니다"라고 생각한다면 품질은 결코 나아지지 않습니다.

진정한 엔지니어링 생산성은 다음과 같은 문화에서 비롯됩니다:

* **품질에 대한 공동 책임**: 개발자, 테스터, PM 모두가 제품의 품질에 책임을 느낍니다.
* **심리적 안전감(Psychological Safety)**: 실패를 비난하기보다 시스템의 문제로 바라보고 개선하려는 태도를 가집니다. 포스트모텀(Post-mortem)을 통해 실수로부터 배웁니다.
* **지속적인 개선**: "원래 그랬어"라는 말에 안주하지 않고, 비효율적인 프로세스와 나쁜 코드 패턴(Code Smell)을 끊임없이 개선하려는 의지를 가집니다.
* **존중과 협업**: 코드 리뷰와 설계 논의 과정에서 서로를 존중하며, 더 나은 해결책을 찾기 위해 열린 마음으로 소통합니다.

도구는 문화를 강화할 수 있지만, 문화를 대체할 수는 없습니다. 건강한 테스트 문화가 정착된 팀은 어떤 도구를 사용하더라도 고품질의 소프트웨어를 만들어냅니다.


## 7.3. 미래의 테스트: AI와 자동화의 진화 방향

소프트웨어 테스트의 미래는 인공지능(AI)과 머신러닝(ML)을 통한 자동화의 진화에 있습니다. 이미 우리는 그 변화의 시작점에 서 있습니다.

1. **테스트 자동 생성**: AI가 코드의 변경 사항을 분석하여 필요한 단위 테스트를 자동으로 생성하고, 엣지 케이스를 찾아내는 기술이 발전하고 있습니다. 개발자는 테스트 로직을 고민하는 대신, AI가 제안한 테스트가 타당한지 검토하는 역할로 전환될 것입니다.
2. **자가 치유(Self-healing) 테스트**: UI가 변경되어 선택자(Selector)가 바뀌었을 때, AI가 이를 감지하고 테스트 코드를 자동으로 수정하여 테스트 실패를 방지하는 기술이 상용화되고 있습니다. 이는 테스트 유지보수 비용을 획기적으로 줄여줄 것입니다.
3. **지능형 리스크 분석**: 방대한 코드베이스에서 어떤 테스트를 실행해야 할지, 어떤 부분에서 버그가 발생할 확률이 높은지를 ML 모델이 예측하여 테스트 효율을 극대화합니다. 구글의 Test Impact Analysis가 그 예시입니다.

하지만 AI가 발전할수록 인간 엔지니어의 역할은 더욱 중요해집니다. AI는 '어떻게(How)' 테스트할지는 잘 알지만, '무엇을(What)' 테스트해야 하는지, 그리고 그 결과가 사용자에게 어떤 '가치(Value)'를 주는지 판단하는 것은 여전히 인간의 몫이기 때문입니다.

우리는 도구의 노예가 되는 것이 아니라, 도구를 활용하여 더 높은 차원의 문제 해결과 가치 창출에 집중하는 엔지니어가 되어야 합니다. 테스트는 그 여정을 함께하는 가장 든든한 동반자가 될 것입니다.

---
**[마치며]**

이 책이 여러분의 코드에 건강함을, 팀에 활력을, 그리고 제품에 신뢰를 더하는 데 작은 보탬이 되기를 바랍니다. **"Debugging sucks, Testing rocks!"** (디버깅은 최악이지만, 테스트는 최고다!)
