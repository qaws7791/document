# 리팩터링

> 리팩터링은 겉으로 드러나는 **코드의 기능은 바꾸지 않으면서** 내부 구조를 개선하는 방식으로 소프트웨어 시스템을 수정하는 과정 - 7p

> 리팩터링의 각 단계는 간단하다 못해 지나칠 정도로 단순하다. - 8p

> 설계가 나쁜 시스템은 수정하기 어렵다 - 26p

> 프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기 수월하다 - 27p

> 리팩터링의 첫 단계는 코드 영역을 꼼꼼하게 검사해줄 테스트 코드를부터 마련하는 것이다. 테스트를 신경 써서 만들어두면 디버깅 시간을 절약하여 전체 작업 시간을 줄일 수 있다 - 28p

리팩터링 하는 이유

- 리팩터링을 통해 **소프트웨어 설계를 반영**할 수 있다
- 리팩터링을 통해 **코드를 이해하기 쉽게** 만들 수 있다
- 리팩터링을 통해 코드의 구조가 명확해지면 **버그를 찾기 쉬워 진다**
- 위의 장점들을 통해 궁극적으로 프로그래밍 속도를 높일 수 있다


### 이름 바꾸기

- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기


### 중복 코드

- 함수 추출하기
- 문장 슬라이드하기
- 메서드 올리기


### 긴 함수

- 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓기
- 임시 변수의 수 줄이기 - 임시 변수를 질의 함수로 바꾸기
- 매개변수의 수 줄이기 - 매개변수를 객체로 만들기, 객체를 통째로 넘기기
- 함수를 명령으로 바꾸기
- 조건문 분해하기
- 조건문을 다형성으로 바꾸기
- 반복문 쪼개기
- 프래그 인수 - 플래그 인수 제거하기
- 여러 함수간 공통 매개변수 - 여러 함수를 클래스로 묶기


### 전역 변수

- 변수 캡슐화하기

6장 기본적인 리팩터링


### 6.1 함수 추출하기

코드의 일부분을 독립된 함수로 추출

- 기준 - 목적 / 코드 길이 / 재사용성
- 해당 함수의 이름을 보고 어떤 한 가지의 작업을 수행하는지 알 수 있어야 한다
- 추상화 레벨에 따른 이름 결정


### 6.2 함수 인라인하기

함수 본문이 그 자체로 의도가 명확하게 드러날 때 인라인하여 사용


### 6.3 변수 추출하기

복잡한 표현식을 변수로 추출하여 이름을 붙이면 코드를 더 읽기 쉽게 만들 수 있다


### 6.4 변수 인라인하기

표현식이 그 자체로 의도를 표현할 수 있을 때는 굳이 추출하지 않아도 된다.


### 6.5 함수 선언 바꾸기

함수 선언은 시작이 되는 부분으로 잘못 정의되면 소프트웨어 동작을 파악하기 어려워진다.

- 함수 이름 바꾸기
- 필요한 매개변수만 입력으로 받아야 한다 - 매개변수 추가, 변경, 삭제하기


### 6.6 변수 캡슐화하기

데이터는 변경 시에 참조하는 모든 부분이 영향을 받는다

함수를 통해서만 데이터를 접근하도록 제한하여 쉽게 변경할 수 있다

값 캡슐화하기 - 항상 새로운 데이터를 반환하여 원본 데이터를 변경하지 않도록할 수 있다(불변성)

> 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다 - 188p


### 6.7 변수 이름 바꾸기

> 변수는 프로그래머가 하려는 일에 관해 많은 것을 설명해준다 - 194p

이름을 잘못 짓게 되는 경우들

- 충분한 고민을 하지 않았을 때
- 문제에 대해 더 이해도가 높아져 다르게 작성해야 하는 경우
- 요구사항이 달라져 프로그램의 목적이 변경되는 경우


### 6.8 매개변수 객체 만들기

데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다


### 6.9 여러 함수를 클래스로 묶기

여러 함수를 클래스로 묶으면 함수 간 환경을 쉽게 공유할 수 있다

함수에 전달되는 인자를 줄일 수 있다

- 계산이 무거운 데이터는 클래스의 메서드로 만들어 사용할 때만 계산되도록 할 수 있다


### 6.10 여러 함수를 변환 함수로 묶기

데이터로부터 도출되는 정보 중 여러 곳에서 공통적으로 사용되는 경우 도출 로직이 중복되어 사용될 수 있다. 변환함수는 원본 데이터를 입력받아 필요한 정보만 도출하여 반환한다

변환 함수는 독립적인 함수로 존재할 수도 있고 클래스 내에서 포함되어 있을 수도 있다


### 6.11 단계 쪼개기

서로 다른 두 가지 이상의 대상을 쉽게 다루기 위해 각각을 단계로 쪼갤 수 있다.

단계는 대상 별 / 모듈 별 / 순서 등 다양한 기준에 따라 나눌 수 있다


### 7 캡슐화

모듈의 분리하는 중요한 기준 -  각 모듈이 드러내지 않아야 할 부분을 최대한 숨겨야 한다

- 데이터 구조를 레코드, 컬렉션으로 캡슐화하기
- 기본형 데이터를 객체로 바꾸기
- 임시  변수를 질의 함수로 바꾸기
- 클래스를 사용한 캡슐화 - 클래스 추출하기 ↔ 클래스 인라인하기
- 클래스 사이의 연결 관계 숨기기 - 위임 숨기기 ↔ 중개자 제거하기
- 함수 캡슐화하기 - 알고리즘 교체하기


### 7.1 레코드 캡슐화하기

레코드를 단순 클래스로 만들고, 게터와 세터를 통해 접근하고 수정하도록 변경한다


### 7.2 컬렉션 캡슐화하기

컬렉션 자체를 게터로 반환하는 경우 컬렉션의 변경을 알아채기 힘들다.

컬렉션에 대한 add(), update(), remove()와 같은 변경자 메서드를 노출하여 항상 소유한 클래스가 컬렉션을 변경하도록 할 수 있다. 이때는 컬렉션을 제공할 때 읽기 전용이나 복제본(불변성)으로 제공할 수 있다


### 7.3 기본형을 객체로 바꾸기

처음에는 간단한 데이터 항목으로 표현되던 것이 개발이 진행됨에 따라 단순한 출력 이상의 복잡한 기능이 필요해질 수 있는데, 이 때 데이터를 표현하는 전용 클래스를 정의하여 사용할 수 있다

날짜, 시간, 상태, 우선 순위, 필터 등


### 7.4 임시 변수를 질의 함수로 바꾸기

임시 변수를 질의 함수로 추출하여 코드의 반복을 줄이고 값의 의미를 더 잘 나타낼 수 있다

```tsx
const salePrice = this.basePrice * this.discountRate
const getSalePrice = () => this.basePrice * this.discountRate
```


### 7.5 클래스 추출하기 / 인라인하기

하나의 클래스에 너무 많은 메서드와 데이터가 혼재하면 사용하고 이해하기 어렵기 때문에 분리하는 것이 좋다

반대로 클래스가 하는 일이 너무 적거나 역할이 마땅히 없다면 다시 인라인할 수 있다. 인라인한 후 다시 나누는 것이 오히려 쉬울 때도 있다


### 7.6 위임 숨기기 / 중개자 제거하기

위임 객체의 의존성을 없애기 위해 위임 메서드를 만들어 위임 객체의 존재를 숨길 수 있다.

하지만 위임 메서드가 계속 추가되어 많아지면 중개자 역할에 가까워지므로 주의하고, 사용하는 곳에서 위임 객체를 직접 호출하는 것이 나을 수도 있다.


### 7.7 알고리즘 교체하기

더 나은 문제 해결 방법을 찾았을 때는 더 간단한 알고리즘으로 바꾸는 것이 낫다. 이때 알고리즘을 교체하기 쉽도록 메서드를 작게 나누는 것부터 시작해야 한다


### 8 기능이동

- 함수 옮기기
- 필드 옮기기
- 문장을 함수로 옮기기
- 문장을 호출한 곳으로 옮기기
- 문장 슬라이드하기
- 인타인 코드를 함수 호출로 바꾸기
- 반복문 쪼개기
- 반복문을 파이프라인으로 바꾸기
- 죽은 코드 제거하기


### 8.1 함수 옮기기

일반적으로 함수는 어떠한 컨텍스트 내에 존재한다

함수는 자신이 있어야 할 가장 적절한 모듈로 옮겨져야 한다

함수의 적절한 모듈에 대한 기준

- 대상 함수가 어떤 데이터들을 참조하는가
- 대상 함수를 호출하는 함수들은 무엇이 있는가
- 대상 함수가 호출하는 함수들은 무엇이 있는가


### 8.2 필드 옮기기

> 현재 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야 한다. -289p

시간이 지남에 따라 데이터 구조에 대한 이해가 쌓이면 더 나은 구조를 만들고 싶을 수 있다

클래스를 사용하면 데이터 접근자통해 캡슐화하여 추후에 옮기는 작업이 더 수월해질 수 있다


### 8.3 문장을 함수로 옮기기, 문장을 호출한 곳으로 옮기기

특정 함수를 호출할 때 그 호출의 앞이나 뒤에서 같은 코드를 계속 사용한다면 이를 함수에 포함하는 것이 나을 수 있다

단 함수 안으로 옮길 때는 그 코드들이 옮길 함수의 일부라는 확신이 있어야 한다. 그렇지 않다면 이 둘을 함께 묶은 다른 함수를 만드는 방법도 있다

반대로 함수 내의 기능이 일부 호출자에게는 다르게 동작해야 한다면 이를 외부로 꺼내 호출하는 근처에서 처리하도록 할 수 있다


### 8.4 인라인 코드를 함수 호출로 바꾸기

함수의 이름은 동작 방식보다는 목적을 말해주기 때문에 코드를 함수로 적절히 추출하면 코드를 더 이해하기 쉬워진다

또한 인라인 코드를 추출하여 여러 곳에서 재사용할 수 있다


### 8.5 문장 슬라이드하기

관련 있는 코드들을 가까이 위치 시키기(특히 변수 선언부)

⚠️코드 순서 변경으로 인한 부수 효과 및 영향에 주의


### 8.6 반복문 쪼개기

하나의 반복문 안에서 한 가지 일만 수행하도록 반복문을 분리할 수 있다

반복문 여러 개로 인해 최적화 문제는 없는가? → 리팩터링을 먼저 수행하고 최적화를 고민하라


### 8.7 반복문을 파이프라인으로 바꾸기

for, while 등의 반복문을 컬렉션 파이프라인으로 변경할 수 있다.

파이프라인은 데이터의 처리 흐름을 읽기 쉽게 해준다


### 8.8 죽은 코드 제거하기

더 이상 사용되지 않는 코드는 제거해야 한다. 미래에 다시 사용할 지 모른다는 걱정 때문이라면 버전 관리 시스템을 통해 가져올 수 있기 때문에 걱정하지 않아도 된다.


### 9 데이터 구조

- 변수 쪼개기
- 파생 변수를 질의 함수로 바꾸기
- 참조를 값으로, 값을 참조로 바꾸기


### 9.1 변수 쪼개기

여러 용도로 사용되는 변수는 코드를 읽을 때 혼란을 줄 수 있다

역할이 둘 이상인 변수를 역할 별로 쪼갤 수 있다


### 9.2 필드 이름 바꾸기

> 개발을 진행할수록 데이터를 더 잘 이해하게 된다. 그 깊어진 이해를 프로그램에 반드시 반영해야 한다


### 9.3 파생 변수를 질의 함수로 바꾸기

가변 데이터가 유효 범위를 줄여 다른 코드에 미치는 영향을 최소화 해야 한다

값을 쉽게 계산할 수 있는 변수들을 질의 함수로 대체할 수 있다


### 9.4 참조를 값으로 바꾸기

객체를 참조로 취급하기 vs 값으로 취급하기

데이터 갱신 방식의 차이

- 참조: 객체의 속성만 변경된다
- 값: 객체 자체가 통째로 바뀐다 → 값 객체로 만들기 → 동치성을 값 기반으로 평가


### 9.5 값을 참조로 바꾸기

같은 데이터가 여러 군데 퍼져 있을 경우 일일이 갱신하는 것은 어렵다

하나의 저장소를 만들어 객체를 한 번만 만들고 이 저장소부터 데이터를 가져다 쓴다


### 9.6 매직 리터럴 바꾸기

매직 리터럴: 여러 번 사용되는 리터럴 값

리터럴 값을 상수로 정의하고 재사용하면 변경이 용이하다

```tsx
const ADULT_AGE = 20
function isAdult (age) { return age >= ADULT_AGE }
```


### 10 조건부 로직 간소화

복잡한 조건문 → 조건문 분해하기

논리적 조합을 다듬기 → 중복 조건식 통합하기

특정 로직 이전에 검사(검증)하기 → 중첩 조건문을 보호 구문으로 바꾸기

분기 로직 재사용하기 → 조건부 로직을 다형성으로 바꾸기

null과 같은 특이 케이스 처리 → 특이 케이스 추가하기(널 객체 추가하기)

프로그램 상태를 확인하고 다르게 동작시키기 → 어서션 추가하기


### 10.1 조건문 분해하기

복잡한 조건부 로직을 별도의 함수로 추출하면 코드의 의도를 파악하기 쉽다


### 10.2 조건식 통합하기

여러 개의 비교 로직을 하나의 조건식으로 통합하여 하려는 작업을 더 명확하게 드러낼 수 있고 별도의 함수로 추출하기 쉬워진다


### 10.3 중첩 조건문을 보호 구문으로 바꾸기

보호구문: 조건을 통해 비정상 상태인지를 판단하고 함수에서 빠져나오기(early return)

[https://en.wikipedia.org/wiki/Guard_(computer_science)](https://en.wikipedia.org/wiki/Guard_(computer_science))


### 10.4 조건부 로직을 다형성으로 바꾸기

슈퍼 클래스와 서브 클래스를 사용

서브 클래스에서 메서드를 오버라이드하여 클래스 별로 동작을 다르게 구현


### 10.5 특이 케이스 추가하기

특정 값에 대해 똑같은 동작을 수행하는 경우(예를 들어 null) 이러한 코드들을 한 곳에 모아 두는 것이 효율적이다

[https://martinfowler.com/eaaCatalog/specialCase.html](https://martinfowler.com/eaaCatalog/specialCase.html)


### 10.6 어서션 추가하기

참이라고 가정하는 조건의 위에 어서션 추가한다

단, 어서션은 시스템의 동작에 영향을 주지 않는다

반드시 참이어야 하는 것만 검사


### 10.7 제어 플래그를 탈출문으로 바꾸기

제어플래그: isFound, isDone과 같은 변수들

제어플래그를 사용하는 대신(일반적으로 반복문에서 많이 사용됨) 제어문을 사용할 수 있다

제어문: return, break, continue 등


### 11 API 리팩터링

질의 함수와 변경 함수 분리하기

함수 매개변수화하기

플래그 인수 제거하기

객체 통째로 넘기기

매개변수를 질의 변수로 바꾸기, 질의함수를 매개변수로 바꾸기

세터 제거하기

생성자를 팩터리 함수로 바꾸기

함수를 명령으로 바꾸기, 명령을 함수로 바꾸기

수정된 값 반환하기

오류 코드를 예외로 바꾸기

예외를 사전 확인으로 바꾸기


### 11.1 질의 함수와 변경 함수 분리하기

겉보기 부수 효과(observable side effect)가 있는 함수와 없는 함수를 명확히 구분해야 한다

명령과 질의 분리(command-query separation) - 질의 함수(조회 함수)는 모두 부수효과가 없어야 한다


### 11.2 함수 매개변수화하기

비슷한 로직을 가진 여러 함수를 매개변수를 통해 하나의 함수에서 처리하도록 하여 중복을 없앨 수 있다


### 11.3 플래그 인수 제거하기

플래그 인수는 호출할 수 있는 함수와 기능, 호출방법을 파악하기 어렵게 만든다

플래그 인수에 각각 대응되는 명시적인 함수들로 분리할 수 있다


### 11.4 객체 통째로 넘기기

레코드를 통째로 넘기면 매개변수 목록이 짧아지고 변화에 대응하기 쉽다

<aside>
✨


단, 함수가 레코드 자체에 의존하게 되므로 주의해야 한다

</aside>


### 11.5 매개변수를 질의 함수로 바꾸기

> 피호출 함수가 스스로 ‘쉽게’ 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다

매개변수를 넘기면 피호출 함수이 매개변수에서 필요한 속성을 꺼내 쓰도록 할 수 있다


### 11.6 질의 함수를 매개변수로 바꾸기

같은 입력을 넣으면 같은 결과를 반환하므로 참조 투명성을 가질 수 있다

함수에 어떤 값을 제공해야 할지를 호출자가 결정해야 한다

<aside>
✨


어떤 값을 사용할지에 대해 호출자가 결정할지, 함수 내부에서 결정할지에 대한 균형점을 찾아야 한다

</aside>


### 11.7 세터 제거하기

세터 메서드가 존재한다는 것은 언제든 필드 값이 수정될 수 있다는 위험이 있다


### 11.8 생성자를 팩터리 함수로 바꾸기

생성자(`new Something()`)는 생성자를 정의한 클래스의 인스턴스를 반환하는 제약 같은 것들이 있다.

반면 팩터리 함수(`createSomething()`)는 new 연산자를 쓰지 않아도 된다거나. 생성자를 선택적으로 호출할 수 있는 등 더 유연하게 사용할 수 있다


### 11.9 함수를 명령으로 바꾸기

함수에 대해 그 함수를 위한 객체로 캡슐화하면 더 유용한 경우도 있다 → 명령 객체

생성자에서 매개변수를 입력받고, `execute` 메서드에서는 되도록 입력을 받지 않는다


### 11.10 명령을 함수로 바꾸기

로직이 크게 복잡하지 않다면 그냥 함수를 사용하는 것이 더 나을 수 있다


### 11.11 수정된 값 반환하기

데이터를 수정하는 대신 수정된 데이터를 반환하도록 할 수 있다

단, 값 여러 개를 갱신해야 하는 경우에는 비효율적일 수 있다


### 11.12 오류 코드를 예외로 바꾸기

> 예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다


### 11.13 예외를 사전확인으로 바꾸기

예외를 유발하는 상황을 미리 검사할 수 있다면 검사하는 것이 좋다
