---
title: Software Architecture Principles
---

## Common Software Architecture Principles (흔히 사용되는 소프트웨어 아키텍처 원칙)

요청하신 목차의 첫 번째 대단원, "객체지향 설계 및 코드 품질 기본 원칙"에 대한 전문적인 설명을 시작하겠습니다. 이 원칙들은 견고하고, 유지보수하기 쉬우며, 유연한 소프트웨어를 만드는 초석입니다.

---


### **1. 객체지향 설계 및 코드 품질 기본 원칙 (Fundamental Principles of OO Design & Code Quality)**

소프트웨어 개발의 역사가 깊어지면서, 수많은 개발자와 설계자들은 "좋은 코드"와 "나쁜 코드"를 구분하는 특징들을 발견했습니다. 나쁜 코드는 수정하기 어렵고(Rigidity), 작은 변화가 시스템 전체에 예기치 않은 문제를 일으키며(Fragility), 재사용이 거의 불가능(Immobility)합니다. 이러한 문제들을 해결하고 고품질의 객체지향 소프트웨어를 만들기 위해 정립된 원칙들이 바로 이 장에서 다룰 내용입니다.

이 원칙들은 단순히 코드를 작성하는 기법을 넘어, 소프트웨어의 구조를 어떻게 구상하고 조직해야 하는지에 대한 철학을 담고 있습니다.


### **1.1. SOLID 원칙**

SOLID는 소프트웨어 설계 전문가인 **로버트 C. 마틴(Robert C. Martin, "Uncle Bob")** 이 2000년대 초반에 객체지향 설계의 다섯 가지 기본 원칙을 정리하여 만든 약어입니다. 이 원칙들을 따르면 응집도는 높이고(High Cohesion) 결합도는 낮추어(Low Coupling), 변화에 유연하게 대처할 수 있는 시스템을 만들 수 있습니다.

> **출처 및 신뢰성:**
>
> - **창시자:** Robert C. Martin
> - **핵심 저서:** *Agile Software Development, Principles, Patterns, and Practices* (2002), *Clean Architecture* (2017)
> - **소개 문서:** 이 원칙들은 마틴의 여러 글과 강연을 통해 널리 알려졌으며, 특히 그의 블로그 [Butt Ugly Mush](http://blog.cleancoder.com/)에서 자주 다루어집니다.

---


#### **1.1.1. 단일 책임 원칙 (SRP: Single Responsibility Principle)**


##### **핵심 아이디어**

> "A class should have only one reason to change."
>
> "클래스는 변경되어야 할 단 하나의 이유만을 가져야 한다."

SRP에서 말하는 '책임' 또는 '변경의 이유'는 종종 시스템의 특정 '액터(Actor)' 또는 '이해관계자'와 연결됩니다. 예를 들어, 회계팀에서 요청하는 보고서 형식 변경과 인사팀에서 요청하는 근무 시간 계산 방식 변경은 서로 다른 이유에 해당합니다. 따라서 보고서 생성 로직과 근무 시간 계산 로직은 서로 다른 클래스에 있어야 합니다.


##### **상세 설명**

하나의 클래스가 여러 책임을 가지게 되면, 각 책임이 서로 강하게 결합됩니다. 한 가지 책임과 관련된 코드를 수정했을 때, 다른 책임과 관련된 코드에 예기치 않은 부작용(Side Effect)을 일으킬 확률이 높아집니다. 예를 들어, 데이터베이스 스키마를 변경하는 작업이 이메일 알림 형식에까지 영향을 미쳐서는 안 됩니다.

SRP를 준수하면 각 클래스는 하나의 개념, 하나의 기능에만 집중하게 됩니다. 이는 코드의 가독성을 높이고, 특정 기능의 변경이 필요할 때 수정해야 할 범위를 명확하게 한정시켜 줍니다. 또한, 각 클래스를 독립적으로 테스트하기 용이해져 시스템의 전반적인 안정성이 향상됩니다.


##### **TypeScript 예시**

**[위반 사례]** `Employee` 클래스가 직원 정보 관리, 급여 계산, 데이터베이스 저장이라는 세 가지 책임을 모두 가지고 있습니다.

```typescript
// Bad: Violates SRP
class Employee {
  constructor(public name: string, public position: string, public monthlySalary: number) {}

  // 책임 1: 급여 계산
  calculatePay(): number {
    // 복잡한 급여 계산 로직...
    return this.monthlySalary;
  }

  // 책임 2: 보고서 생성 (인사팀 요구사항)
  generateReport(): string {
    return `Employee: ${this.name}, Position: ${this.position}`;
  }

  // 책임 3: 데이터베이스 저장 (DBA 요구사항)
  saveToDatabase(): void {
    console.log(`Saving ${this.name} to the database...`);
    // DB 연결 및 저장 로직...
  }
}
```

**[준수 사례]** 각 책임을 별도의 클래스로 분리합니다.

```typescript
// Good: Adheres to SRP

// 책임 1: 직원 데이터 모델
class Employee {
  constructor(public name: string, public position: string, public monthlySalary: number) {}
}

// 책임 2: 급여 계산기 (재무팀)
class PayCalculator {
  calculatePay(employee: Employee): number {
    // 급여 계산 로직
    return employee.monthlySalary;
  }
}

// 책임 3: 직원 리포지토리 (DBA)
class EmployeeRepository {
  save(employee: Employee): void {
    console.log(`Saving ${employee.name} to the database...`);
    // DB 연결 및 저장 로직
  }
}

// 책임 4: 보고서 생성기 (인사팀)
class ReportGenerator {
    generate(employee: Employee): string {
        return `Employee: ${employee.name}, Position: ${employee.position}`;
    }
}
```


##### **장점**

- **유지보수성 향상:** 변경이 필요한 기능의 코드가 한 곳에 모여 있어 수정이 용이합니다.
- **테스트 용이성:** 각 클래스를 독립적으로 Mocking하여 테스트하기 쉽습니다.
- **코드 재사용성 증가:** 특정 책임(예: 데이터베이스 저장)을 다른 곳에서도 재사용하기 용이합니다.


##### **더 찾아볼 자료**

- **Clean Architecture (책):** 로버트 C. 마틴의 저서에서 SRP를 포함한 SOLID 원칙을 심도 있게 다룹니다.
- **Facade Pattern:** 여러 개의 분리된 클래스를 사용하는 것이 복잡하게 느껴질 때, Facade 패턴을 적용하여 간단한 인터페이스를 제공할 수 있습니다.

---


#### **1.1.2. 개방-폐쇄 원칙 (OCP: Open-Closed Principle)**


##### **핵심 아이디어**

> "Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification."
>
> "소프트웨어 개체는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다."

OCP의 핵심은 새로운 기능이나 요구사항이 추가될 때, 기존의 잘 동작하던 코드를 변경하는 것이 아니라, 새로운 코드를 추가하여 시스템을 확장하는 방식으로 대응해야 한다는 것입니다.


##### **상세 설명**

기존 코드를 수정하는 것은 항상 위험을 동반합니다. 이미 테스트를 통과하고 안정적으로 운영되던 코드에 변경을 가하면, 새로운 버그가 발생할 가능성이 있습니다. OCP는 이러한 위험을 최소화하기 위해 '추상화'와 '다형성'을 활용할 것을 권장합니다.

공통적인 부분을 인터페이스나 추상 클래스로 정의하고, 각 기능의 세부 구현은 해당 추상화를 구현하는 구체 클래스에 위임합니다. 이렇게 하면 새로운 기능을 추가할 때, 새로운 구체 클래스를 만들기만 하면 되므로 기존의 클라이언트 코드는 전혀 수정할 필요가 없게 됩니다.


##### **TypeScript 예시**

**[위반 사례]** 결제 유형이 추가될 때마다 `PaymentProcessor` 클래스의 `process` 메서드를 수정해야 합니다.

```typescript
// Bad: Violates OCP
type PaymentType = 'credit-card' | 'paypal' | 'crypto';

class PaymentProcessor {
  process(type: PaymentType, amount: number): void {
    if (type === 'credit-card') {
      console.log(`Processing credit card payment of $${amount}`);
      // 신용카드 결제 로직...
    } else if (type === 'paypal') {
      console.log(`Processing PayPal payment of $${amount}`);
      // 페이팔 결제 로직...
    } else if (type === 'crypto') { // 새로운 결제 방식 추가 시 이 부분을 수정해야 함
      console.log(`Processing Crypto payment of $${amount}`);
      // 암호화폐 결제 로직...
    }
  }
}
```

물론입니다. 목차의 두 번째 대단원, **"구조적 설계 원칙"** 에 대한 전문적인 설명을 시작하겠습니다. 이 원칙들은 소프트웨어의 뼈대를 어떻게 구성하고 조직할 것인지에 대한 지침을 제공합니다.

---


### **2. 구조적 설계 원칙 (Structural Design Principles)**

SOLID 원칙이 개별 클래스 수준의 '좋은 설계'에 집중했다면, 구조적 설계 원칙은 더 큰 그림, 즉 시스템의 모듈, 컴포넌트, 계층을 어떻게 조직하고 배치할 것인지에 대한 가이드라인을 제공합니다. 잘 정의된 구조는 시스템의 복잡성을 관리하고, 개발과 유지보수를 용이하게 하며, 특정 기술이나 구현으로부터 시스템을 보호하는 역할을 합니다.

이 원칙들은 시스템의 청사진을 그리는 건축가의 관점에서 소프트웨어를 바라보게 합니다.


### **2.1. 관심사 분리 및 계층화 (Separation of Concerns & Layering)**

시스템을 구성하는 가장 근본적인 방법 중 하나는 서로 다른 '관심사'들을 분리하고, 이를 논리적인 '계층'으로 쌓아 올리는 것입니다.

---


#### **2.1.1. 관심사 분리 원칙 (SoC: Separation of Concerns)**


##### **핵심 아이디어**

> "A computer program is a set of modules, each dealing with a distinct concern."
>
> "컴퓨터 프로그램은 각각의 개별적인 관심사를 다루는 모듈들의 집합이다."

관심사 분리(SoC)는 소프트웨어를 서로 다른 역할을 수행하는 별개의 부분으로 나누는 원칙입니다. 여기서 '관심사'란 사용자 인터페이스(UI), 비즈니스 로직, 데이터 접근, 로깅, 인증 등과 같이 프로그램이 수행해야 하는 특정 기능이나 목적을 의미합니다.


##### **출처 및 신뢰성**

- **창시자:** 에츠허르 다익스트라(Edsger W. Dijkstra)
- **핵심 저서/문서:** 1974년 논문 "On the role of scientific thought"에서 이 용어를 공식적으로 사용하며 소프트웨어 공학의 핵심 원리로 자리 잡게 했습니다. 그는 복잡한 문제를 한 번에 해결하려 하지 말고, 다루기 쉬운 작은 문제로 분해하여 해결해야 한다고 주장했습니다.


##### **상세 설명**

하나의 코드 덩어리가 여러 관심사를 동시에 처리하면, 코드는 금방 복잡해지고 이해하기 어려워집니다. 예를 들어, 웹 페이지를 표시하는 코드 안에 데이터베이스 쿼리문과 HTML 템플릿, 사용자 입력 유효성 검사 로직이 모두 섞여 있다면 어떨까요? UI를 조금 수정하는 작업이 데이터베이스 로직에 영향을 미칠 수 있고, 데이터베이스 스키마 변경이 UI 코드를 망가뜨릴 수 있습니다.

SoC는 이러한 '얽힘(tangling)'을 방지합니다. 각 모듈은 하나의 주된 관심사에만 집중하도록 설계됩니다. 이로 인해 각 부분을 독립적으로 개발, 테스트, 수정, 재사용하기가 훨씬 수월해집니다. 현대적인 거의 모든 아키텍처 패턴(MVC, MVVM, 클린 아키텍처 등)은 이 SoC 원칙에 깊이 뿌리를 두고 있습니다.


##### **TypeScript (React) 예시**

**[위반 사례]** 하나의 컴포넌트 안에서 데이터 페칭, 상태 관리, 렌더링(UI)이라는 여러 관심사가 섞여 있습니다.

```typescript
// Bad: Violates SoC - A "God Component"
import React, { useState, useEffect } from 'react';

function UserProfile() {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  // 관심사 1: 데이터 페칭 (Data Fetching)
  useEffect(() => {
    fetch('https://api.example.com/users/1')
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setIsLoading(false);
      });
  }, []);

  // 관심사 2: 렌더링 로직 (Rendering Logic)
  if (isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
    </div>
  );
}
```

**[준수 사례]** 각 관심사를 별도의 모듈(함수, 커스텀 훅, 컴포넌트)로 분리합니다.

```typescript
// Good: Adheres to SoC

// 관심사 1: API 서비스 (분리된 모듈)
// api/userService.ts
export const fetchUser = async (userId: number) => {
  const response = await fetch(`https://api.example.com/users/${userId}`);
  if (!response.ok) throw new Error('Failed to fetch user');
  return response.json();
};

// 관심사 2: 상태 관리 로직 (커스텀 훅)
// hooks/useUser.ts
import { useState, useEffect } from 'react';
import { fetchUser } from '../api/userService';

export function useUser(userId: number) {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(data => {
      setUser(data);
      setIsLoading(false);
    });
  }, [userId]);

  return { user, isLoading };
}

// 관심사 3: 순수 프레젠테이션 컴포넌트
// components/UserProfileView.tsx
import React from 'react';

export function UserProfileView({ user }) {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
    </div>
  );
}

// 최상위 컨테이너 컴포넌트 (관심사들을 조립)
// containers/UserProfile.tsx
import React from 'react';
import { useUser } from '../hooks/useUser';
import { UserProfileView } from '../components/UserProfileView';

export function UserProfile({ userId }) {
    const { user, isLoading } = useUser(userId);

    if (isLoading) return <div>Loading...</div>;
    if (!user) return <div>User not found.</div>;

    return <UserProfileView user={user} />;
}
```


##### **장점**

- **모듈성(Modularity):** 시스템을 독립적인 모듈의 조합으로 구성할 수 있습니다.
- **재사용성:** 특정 관심사를 다루는 모듈(예: API 서비스)은 다른 부분에서도 쉽게 재사용할 수 있습니다.
- **병렬 개발:** 여러 개발자가 서로 다른 관심사(모듈)를 동시에 작업할 수 있어 생산성이 향상됩니다.


##### **더 찾아볼 자료**

- **MVC (Model-View-Controller) 패턴:** SoC를 웹 프레임워크에 적용한 가장 고전적이고 유명한 사례입니다.
- **Aspect-Oriented Programming (AOP):** 로깅, 트랜잭션과 같이 시스템 전반에 흩어져 있는 '횡단 관심사(Cross-cutting concerns)'를 분리하기 위한 고급 프로그래밍 패러다임입니다.

---


#### **2.1.2. 계층형 아키텍처 원칙 (Layered Architecture)**


##### **핵심 아이디어**

> "Structure a system into groups of subtasks at particular levels of abstraction, with each layer providing services to the next higher layer."
>
> "시스템을 특정 추상화 수준의 하위 작업 그룹(계층)으로 구성하라. 각 계층은 바로 위 상위 계층에게 서비스를 제공한다."

계층형 아키텍처는 SoC를 적용하는 구체적인 방법 중 하나로, 시스템을 수평적인 계층(Layer)으로 나누어 구성하는 방식입니다. 가장 중요한 규칙은 **'의존성 방향의 일관성'** 입니다. 즉, 상위 계층은 바로 아래 하위 계층에만 의존해야 하며, 하위 계층은 상위 계층에 대해 아무것도 알아서는 안 됩니다.


##### **상세 설명**

전형적인 N-Tier(N계층) 아키텍처는 다음과 같은 계층으로 구성됩니다.

1. **프레젠테이션 계층 (Presentation Layer / UI Layer):** 사용자에게 정보를 보여주고(View) 사용자 입력을 받는(Controller) 역할. (예: 웹 브라우저, 모바일 앱 UI)
2. **비즈니스 계층 (Business Layer / Application Layer):** 시스템의 핵심 비즈니스 로직과 규칙을 처리. 프레젠테이션 계층으로부터 요청을 받아 데이터 계층을 활용해 작업을 수행. (예: 주문 처리, 결제 로직)
3. **영속성 계층 (Persistence Layer / Data Access Layer):** 데이터베이스나 파일 시스템과 같이 데이터의 저장 및 조회를 담당. (예: Repository, DAO)
4. **데이터베이스 계층 (Database Layer):** 실제 데이터가 저장되는 물리적인 저장소.

이 구조에서 프레젠테이션 계층은 비즈니스 계층의 존재는 알지만, 영속성 계층이나 데이터베이스의 존재는 전혀 알지 못합니다. 이러한 엄격한 분리는 각 계층을 독립적으로 개발하고 교체할 수 있게 만듭니다. 예를 들어, 데이터베이스를 MySQL에서 PostgreSQL로 변경하더라도 영속성 계층의 내부 구현만 수정하면 될 뿐, 비즈니스 계층이나 프레젠테이션 계층은 아무런 영향을 받지 않습니다.


##### **TypeScript (Node.js/Express) 예시**

**[위반 사례]** Express 라우트 핸들러가 비즈니스 로직과 데이터베이스 쿼리를 모두 처리합니다.

```typescript
// Bad: No layering. All concerns are mixed in the route handler.
import express from 'express';
import { PrismaClient } from '@prisma/client';

const app = express();
const prisma = new PrismaClient();

app.post('/users', async (req, res) => {
  // 1. Presentation/Controller Logic
  const { email, name } = req.body;

  // 2. Business Logic
  if (!email || !name) {
    return res.status(400).send('Email and name are required.');
  }
  if (name.length > 50) {
    return res.status(400).send('Name is too long.');
  }
  
  // 3. Data Access Logic
  const user = await prisma.user.create({
    data: { email, name },
  });

  res.status(201).json(user);
});
```

**[준수 사례]** 책임을 Controller, Service, Repository 계층으로 분리합니다.

```typescript
// Good: Adheres to Layered Architecture

// 1. Presentation Layer (controller) - user.controller.ts
import { UserService } from './user.service';

export class UserController {
  private userService = new UserService();

  async createUser(req, res) {
    try {
      const user = await this.userService.createUser(req.body);
      res.status(201).json(user);
    } catch (error) {
      res.status(400).send(error.message);
    }
  }
}

// 2. Business Layer (service) - user.service.ts
import { UserRepository } from './user.repository';
import { User } from '@prisma/client';

export class UserService {
  private userRepository = new UserRepository();

  async createUser(userData: { email: string, name: string }): Promise<User> {
    const { email, name } = userData;
    // Business logic
    if (!email || !name) throw new Error('Email and name are required.');
    if (name.length > 50) throw new Error('Name is too long.');

    // Delegate data operations to the repository layer
    return this.userRepository.create({ email, name });
  }
}

// 3. Persistence Layer (repository) - user.repository.ts
import { PrismaClient, User } from '@prisma/client';

export class UserRepository {
  private prisma = new PrismaClient();

  async create(data: { email: string, name: string }): Promise<User> {
    return this.prisma.user.create({ data });
  }
}
```


##### **장점**

- **유지보수 용이성:** 각 계층이 명확히 분리되어 있어 특정 기능의 수정 및 디버깅이 용이합니다.
- **기술 교체 유연성:** 한 계층의 구현 기술을 다른 기술로 교체하기 쉽습니다. (예: ORM 변경, UI 프레임워크 변경)
- **테스트 용이성:** 각 계층을 독립적으로 테스트할 수 있습니다. (예: Repository를 Mocking하고 Service 계층만 테스트)


##### **더 찾아볼 자료**

- **클린 아키텍처(Clean Architecture):** 로버트 C. 마틴이 제안한, 계층형 아키텍처를 더욱 발전시킨 모델로, 의존성 규칙을 통해 비즈니스 로직을 외부 환경(UI, DB, 프레임워크)으로부터 철저히 보호합니다.
- **헥사고날 아키텍처(Hexagonal Architecture / Ports and Adapters):** 애플리케이션의 핵심 로직(내부)과 외부 서비스(외부)를 '포트'와 '어댑터'로 분리하는 아키텍처로, 계층형 아키텍처의 변형입니다.


### **2.2. 정보 은닉 및 캡슐화 (Information Hiding & Encapsulation)**

이 두 원칙은 종종 혼용되지만, 미묘한 차이가 있습니다. 둘 다 객체의 내부를 보호하고 복잡성을 감추는 것을 목표로 합니다.

---


#### **2.2.1. 정보 은닉 원칙 (Information Hiding)**


##### **핵심 아이디어**

> "Hide design decisions in a module that are most likely to change, thus protecting other parts of the system from change if the design decision is changed."
>
> "가장 변경될 가능성이 높은 설계 결정을 모듈 안에 숨겨라. 이를 통해 그 설계 결정이 변경되더라도 시스템의 다른 부분이 변경으로부터 보호되도록 하라."

정보 은닉은 단순히 데이터 필드를 `private`으로 만드는 것 이상의 의미를 가집니다. 이는 '구현 세부사항' 자체를 숨기는 설계 원리입니다. 여기서 구현 세부사항이란 사용된 자료구조, 특정 알고리즘, 외부 라이브러리 호출 방식 등, 모듈의 외부에서는 알 필요가 없는 모든 것을 의미합니다.


##### **출처 및 신뢰성**

- **창시자:** 데이비드 파르나스(David Parnas)
- **핵심 저서/문서:** 1972년 발표한 기념비적인 논문 **"On the Criteria To Be Used in Decomposing Systems into Modules"** 에서 이 개념을 처음 제시했습니다. 그는 모듈화의 기준이 '기능'이 아니라 '숨겨야 할 설계 결정'이 되어야 한다고 주장했습니다.


##### **상세 설명**

정보 은닉의 목표는 모듈의 내부 구현과 외부 인터페이스를 완벽하게 분리하는 것입니다. 클라이언트는 오직 공개된 인터페이스(API)에만 의존해야 합니다. 이렇게 하면, 모듈의 내부 구현(예: 데이터를 `Array`에 저장하던 것을 `Map`으로 바꾸는 것)을 변경하더라도, 인터페이스에 변경이 없다면 클라이언트 코드는 전혀 수정할 필요가 없습니다. 이는 시스템의 결합도를 낮추고 유연성을 극대화하는 핵심적인 방법입니다.


##### **TypeScript 예시**

**[위반 사례]** 통계 계산기의 내부 데이터 구조(`Array`)가 외부에 그대로 노출됩니다.

```typescript
// Bad: Violates Information Hiding
class StatsCalculator {
  // 내부 데이터 구조가 public으로 노출됨
  public numbers: number[] = [];

  add(n: number) {
    this.numbers.push(n);
  }

  getMean() {
    const sum = this.numbers.reduce((a, b) => a + b, 0);
    return sum / this.numbers.length;
  }
}

const stats = new StatsCalculator();
// 클라이언트가 내부 데이터 구조에 직접 접근하여 조작함
stats.numbers.push(10);
stats.numbers.push(20);
// 만약 StatsCalculator 내부를 `Set`으로 바꾼다면 이 코드는 동작하지 않음.
console.log(stats.getMean());
```

**[준수 사례]** 내부 데이터 구조를 `private`으로 숨기고, 공개된 메서드를 통해서만 상호작용하도록 합니다.

```typescript
// Good: Adheres to Information Hiding
class StatsCalculator {
  // 설계 결정(Array 사용)이 외부에 숨겨짐
  private numbers: number[] = [];

  // 공개된 인터페이스(메서드)
  public add(n: number): void {
    this.numbers.push(n);
  }

  public getMean(): number {
    if (this.numbers.length === 0) return 0;
    const sum = this.numbers.reduce((a, b) => a + b, 0);
    return sum / this.numbers.length;
  }
}

const stats = new StatsCalculator();
// 클라이언트는 내부가 어떻게 동작하는지 모르고, 공개된 인터페이스만 사용
stats.add(10);
stats.add(20);
console.log(stats.getMean()); // 내부 구현이 Array든 Set이든 이 코드는 항상 동작
```


##### **장점**

- **결합도 감소:** 모듈의 내부 변경이 외부에 미치는 영향을 차단하여 결합도를 낮춥니다.
- **유지보수성 향상:** 변경의 파급 효과가 해당 모듈 내로 한정되므로 유지보수가 쉬워집니다.
- **시스템 안정성:** 클라이언트가 모듈의 내부 상태를 직접 조작하여 망가뜨리는 것을 방지합니다.


##### **더 찾아볼 자료**

- **API (Application Programming Interface):** 정보 은닉 원칙을 실현하는 가장 대표적인 결과물입니다. 잘 설계된 API는 내부 구현을 완벽히 숨깁니다.

---


#### **2.2.2. 캡슐화 원칙 (Encapsulation)**


##### **핵심 아이디어**

> "The bundling of data, and the methods that operate on that data, into a single unit or 'object'."
>
> "데이터와 그 데이터에 대해 작동하는 메서드를 하나의 단위, 즉 '객체'로 묶는 것."

캡슐화는 객체지향 프로그래밍의 핵심 개념 중 하나로, 연관된 데이터(속성)와 행위(메서드)를 하나의 캡슐(클래스)로 묶는 것을 의미합니다. 이를 통해 객체의 상태(데이터)는 오직 그 객체의 메서드를 통해서만 접근하고 변경할 수 있도록 제한할 수 있습니다.


##### **상세 설명**

정보 은닉이 '무엇을 숨길 것인가'에 대한 설계 원리라면, 캡슐화는 그것을 달성하기 위한 '구체적인 기술 또는 메커니즘'입니다. 대부분의 객체지향 언어는 `class`, `private`, `public` 같은 키워드를 통해 캡슐화를 지원합니다.

캡슐화의 주된 목적은 객체의 '상태 일관성'과 '무결성'을 보장하는 것입니다. 예를 들어, `BankAccount` 객체의 `balance`(잔액)는 음수가 될 수 없다는 규칙(불변식, invariant)이 있다면, `balance` 필드를 `public`으로 두어서는 안 됩니다. 대신 `private`으로 숨기고, `deposit`(입금)과 `withdraw`(출금) 메서드를 통해서만 `balance`를 변경하도록 해야 합니다. `withdraw` 메서드 안에서는 잔액이 음수가 되지 않도록 검사하는 로직을 추가하여 객체의 무결성을 지킬 수 있습니다.


##### **TypeScript 예시**

**[위반 사례]** `BankAccount`의 `balance`가 외부에서 직접 수정될 수 있어, 객체의 상태가 깨질 수 있습니다.

```typescript
// Bad: No encapsulation
class BankAccount {
  public owner: string;
  public balance: number = 0; // Public field, can be modified directly

  constructor(owner: string) {
    this.owner = owner;
  }
}

const myAccount = new BankAccount("John Doe");
// 객체의 규칙을 무시하고 상태를 직접 변경 (잔액이 음수가 됨)
myAccount.balance = -1000;
console.log(myAccount.balance); // -1000. 객체의 무결성이 깨짐.
```

**[준수 사례]** `balance`를 `private`으로 캡슐화하고, `public` 메서드를 통해 상태를 안전하게 변경합니다.

```typescript
// Good: Proper encapsulation
class BankAccount {
  public readonly owner: string; // 읽기 전용으로 외부 노출
  private _balance: number = 0;  // 데이터는 private으로 캡슐화

  constructor(owner: string, initialBalance: number = 0) {
    this.owner = owner;
    if(initialBalance > 0) {
      this._balance = initialBalance;
    }
  }

  // Public 메서드를 통해 내부 상태에 접근
  public getBalance(): number {
    return this._balance;
  }

  public deposit(amount: number): void {
    if (amount <= 0) {
      throw new Error("Deposit amount must be positive.");
    }
    this._balance += amount;
  }

  public withdraw(amount: number): void {
    if (amount <= 0) {
      throw new Error("Withdraw amount must be positive.");
    }
    if (amount > this._balance) {
      throw new Error("Insufficient funds.");
    }
    this._balance -= amount;
  }
}

const myAccount = new BankAccount("Jane Doe", 100);
myAccount.deposit(50);
// myAccount._balance = -1000; // Error: Property '_balance' is private.
try {
    myAccount.withdraw(200); // Throws "Insufficient funds."
} catch (e) {
    console.error(e.message);
}
console.log(myAccount.getBalance()); // 150. 객체의 상태가 안전하게 유지됨.
```


##### **장점**

- **데이터 무결성:** 객체의 내부 상태가 임의로 변경되는 것을 막아 일관성을 유지합니다.
- **복잡성 감소:** 클라이언트는 객체의 복잡한 내부 동작을 알 필요 없이, 단순한 공개 메서드만 사용하면 됩니다.
- **유지보수 용이성:** 데이터와 관련된 모든 로직이 한 클래스 안에 모여 있어 코드를 이해하고 수정하기 쉽습니다.


##### **더 찾아볼 자료**

- **객체지향 프로그래밍(OOP)의 4대 특성:** 캡슐화는 상속, 다형성, 추상화와 함께 OOP를 구성하는 핵심 기둥 중 하나입니다.

**[준수 사례]** `PaymentGateway` 인터페이스를 만들고, 각 결제 방식은 이 인터페이스를 구현하는 클래스로 만듭니다. `PaymentProcessor`는 인터페이스에만 의존합니다.

```typescript
// Good: Adheres to OCP

interface PaymentGateway {
  pay(amount: number): void;
}

class CreditCardGateway implements PaymentGateway {
  pay(amount: number): void {
    console.log(`Processing credit card payment of $${amount}`);
  }
}

class PayPalGateway implements PaymentGateway {
  pay(amount: number): void {
    console.log(`Processing PayPal payment of $${amount}`);
  }
}

// 새로운 결제 방식 추가: 새로운 클래스만 만들면 됨
class CryptoGateway implements PaymentGateway {
  pay(amount: number): void {
    console.log(`Processing Crypto payment of $${amount}`);
  }
}

// PaymentProcessor는 수정할 필요가 없음 (Closed for modification)
class PaymentProcessor {
  process(gateway: PaymentGateway, amount: number): void {
    gateway.pay(amount);
  }
}

// 사용 예시
const processor = new PaymentProcessor();
processor.process(new CreditCardGateway(), 100);
processor.process(new CryptoGateway(), 50); // 새로운 기능이 쉽게 확장됨 (Open for extension)
```


##### **장점**

- **안정성:** 기존의 검증된 코드를 수정하지 않으므로 시스템의 안정성이 높아집니다.
- **유연성 및 확장성:** 새로운 기능을 쉽게 추가할 수 있는 '플러그인(Plug-in)' 아키텍처를 구현할 수 있습니다.
- **유지보수성:** 기능 확장에 따른 코드 변경 범위가 최소화됩니다.


##### **더 찾아볼 자료**

- **Strategy Pattern:** OCP를 구현하는 가장 대표적인 디자인 패턴 중 하나입니다.
- **Template Method Pattern:** 상속을 통해 OCP를 구현하는 또 다른 고전적인 패턴입니다.

---


#### **1.1.3. 리스코프 치환 원칙 (LSP: Liskov Substitution Principle)**


##### **핵심 아이디어**

> "Subtypes must be substitutable for their base types."
>
> "서브타입은 언제나 그것의 기반 타입으로 교체될 수 있어야 한다."

즉, 부모 클래스의 인스턴스를 사용하는 곳에 자식 클래스의 인스턴스를 대신 넣어도 프로그램의 의미나 기능이 변하지 않고 정상적으로 동작해야 합니다.


##### **상세 설명**

LSP는 상속 관계의 '행위적 계약'을 강조하는 원칙입니다. 자식 클래스는 부모 클래스의 기능을 단순히 재정의(override)하는 것을 넘어, 부모 클래스가 정의한 규약(예: 메서드 파라미터 타입, 리턴 타입, 발생시키는 예외, 사전/사후 조건 등)을 반드시 지켜야 합니다.

만약 자식 클래스가 부모 클래스의 규약을 위반하면, 클라이언트 코드에서는 `instanceof`와 같은 타입 체크를 통해 자식 클래스의 종류에 따라 분기 처리를 해야 하는 상황이 발생합니다. 이는 OCP를 위반하게 만들며, 시스템의 복잡도를 높이는 원인이 됩니다.


##### **TypeScript (Conceptual) 예시**

**[위반 사례]** 정사각형(`Square`)이 직사각형(`Rectangle`)을 상속받는 고전적인 예시입니다. 수학적으로는 맞지만, 프로그래밍에서는 LSP를 위반할 수 있습니다.

```typescript
// Bad: Violates LSP
class Rectangle {
  protected width: number = 0;
  protected height: number = 0;

  setWidth(width: number): void {
    this.width = width;
  }

  setHeight(height: number): void {
    this.height = height;
  }

  getArea(): number {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  // Square는 너비와 높이가 같아야 한다는 제약 조건을 추가함
  setWidth(width: number): void {
    this.width = width;
    this.height = width; // 부모의 행위(높이는 그대로)를 변경
  }

  setHeight(height: number): void {
    this.width = height;
    this.height = height; // 부모의 행위(너비는 그대로)를 변경
  }
}

// 클라이언트 코드
function printArea(rectangle: Rectangle) {
  rectangle.setWidth(5);
  rectangle.setHeight(4);
  const area = rectangle.getArea();
  // 클라이언트는 area가 20 (5 * 4)이 될 것이라고 기대한다.
  console.log(`Expected area: 20, Actual area: ${area}`);
}

const rect = new Rectangle();
const sq = new Square();

printArea(rect); // Expected area: 20, Actual area: 20 -> OK
printArea(sq);   // Expected area: 20, Actual area: 16 -> NOT OK! (LSP 위반)
```

`Square` 객체를 `printArea` 함수에 전달했을 때, 클라이언트의 기대와 다른 결과가 나옵니다. `Square`는 `Rectangle`을 대체할 수 없습니다.

**[준수 사례]** 상속 관계를 재고려합니다. 정사각형과 직사각형의 공통적인 특성을 가진 `Shape` 같은 인터페이스를 도입하고, 상속을 사용하지 않거나, 계층 구조를 다르게 설계합니다. 여기서는 상속이 적절하지 않다는 것을 보여줍니다.


##### **장점**

- **신뢰성 있는 상속 구조:** 다형성을 믿고 사용할 수 있게 되어 코드의 신뢰성이 높아집니다.
- **코드의 재사용성:** 부모 클래스를 사용하는 코드를 자식 클래스에서도 그대로 재사용할 수 있습니다.
- **예측 가능성:** 객체의 동작을 예측하기 쉬워집니다.


##### **더 찾아볼 자료**

- **Barbara Liskov (창시자):** 1988년 컨퍼런스에서 이 원칙을 처음 소개했습니다. 그녀의 관련 논문을 찾아보면 원칙의 수학적, 이론적 배경을 이해할 수 있습니다.
- **계약에 의한 설계 (Design by Contract):** LSP는 계약에 의한 설계의 개념과 깊은 관련이 있습니다.

---


#### **1.1.4. 인터페이스 분리 원칙 (ISP: Interface Segregation Principle)**


##### **핵심 아이디어**

> "Clients should not be forced to depend upon interfaces that they do not use."
>
> "클라이언트는 자신이 사용하지 않는 메서드에 의존하도록 강요받아서는 안 된다."

ISP는 '비대한(fat)' 인터페이스를 지양하고, 클라이언트의 목적과 역할에 맞게 인터페이스를 잘게 분리하라는 원칙입니다.


##### **상세 설명**

하나의 인터페이스가 너무 많은 기능을 담고 있으면, 그 인터페이스를 구현하는 클래스는 자신이 사용하지도 않는 메서드까지 억지로 구현해야 하는 상황이 발생합니다. 이는 불필요한 코드, 빈 구현(empty implementation)을 낳고, 한 메서드의 인터페이스 변경이 그 메서드를 사용하지 않는 다른 클래스들에게까지 영향을 미치는 문제를 야기합니다.

ISP는 SRP의 인터페이스 버전이라고도 볼 수 있습니다. SRP가 클래스의 책임을 분리한다면, ISP는 인터페이스의 책임을 분리합니다.


##### **TypeScript 예시**

**[위반 사례]** `Worker` 인터페이스가 너무 많은 책임을 가지고 있습니다. `Robot`은 일은 할 수 있지만, 먹거나 쉴 수는 없습니다.

```typescript
// Bad: Violates ISP (Fat Interface)
interface Worker {
  work(): void;
  eat(): void;
  sleep(): void;
}

class HumanWorker implements Worker {
  work(): void { console.log('Working...'); }
  eat(): void { console.log('Eating...'); }
  sleep(): void { console.log('Sleeping...'); }
}

class RobotWorker implements Worker {
  work(): void { console.log('Working much faster!'); }

  // 로봇은 먹거나 잘 필요가 없지만, 인터페이스 때문에 억지로 구현해야 함
  eat(): void { /* do nothing */ }
  sleep(): void { /* do nothing */ }
}
```

**[준수 사례]** 역할을 기준으로 인터페이스를 잘게 분리합니다.

```typescript
// Good: Adheres to ISP

interface Workable {
  work(): void;
}

interface Eatable {
  eat(): void;
}

interface Sleepable {
    sleep(): void;
}

// 각 클래스는 자신이 필요한 인터페이스만 구현(implements)한다.
class HumanWorker implements Workable, Eatable, Sleepable {
  work(): void { console.log('Working...'); }
  eat(): void { console.log('Eating...'); }
  sleep(): void { console.log('Sleeping...'); }
}

class RobotWorker implements Workable {
  work(): void { console.log('Working much faster!'); }
}

// 클라이언트 코드
function manageWork(worker: Workable) {
    worker.work();
}

manageWork(new HumanWorker());
manageWork(new RobotWorker()); // 둘 다 Workable이므로 문제 없음
```


##### **장점**

- **결합도 감소:** 클라이언트와 구현체 사이의 결합도를 낮추어 시스템을 유연하게 만듭니다.
- **높은 응집도:** 인터페이스가 특정 역할에 집중하므로 응집도가 높아집니다.
- **시스템 유연성:** 클래스가 필요한 인터페이스만 선택적으로 구현할 수 있어 유연성이 증대됩니다.


##### **더 찾아볼 자료**

- **Role Interface Pattern:** ISP는 객체가 수행하는 역할(Role)마다 인터페이스를 제공하는 패턴과 밀접한 관련이 있습니다.

---


#### **1.1.5. 의존성 역전 원칙 (DIP: Dependency Inversion Principle)**


##### **핵심 아이디어**

> A. High-level modules should not depend on low-level modules. Both should depend on abstractions.
>
> B. Abstractions should not depend on details. Details should depend on abstractions.
>
> A. 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
>
> B. 추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다.

DIP는 의존 관계를 맺을 때, 구체적인 클래스(세부 사항)가 아닌 추상화(인터페이스, 추상 클래스)에 의존해야 한다는 원칙입니다. 이를 통해 모듈 간의 결합도를 극단적으로 낮출 수 있습니다.


##### **상세 설명**

전통적인 절차적 프로그래밍에서는 상위 수준 모듈이 하위 수준 모듈을 직접 호출하고 의존하는 구조를 가집니다. 예를 들어, `알림 서비스`(상위)가 `이메일 전송기`(하위)를 직접 생성하고 사용하는 식입니다. 이 경우, `이메일`을 `SMS`로 바꾸려면 `알림 서비스` 코드를 직접 수정해야 합니다.

DIP는 이 의존성의 방향을 '역전'시킵니다. 상위 모듈과 하위 모듈 사이에 '추상화'라는 계층을 둡니다. 상위 모듈은 이 추상화에만 의존하고, 하위 모듈은 이 추상화를 구현합니다. 실제 객체는 외부에서 생성하여 주입(Injection)해주는 방식을 사용합니다.


##### **TypeScript 예시**

**[위반 사례]** `Notification` 서비스가 구체적인 `EmailClient` 클래스에 직접 의존합니다.

```typescript
// Bad: Violates DIP

// Low-level module
class EmailClient {
  send(message: string): void {
    console.log(`Sending email: ${message}`);
  }
}

// High-level module
class NotificationService {
  private emailClient: EmailClient;

  constructor() {
    this.emailClient = new EmailClient(); // 구체 클래스에 직접 의존!
  }

  sendNotification(message: string): void {
    this.emailClient.send(message);
  }
}
```

**[준수 사례]** `MessageClient`라는 추상화(인터페이스)를 도입하고, `Notification` 서비스는 이 인터페이스에만 의존합니다.

```typescript
// Good: Adheres to DIP

// Abstraction
interface MessageClient {
  send(message: string): void;
}

// Low-level module (Detail)
class EmailClient implements MessageClient {
  send(message: string): void {
    console.log(`Sending email: ${message}`);
  }
}

// Another low-level module (Detail)
class SmsClient implements MessageClient {
  send(message: string): void {
    console.log(`Sending SMS: ${message}`);
  }
}

// High-level module
class NotificationService {
  // 추상화에 의존!
  private client: MessageClient;

  // 의존성 주입(Dependency Injection)
  constructor(client: MessageClient) {
    this.client = client;
  }

  sendNotification(message: string): void {
    this.client.send(message);
  }
}

// 사용 예시: 의존성이 역전되고 외부에서 주입됨
const emailNotifier = new NotificationService(new EmailClient());
emailNotifier.sendNotification("Hello via Email!");

const smsNotifier = new NotificationService(new SmsClient());
smsNotifier.sendNotification("Hello via SMS!");
```


##### **장점**

- **최상의 유연성:** 하위 모듈(세부 구현)을 쉽게 교체할 수 있습니다. 예를 들어, 실제 이메일 클라이언트 대신 테스트용 Mock 객체를 주입하여 단위 테스트를 매우 쉽게 만들 수 있습니다.
- **결합도 최소화:** 모듈들이 추상화에만 의존하므로 결합도가 크게 낮아집니다.
- **재사용성 극대화:** 상위 모듈은 하위 모듈의 구현에 상관없이 재사용될 수 있습니다.


##### **더 찾아볼 자료**

- **의존성 주입 (Dependency Injection, DI):** DIP를 구현하는 가장 흔한 기술적 메커니즘입니다.
- **제어의 역전 (Inversion of Control, IoC):** DI는 더 큰 개념인 IoC의 한 형태입니다. 객체의 생성과 생명주기를 외부(IoC 컨테이너)가 관리하는 패러다임입니다. NestJS, Spring, Angular와 같은 프레임워크의 핵심 원리입니다.

물론입니다. 목차의 세 번째 대단원, **"컴포넌트 및 서비스 설계 원칙"** 에 대한 전문적인 설명을 시작하겠습니다. 이 원칙들은 개별 클래스를 넘어, 시스템을 구성하는 더 큰 단위인 컴포넌트(라이브러리, 모듈, 마이크로서비스 등)를 어떻게 설계하고 관계 맺을 것인지에 대한 지침을 제공합니다.

---


### **3. 컴포넌트 및 서비스 설계 원칙 (Component & Service Design Principles)**

SOLID 원칙이 벽돌(클래스)을 잘 만드는 법을 알려준다면, 컴포넌트 설계 원칙은 그 벽돌들을 모아 어떻게 견고한 방(컴포넌트)을 만들고, 그 방들을 어떻게 배치하여 튼튼한 건물(소프트웨어)을 지을 것인지에 대한 원칙입니다. 여기서 '컴포넌트'란 독립적으로 배포하고 재사용할 수 있는 소프트웨어의 단위(예: npm 패키지, Java의 JAR 파일, .NET의 DLL, 마이크로서비스)를 의미합니다.

이 원칙들은 거대한 소프트웨어 시스템의 의존성 구조를 관리하여, 시스템을 유지보수 가능하고, 배포 가능하며, 이해하기 쉽게 만드는 것을 목표로 합니다.


### **3.1. 결합도와 응집도 (Coupling and Cohesion)**

이 두 가지는 소프트웨어 설계의 품질을 측정하는 가장 근본적인 척도입니다. 모든 컴포넌트 설계 원칙은 결국 **'높은 응집도'** 와 **'낮은 결합도'** 라는 두 가지 목표를 달성하기 위한 구체적인 전략이라고 볼 수 있습니다.

---


#### **3.1.1. 높은 응집도 (High Cohesion)**


##### **핵심 아이디어**

> "The elements of a module should belong together."
>
> "하나의 모듈(컴포넌트)을 구성하는 요소들은 서로 긴밀하게 연관되어 있어야 한다."

응집도는 하나의 컴포넌트가 단일하고 잘 정의된 목적을 가지고 있는지를 나타내는 척도입니다. 응집도가 높다는 것은 컴포넌트 내의 모든 클래스, 함수, 데이터가 해당 컴포넌트의 주된 책임을 수행하기 위해 존재한다는 의미입니다. 마치 잘 정리된 주방 서랍에 조리 도구만 모여 있는 것과 같습니다.


##### **상세 설명**

높은 응집도를 가진 컴포넌트는 이해하기 쉽고 재사용하기 좋습니다. 해당 컴포넌트가 어떤 일을 하는지 명확하기 때문입니다. 반대로 낮은 응집도를 가진 컴포넌트는 서로 관련 없는 기능들이 잡다하게 섞여 있습니다(마치 '잡동사니 서랍'처럼). 예를 들어, 결제 처리, 사용자 인증, 이미지 렌더링 기능이 모두 `common-utils`라는 하나의 컴포넌트에 들어있다면, 이는 응집도가 매우 낮은 것입니다. 이 경우, 이미지 렌더링 기능만 필요한 클라이언트도 불필요하게 결제 처리 코드에 의존하게 됩니다.


##### **TypeScript (Conceptual) 예시**

**[낮은 응집도]**

```typescript
// Bad: Low Cohesion - "common" component
// src/common-component/index.ts
export * from './payment-processor'; // 결제 관련
export * from './user-authenticator'; // 인증 관련
export * from './image-resizer';      // 이미지 처리 관련
export * from './currency-formatter'; // 통화 포맷팅 관련
```

**[높은 응집도]** 각 책임을 별도의 컴포넌트(패키지)로 분리합니다.

```typescript
// Good: High Cohesion - focused components

// src/billing-component/index.ts
export * from './payment-processor';
export * from './invoice-generator';
export * from './tax-calculator';

// src/auth-component/index.ts
export * from './user-authenticator';
export * from './permission-checker';
```

`billing-component`는 오직 '청구'와 관련된 책임만 가집니다.


##### **더 찾아볼 자료**

- **단일 책임 원칙 (SRP):** 높은 응집도는 SRP를 컴포넌트 수준으로 확장한 개념으로 볼 수 있습니다.

---


#### **3.1.2. 낮은 결합도 (Low Coupling)**


##### **핵심 아이디어**

> "A change in one module should have minimal impact on other modules."
>
> "하나의 모듈 변경이 다른 모듈에 미치는 영향을 최소화해야 한다."

결합도는 한 컴포넌트가 다른 컴포넌트에 대해 얼마나 많이 알고 있고, 얼마나 의존적인지를 나타내는 척도입니다. 결합도가 낮다는 것은 각 컴포넌트가 독립적으로 존재하며, 다른 컴포넌트의 내부 구현에 대해 거의 알지 못한다는 의미입니다. 마치 USB 포트처럼, 표준화된 인터페이스를 통해 연결되므로 어떤 장치(마우스, 키보드)를 연결하든 컴퓨터 본체를 수정할 필요가 없는 것과 같습니다.


##### **상세 설명**

결합도가 높으면 '파급 효과(Ripple Effect)'가 발생합니다. 한 컴포넌트를 수정했을 때, 그 컴포넌트에 의존하는 다른 모든 컴포넌트까지 연쇄적으로 수정하거나 재테스트해야 합니다. 이는 시스템을 경직되고(Rigid), 깨지기 쉽게(Fragile) 만듭니다. 낮은 결합도는 컴포넌트 간의 의존성을 최소화하여 이러한 문제를 해결합니다. 주로 인터페이스(추상화)에 의존하고, 구체적인 구현을 숨김으로써 낮은 결합도를 달성할 수 있습니다.


##### **TypeScript 예시**

**[높은 결합도]** `ReportService`가 구체적인 `MySqlDatabase` 클래스에 직접 의존합니다.

```typescript
// Bad: High Coupling
import { MySqlDatabase } from './mysql-database';

class ReportService {
  private db: MySqlDatabase = new MySqlDatabase(); // 구체 클래스에 직접 의존

  generateReport() {
    const data = this.db.query('SELECT * FROM sales');
    // ... report generation logic
  }
}
```

**[낮은 결합도]** `ReportService`는 `Database` 인터페이스에만 의존합니다.

```typescript
// Good: Low Coupling

// 추상화 인터페이스
interface Database {
  query(sql: string): any[];
}

// 구체적인 구현
class MySqlDatabase implements Database { /* ... */ }
class PostgreSqlDatabase implements Database { /* ... */ }

// ReportService는 인터페이스에만 의존 (결합도 낮음)
class ReportService {
  private db: Database;

  constructor(database: Database) { // 의존성 주입
    this.db = database;
  }

  generateReport() {
    const data = this.db.query('SELECT * FROM sales');
    // ...
  }
}
```


##### **더 찾아볼 자료**

- **의존성 역전 원칙 (DIP):** 낮은 결합도를 달성하기 위한 가장 핵심적인 원칙입니다.
- **인터페이스(Interface):** 컴포넌트 간의 계약 역할을 하여 결합도를 낮추는 핵심 도구입니다.

---


### **3.2. 컴포넌트 응집도 원칙 (Principles of Component Cohesion)**

> **출처 및 신뢰성:**
>
> - **창시자:** Robert C. Martin ("Uncle Bob")
> - **핵심 저서:** *Agile Software Development, Principles, Patterns, and Practices*, *Clean Architecture*
> - **설명:** 이 세 가지 원칙은 어떤 클래스들을 하나의 컴포넌트로 묶어야 하는지에 대한 지침을 제공합니다. 이 원칙들은 서로 상충하는 경우가 많아, 프로젝트의 상황에 맞게 균형을 맞추는 것이 중요합니다.

---


#### **3.2.1. 재사용-릴리스 등가 원칙 (REP: Reuse/Release Equivalence Principle)**

> "The granule of reuse is the granule of release."
>
> "재사용의 단위는 릴리스의 단위와 같다."

이 원칙은 재사용성에 대한 실용적인 관점을 제시합니다. 개발자들이 진정으로 재사용하고 싶어 하는 것은 개별 클래스가 아니라, 버전 번호가 있고, 문서화가 잘 되어 있으며, 안정적으로 관리되는 '컴포넌트(릴리스 단위)'라는 것입니다. 따라서 재사용될 클래스들은 하나의 컴포넌트로 묶어 함께 릴리스하고 버전 관리를 해야 합니다.

예를 들어, 우리는 `lodash` 라이브러리의 `debounce` 함수 하나만 필요하더라도 `npm install lodash`를 통해 `lodash` 패키지 전체를 설치합니다. 여기서 재사용 단위(함수)와 릴리스 단위(패키지)가 일치하는 것입니다.

---


#### **3.2.2. 공통 폐쇄 원칙 (CCP: Common Closure Principle)**

> "Gather into components those classes that change for the same reasons and at the same times."
>
> "동일한 이유로, 동일한 시점에 변경되는 클래스들은 하나의 컴포넌트로 묶어라."

이것은 **단일 책임 원칙(SRP)** 의 컴포넌트 버전입니다. 어떤 기능 요구사항 변경이 발생했을 때, 여러 컴포넌트를 동시에 수정해야 한다면 이는 CCP를 위반한 것입니다. 변경이 필요한 모든 클래스가 단 하나의 컴포넌트 안에 있다면, 우리는 그 컴포넌트 하나만 새로 릴리스하면 됩니다. 이는 시스템의 유지보수성을 크게 향상시킵니다.

예를 들어, '주문'과 관련된 기능 변경 시 `Order`, `OrderItem`, `OrderValidator` 클래스가 항상 함께 변경된다면, 이들은 `OrderComponent`라는 하나의 컴포넌트에 속해야 합니다.

---


#### **3.2.3. 공통 재사용 원칙 (CRP: Common Reuse Principle)**

> "Don't force users of a component to depend on things they don't need."
>
> "컴포넌트 사용자(다른 컴포넌트)가 필요로 하지 않는 것에 의존하게 만들지 말라."

이것은 **인터페이스 분리 원칙(ISP)** 의 컴포넌트 버전입니다. 하나의 컴포넌트 안에 서로 관련 없는 클래스들을 너무 많이 묶어놓으면, 그중 일부 클래스만 필요한 사용자도 전체 컴포넌트에 의존하게 됩니다. 이 경우, 사용하지도 않는 기능의 변경 때문에 불필요한 재컴파일, 재테스트, 재배포가 발생할 수 있습니다.

예를 들어, 거대한 `MegaUtilsComponent`에 수많은 유틸리티 클래스가 있다면, 이를 `StringUtilsComponent`, `MathUtilsComponent`, `HttpUtilsComponent` 등으로 잘게 쪼개는 것이 CRP를 따르는 것입니다.


### **3.3. 컴포넌트 결합 원칙 (Principles of Component Coupling)**

> **출처 및 신뢰성:**
>
> - **창시자:** Robert C. Martin ("Uncle Bob")
> - **핵심 저서:** *Clean Architecture*
> - **설명:** 이 원칙들은 컴포넌트 간의 의존성 구조를 어떻게 관리해야 하는지에 대한 지침을 제공하며, 변동성이 큰 컴포넌트가 안정적인 컴포넌트에 영향을 주지 못하도록 막는 것을 목표로 합니다.

---


#### **3.3.1. 비순환 의존성 원칙 (ADP: Acyclic Dependencies Principle)**

> "The dependency graph of components must not have any cycles."
>
> "컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안 된다."

컴포넌트 A가 B에 의존하고, B가 C에 의존하는데, C가 다시 A에 의존하는 '순환 의존성'이 발생하면, 이 세 컴포넌트는 사실상 하나의 거대한 컴포넌트처럼 동작하게 됩니다. A, B, C 중 어느 하나만 변경해도 세 컴포넌트 모두를 함께 빌드하고 테스트하고 배포해야 합니다. 이를 '아침 후 증후군(The Morning After Syndrome)'이라고도 부릅니다. 어제는 잘 동작하던 내 컴포넌트가, 밤사이 다른 팀원이 수정한 의존 컴포넌트 때문에 아침에 빌드가 깨지는 현상을 말합니다.

순환 의존성은 **의존성 역전 원칙(DIP)** 을 적용하거나, 순환의 고리가 되는 클래스를 새로운 컴포넌트로 분리하여 해결할 수 있습니다.

---


#### **3.3.2. 안정된 의존성 원칙 (SDP: Stable Dependencies Principle)**

> "Depend in the direction of stability."
>
> "안정성의 방향으로 의존하라."

여기서 **안정성(Stability)** 이란 '변경하기 어려운 정도'를 의미합니다. 어떤 컴포넌트를 의존하는 다른 컴포넌트가 많을수록, 그 컴포넌트는 변경하기 어렵기 때문에 안정적이라고 말합니다.

SDP는 변동성이 큰(불안정한) 컴포넌트가 안정적인 컴포넌트에 의존해야 한다고 말합니다. 반대로 안정적인 컴포넌트가 변동성이 큰 컴포넌트에 의존하면, 변덕스러운 변경사항이 안정적인 코어에까지 영향을 미쳐 시스템 전체를 불안하게 만듭니다.

예를 들어, 자주 변경되는 우리의 `UIComponent`는 거의 변경되지 않는 `CoreFramework` 라이브러리에 의존하는 것이 올바른 방향입니다.

---


#### **3.3.3. 안정된 추상화 원칙 (SAP: Stable Abstractions Principle)**

> "A component should be as abstract as it is stable."
>
> "컴포넌트는 안정적인 만큼 추상적이어야 한다."

이 원칙은 SDP를 보완합니다. 안정적인 컴포넌트는 변경하기가 어렵습니다. 만약 이런 컴포넌트가 구체적인 클래스들로 가득 차 있다면, 확장이 거의 불가능합니다(OCP 위반). 따라서, 안정적인 컴포넌트는 주로 인터페이스나 추상 클래스 같은 '추상화'로 구성되어야 합니다. 그래야만 클라이언트들이 이 추상화를 상속하거나 구현하는 방식으로 기능을 확장할 수 있고, 안정적인 컴포넌트 자체는 수정할 필요가 없게 됩니다.

예를 들어, 데이터베이스 정책을 담고 있는 매우 안정적인 `PolicyComponent`는 구체적인 `MySQLPolicy`를 담고 있는 것이 아니라, `IDatabasePolicy`라는 인터페이스를 담고 있어야 합니다. 그래야 새로운 `PostgreSQLPolicy`를 추가할 때 `PolicyComponent`를 건드리지 않아도 됩니다.

물론입니다. 목차의 네 번째 대단원, **"도메인 주도 설계 원칙"** 에 대한 전문적인 설명을 시작하겠습니다. 이 원칙들은 소프트웨어를 비즈니스 문제 영역(도메인) 중심으로 모델링하여 복잡한 비즈니스 로직을 효과적으로 관리하기 위한 접근법입니다.

---


### **4. 도메인 주도 설계 원칙 (Domain-Driven Design Principles)**

도메인 주도 설계(Domain-Driven Design, DDD)는 기술 중심이 아닌, **소프트웨어가 해결하고자 하는 핵심 비즈니스 문제, 즉 '도메인'에 집중하는** 소프트웨어 개발 접근법입니다. 데이터베이스 스키마나 UI 프레임워크가 아닌, 비즈니스 전문가들이 사용하는 용어와 프로세스를 코드에 직접 반영하여, 복잡한 비즈니스 도메인을 명확하고 유지보수 가능한 형태로 모델링하는 것을 목표로 합니다.

DDD는 단순히 코드를 작성하는 기술이 아니라, 도메인 전문가와 개발자가 긴밀하게 협력하여 비즈니스의 본질을 이해하고 이를 소프트웨어 모델로 표현하는 일련의 철학이자 패턴의 집합입니다.

> **출처 및 신뢰성:**
>
> - **창시자:** 에릭 에반스(Eric Evans)
> - **핵심 저서:** *Domain-Driven Design: Tackling Complexity in the Heart of Software* (2003, "The Blue Book")
> - **관련 저서:** *Implementing Domain-Driven Design* (Vaughn Vernon), *Domain-Driven Design Distilled* (Vaughn Vernon)
> - **커뮤니티:** [DDD Community](https://dddcommunity.org/) 등 전 세계적으로 활발한 커뮤니티가 형성되어 있습니다.

DDD는 크게 두 부분으로 나뉩니다.

- **전략적 설계 (Strategic Design):** 시스템 전체의 큰 그림을 그리고, 복잡한 도메인을 관리 가능한 단위로 나누는 거시적인 접근법입니다.
- **전술적 설계 (Tactical Design):** 나누어진 단위 안에서 도메인 모델을 구체적으로 어떻게 구현할 것인지에 대한 미시적인 패턴과 빌딩 블록을 다룹니다.


### **4.1. 전략적 설계 (Strategic Design)**

전략적 설계는 개별 코드보다 팀, 컨텍스트, 시스템 간의 경계를 정의하는 데 중점을 둡니다.

---


#### **4.1.1. 유비쿼터스 언어 (Ubiquitous Language)**


##### **핵심 아이디어**

> "Use a language structured around the domain model and used by all team members — domain experts, developers, testers, and business analysts — to connect all the activities of the team with the software."
>
> "도메인 모델을 중심으로 구성된 언어를 사용하라. 이 언어는 모든 팀 구성원(도메인 전문가, 개발자, 테스터, 기획자)이 사용하여 팀의 모든 활동을 소프트웨어와 연결해야 한다."

유비쿼터스 언어는 프로젝트에 참여하는 모든 사람이 공통으로 사용하는 '단일화된 어휘집'입니다. 도메인 전문가가 말하는 '고객'과 개발자가 코드에서 사용하는 `Customer` 클래스, 데이터베이스의 `CUSTOMER` 테이블이 모두 동일한 개념과 규칙을 공유해야 합니다. "견적", "주문", "결제", "배송"과 같은 비즈니스 용어가 코드에 그대로 클래스명, 메서드명, 변수명으로 나타나야 합니다.


##### **상세 설명**

개발자와 비즈니스 전문가 사이에 '번역'이 필요하다면, 그 과정에서 오해와 버그가 발생할 가능성이 매우 높습니다. 유비쿼터스 언어는 이러한 번역 과정을 없애고, 대화와 코드를 일치시킴으로써 비즈니스 요구사항이 소프트웨어에 정확하게 반영되도록 보장합니다. 이 언어는 회의, 문서, 다이어그램, 그리고 무엇보다도 **소스 코드** 에서 일관되게 사용되어야 합니다. 코드가 곧 살아있는 문서가 되는 것입니다.


##### **TypeScript 예시**

**[부적절한 예]** 비즈니스 용어와 코드가 불일치합니다.

```typescript
// 비즈니스 용어: "고객이 상품을 장바구니에 담는다."
// 개발자 코드:
class User {
  // ...
}
class Product {
  // ...
}
class ShoppingCartManager {
  // 메서드 이름이 모호하고 비즈니스 용어와 다름
  addItem(user: User, item: Product, quantity: number) { 
    // ...
  }
}
```

**[유비쿼터스 언어 적용]** 비즈니스 용어가 코드에 그대로 반영됩니다.

```typescript
// 비즈니스 용어: "고객(Customer)이 장바구니(Cart)에 품목(LineItem)을 추가(add)한다."
// 개발자 코드:
class Customer {
  // ...
}
class Product {
  // ...
}
class LineItem {
  constructor(public product: Product, public quantity: number) {}
}

class Cart {
  private lineItems: LineItem[] = [];

  // 메서드 이름이 비즈니스 행위와 일치
  add(lineItem: LineItem) {
    // ... 비즈니스 규칙(재고 확인 등) 포함
    this.lineItems.push(lineItem);
  }
}
```

---


#### **4.1.2. 경계 컨텍스트 (Bounded Context)**


##### **핵심 아이디어**

> "A Bounded Context is a semantic boundary within which a particular domain model is defined and applicable."
>
> "경계 컨텍스트는 특정 도메인 모델이 정의되고 적용되는 의미론적 경계이다."

하나의 단어라도 다른 비즈니스 문맥(Context)에서는 다른 의미를 가질 수 있습니다. 예를 들어, '상품(Product)'이라는 단어는 **재고 컨텍스트** 에서는 '창고 위치', '수량'과 같은 속성을 가지지만, **영업 컨텍스트** 에서는 '가격', '할인 정책'과 같은 속성을 가집니다.

경계 컨텍스트는 이러한 의미론적 경계를 명확히 설정하는 것입니다. 각 컨텍스트 안에서는 자체적인 유비쿼터스 언어가 존재하며, 모델은 그 안에서만 일관성을 유지합니다. '상품'이라는 모델은 재고 컨텍스트와 영업 컨텍스트에서 서로 다른 클래스로 존재할 수 있으며, 이것이 정상입니다.


##### **상세 설명**

거대한 시스템 전체에 단 하나의 통합된 모델을 만들려는 시도는 필연적으로 실패합니다. 이는 모델을 지나치게 복잡하고 모순적으로 만들기 때문입니다. 경계 컨텍스트는 복잡한 도메인을 더 작고 관리 가능한 여러 개의 모델로 분할하는 핵심 전략입니다. 이는 마이크로서비스 아키텍처에서 각 서비스의 경계를 정의하는 가장 중요한 기준으로 작용합니다.

---


#### **4.1.3. 컨텍스트 맵 (Context Map)**


##### **핵심 아이디어**

> "A Context Map is a document that shows the relationships and integrations between different Bounded Contexts."
>
> "컨텍스트 맵은 여러 경계 컨텍스트 간의 관계와 통합 방식을 보여주는 문서이다."

경계 컨텍스트들이 완전히 고립되어 동작하는 경우는 드뭅니다. 대부분 서로 정보를 주고받으며 협력해야 합니다. 컨텍스트 맵은 이러한 컨텍스트 간의 '정치적', '조직적' 관계를 명시적으로 정의하는 다이어그램입니다.


##### **상세 설명**

컨텍스트 맵은 다음과 같은 다양한 관계 패턴을 사용하여 컨텍스트 간의 상호작용을 정의합니다.

- **파트너십(Partnership):** 두 팀이 긴밀하게 협력하여 컨텍스트를 함께 개발하고 통합합니다.
- **공유 커널(Shared Kernel):** 두 컨텍스트가 도메인 모델의 일부(코드)를 공유합니다. 신중하게 사용해야 합니다.
- **고객-공급자(Customer-Supplier):** 한 팀(공급자, Upstream)이 다른 팀(고객, Downstream)에게 서비스를 제공합니다. 고객 팀의 요구사항이 공급자 팀의 계획에 영향을 줍니다.
- **준수자(Conformist):** 고객 팀이 공급자 팀의 모델을 그대로 따릅니다. 공급자 팀의 일방적인 변경에 취약합니다.
- **충돌 방지 계층(Anticorruption Layer, ACL):** 고객 팀이 자신의 모델을 보호하기 위해, 공급자 팀의 모델을 자신의 모델로 변환하는 '번역 계층'을 만듭니다. 외부 시스템과의 통합 시 가장 흔하고 안정적인 패턴입니다.
- **분리된 방법(Separate Ways):** 두 컨텍스트가 서로 통합하지 않고 각자의 길을 갑니다.

이러한 관계 정의는 팀 간의 책임과 의사소통 방식을 명확히 하여 프로젝트의 혼란을 줄여줍니다.


### **4.2. 전술적 설계 (Tactical Design)**

전술적 설계는 경계 컨텍스트 안에서 도메인 모델을 구성하는 구체적인 빌딩 블록(패턴)들을 다룹니다.

---


#### **4.2.1. 애그리거트 (Aggregate)**


##### **핵심 아이디어**

> "An Aggregate is a cluster of associated objects that we treat as a single unit for the purpose of data changes."
>
> "애그리거트는 데이터 변경의 단위로 취급되는, 연관된 객체들의 묶음이다."

애그리거트는 트랜잭션 일관성의 경계를 정의합니다. 애그리거트 내의 모든 객체는 하나의 트랜잭션으로 함께 생성, 수정, 삭제되어야 하며, 비즈니스 규칙(불변식, Invariant)을 항상 유지해야 합니다.

각 애그리거트에는 **애그리거트 루트(Aggregate Root)** 라는 하나의 대표 엔티티가 존재합니다. 외부에서는 오직 이 루트를 통해서만 애그리거트 내부의 객체에 접근할 수 있습니다. 이는 캡슐화와 정보 은닉을 강제하여 모델의 무결성을 보호하는 강력한 장치입니다.


##### **TypeScript 예시**

`Order` 애그리거트를 생각해 봅시다. `Order`가 루트이며, `OrderItem`과 `ShippingAddress`는 내부 객체입니다.

```typescript
class OrderItem { /* ... */ }
class ShippingAddress { /* ... */ }

// Order는 Aggregate Root
class Order {
  private _id: OrderId;
  private _orderItems: OrderItem[] = [];
  private _shippingAddress: ShippingAddress;
  private _status: 'PENDING' | 'CONFIRMED' | 'SHIPPED';

  // 외부에서는 Order 루트를 통해서만 내부 상태 변경 가능
  public addOrderItem(product: Product, quantity: number) {
    if (this._status !== 'PENDING') {
      throw new Error("Cannot add items to a confirmed order."); // 비즈니스 규칙(불변식)
    }
    // ...
    this._orderItems.push(new OrderItem(product, quantity));
  }
  
  public confirm() {
      if (this._orderItems.length === 0) {
          throw new Error("Cannot confirm an empty order."); // 불변식
      }
      this._status = 'CONFIRMED';
  }

  // 외부에서 OrderItem 배열에 직접 접근 불가
}
```

`order.orderItems.push(...)` 와 같은 직접적인 조작은 불가능하며, 반드시 `order.addOrderItem(...)` 메서드를 통해 비즈니스 규칙을 통과해야 합니다.

---


#### **4.2.2. 엔티티와 값 객체 (Entity & Value Object)**

- **엔티티(Entity):**
  - **식별성(Identity)** 이 가장 중요한 객체입니다. 속성이 같더라도 식별자(`id`)가 다르면 다른 객체로 취급됩니다.
  - 생명주기(Life Cycle)를 가지며, 생성부터 소멸까지 상태가 계속 변할 수 있습니다.
  - 예: `Customer` (이름이 같아도 다른 고객일 수 있음), `Order`, `Product`.

- **값 객체(Value Object):**
  - **속성(Attribute)** 자체가 중요한 객체입니다. 모든 속성 값이 같으면 같은 객체로 취급됩니다.
  - 식별자가 없으며, **불변(Immutable)** 하게 만드는 것이 핵심입니다. 값을 변경하고 싶으면 새로운 값 객체를 만들어 교체해야 합니다.
  - 예: `Money` (1000원짜리 지폐 두 장은 구별할 필요 없음), `Address`, `DateRange`.


##### **TypeScript 예시**

```typescript
// Value Object: 불변성을 가짐
class Money {
  constructor(public readonly amount: number, public readonly currency: string) {
    if (amount < 0) throw new Error("Amount cannot be negative.");
    Object.freeze(this); // 객체를 불변으로 만듦
  }

  public add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error("Cannot add money of different currencies.");
    }
    return new Money(this.amount + other.amount, this.currency); // 새로운 객체 반환
  }
}

// Entity: 식별자를 가짐
class Customer {
  private readonly _id: CustomerId;
  private name: string;
  private address: Address; // Address는 Value Object

  constructor(id: CustomerId, name: string, address: Address) {
    this._id = id;
    this.name = name;
    this.address = address;
  }
  
  public changeAddress(newAddress: Address) {
      this.address = newAddress; // 상태 변경
  }

  public getId(): CustomerId {
      return this._id;
  }
}
```

---


#### **4.2.3. 리포지토리 (Repository)**


##### **핵심 아이디어**

리포지토리는 도메인 모델과 데이터 영속성 메커니즘(DB 등) 사이를 중재하는 역할을 합니다. 비즈니스 코드(서비스) 입장에서는 마치 애그리거트가 **메모리상의 컬렉션** 에 저장되어 있는 것처럼 보이게 만듭니다. 리포지토리는 영속성에 대한 복잡한 세부사항(SQL 쿼리, ORM 사용법 등)을 캡슐화하고 숨깁니다.

- `findById(id)`
- `save(aggregate)`
- `delete(aggregate)`

위와 같은 간단한 인터페이스를 제공하여, 비즈니스 로직이 데이터베이스 기술에 오염되는 것을 막습니다.

---


#### **4.2.4. 도메인 이벤트 (Domain Event)**


##### **핵심 아이디어**

> "A Domain Event is an object that represents something that happened in the domain."
>
> "도메인 이벤트는 도메인에서 발생한 '과거의 사건'을 나타내는 객체이다."

도메인 내에서 중요한 상태 변경이 발생했을 때, 이를 명시적인 '이벤트' 객체로 모델링합니다. 예를 들어, 주문이 확정되면 `OrderConfirmed`라는 이벤트를 발행(publish)합니다.

이벤트를 사용하면 시스템 간의 결합도를 크게 낮출 수 있습니다. `Order` 애그리거트는 주문이 확정되었다는 사실만 알리면 되고, 그 이후에 '이메일 발송', '재고 감소', '배송 시작'과 같은 후속 처리는 이 이벤트를 구독(subscribe)하는 다른 컴포넌트(또는 다른 경계 컨텍스트)들이 알아서 처리하면 됩니다. 이는 시스템을 확장 가능하고 유연하게 만듭니다.

물론입니다. 목차의 다섯 번째 대단원, **"분산 시스템 설계 원칙"** 에 대한 전문적인 설명을 시작하겠습니다. 이 원칙들은 단일 머신을 넘어 여러 컴퓨터(노드)가 네트워크를 통해 협력하여 하나의 시스템처럼 동작하는 분산 환경에서의 문제를 다룹니다.

---


### **5. 분산 시스템 설계 원칙 (Distributed Systems Design Principles)**

현대의 소프트웨어는 대부분 분산 시스템입니다. 마이크로서비스 아키텍처, 클라우드 네이티브 애플리케이션, 대규모 데이터 처리 시스템은 모두 여러 개의 독립적인 컴포넌트가 네트워크를 통해 통신하며 동작합니다. 이러한 환경은 단일 시스템에서는 고려하지 않았던 새로운 도전과제들을 제시합니다. 네트워크는 불안정하고(unreliable), 개별 노드는 언제든지 실패할 수 있으며(failure-prone), 데이터의 일관성을 유지하기 어렵습니다.

이 장에서는 분산 시스템을 견고하고, 신뢰할 수 있으며, 확장 가능하게 만들기 위한 핵심 원칙과 정리를 다룹니다.


### **5.1. 가용성 및 일관성 (Availability & Consistency)**

분산 시스템 설계에서 가장 근본적인 트레이드오프는 바로 '일관성'과 '가용성' 사이의 선택입니다.

---


#### **5.1.1. CAP 정리 (CAP Theorem)**


##### **핵심 아이디어**

> "In a distributed computer system, you can only have at most two of the following three guarantees: Consistency, Availability, and Partition Tolerance."
>
> "분산 컴퓨터 시스템에서는 일관성, 가용성, 분할 용인 이 세 가지 중 최대 두 가지만을 동시에 보장할 수 있다."

- **일관성 (Consistency):** 모든 노드는 어떤 클라이언트가 접근하더라도 항상 동일한 최신 데이터를 보아야 합니다. 즉, 모든 읽기 요청은 가장 최근에 성공한 쓰기 요청의 결과를 반환해야 합니다.
- **가용성 (Availability):** 모든 요청(읽기/쓰기)은 일부 노드에 장애가 발생하더라도 항상 성공적인 응답을 받아야 합니다 (단, 데이터가 오래된 것일 수 있음). 시스템이 '죽지 않고' 항상 응답하는 것을 의미합니다.
- **분할 용인 (Partition Tolerance):** 노드 간의 네트워크 통신이 끊어지거나 지연되는 상황(네트워크 분할)이 발생하더라도 시스템은 계속해서 동작해야 합니다.


##### **출처 및 신뢰성**

- **창시자:** 에릭 브루어 (Eric Brewer)
- **핵심 문서:** 2000년 ACM 심포지엄에서 처음 개념을 발표했으며, 이후 2002년 MIT의 세스 길버트(Seth Gilbert)와 낸시 린치(Nancy Lynch)에 의해 공식적으로 증명되었습니다.


##### **상세 설명**

현대의 분산 시스템에서 **네트워크 분할(P)은 피할 수 없는 현실** 입니다. 라우터가 다운되거나, 네트워크 케이블이 끊기는 등의 문제는 언제든 발생할 수 있습니다. 따라서 CAP 정리는 실질적으로 **"네트워크 분할이 발생했을 때, 일관성(C)과 가용성(A) 중 어느 것을 선택할 것인가?"** 라는 질문으로 귀결됩니다.

- **CP (Consistency / Partition Tolerance):** 네트워크 분할이 발생하면, 데이터의 일관성을 깨뜨릴 위험이 있는 요청(예: 다른 노드와 동기화가 필요한 쓰기 요청)을 거부(에러 반환)함으로써 가용성을 희생합니다. 데이터가 틀리는 것보다 시스템이 잠시 멈추는 것이 낫다고 판단하는 시스템입니다.
  - **예시:** 금융 거래 시스템, 은행 시스템, 관계형 데이터베이스(RDB) 클러스터.

- **AP (Availability / Partition Tolerance):** 네트워크 분할이 발생하더라도, 모든 요청에 일단 응답하여 가용성을 보장합니다. 대신, 일부 노드는 오래된(stale) 데이터를 반환할 수 있으므로 일관성이 깨질 수 있습니다. 이러한 시스템은 보통 '최종 일관성(Eventual Consistency)' 모델을 채택합니다.
  - **예시:** Amazon DynamoDB, Cassandra, 소셜 미디어 피드 (친구가 방금 올린 글이 잠시 안 보여도 큰 문제가 되지 않음).

- **CA (Consistency / Availability):** 네트워크 분할을 전혀 허용하지 않는 시스템. 이는 사실상 모든 노드가 단일 데이터 센터의 동일 랙 안에 있는 등 극히 제한적인 경우에만 가능하며, 현대적인 의미의 분산 시스템에는 해당하지 않습니다.

---


#### **5.1.2. PACELC 정리 (PACELC Theorem)**


##### **핵심 아이디어**

> "If there is a partition (P), a distributed system can trade between availability (A) and consistency (C). Else (E), when the system is running normally, it can trade between latency (L) and consistency (C)."
>
> "만약 네트워크 분할(P)이 발생하면, 시스템은 가용성(A)과 일관성(C) 사이에서 선택해야 한다. 그 외의 경우(E), 시스템이 정상적으로 동작할 때는 지연 시간(L)과 일관성(C) 사이에서 선택해야 한다."

PACELC(패클-씨) 정리는 CAP 정리를 확장한 개념입니다. CAP이 네트워크 장애 상황에만 초점을 맞췄다면, PACELC는 **정상 상황(Else)에서의 트레이드오프** 까지 고려합니다.


##### **출처 및 신뢰성**

- **창시자:** 다니엘 아바디 (Daniel J. Abadi)
- **핵심 문서:** 2010년 블로그 포스팅을 통해 처음 제안되었으며, 분산 데이터베이스 시스템의 특성을 더 정밀하게 설명하는 모델로 널리 인정받고 있습니다.


##### **상세 설명**

- **P(Partition) 상황:** CAP 정리와 동일. **A**와 **C** 중 선택.
- **E(Else) 상황:** 네트워크가 정상일 때,
  - **L(Latency) 우선:** 쓰기 요청에 대해 즉시 응답하고, 다른 노드들에는 비동기적으로 데이터를 복제합니다. 이로 인해 응답 시간(Latency)은 매우 짧아지지만, 다른 노드에서 데이터를 읽을 때 일시적으로 오래된 데이터를 읽을 수 있어 일관성(Consistency)이 낮아집니다.
  - **C(Consistency) 우선:** 쓰기 요청이 발생하면, 모든 복제본 노드에 데이터가 성공적으로 쓰여질 때까지 기다린 후 응답합니다. 이로 인해 강한 일관성은 보장되지만, 동기화 시간만큼 응답 시간(Latency)이 길어집니다.

**시스템 분류:**

- **PA/EL:** 네트워크 분할 시 가용성을, 정상 시 지연 시간을 우선 (예: Amazon DynamoDB, Cassandra)
- **PC/EC:** 네트워크 분할 시 일관성을, 정상 시에도 일관성을 우선 (예: 전통적인 RDBMS, Google Spanner)
- **PA/EC:** 네트워크 분할 시 가용성을, 정상 시에는 일관성을 우선 (거의 없음)
- **PC/EL:** 네트워크 분할 시 일관성을, 정상 시에는 지연 시간을 우선 (거의 없음)


### **5.2. 통신 및 상호작용 (Communication & Interaction)**

분산된 컴포넌트 간의 통신 방식은 시스템 전체의 안정성과 결합도에 큰 영향을 미칩니다.

---


#### **5.2.1. 비동기 통신 (Asynchronous Communication)**


##### **핵심 아이디어**

"요청을 보낸 컴포넌트가 응답을 즉시 기다리지 않고, 자신의 작업을 계속 수행하도록 하는 통신 방식."

동기(Synchronous) 통신에서는 서비스 A가 서비스 B를 호출하면, B의 응답이 올 때까지 A는 대기(block)해야 합니다. 이는 서비스 간에 강한 시간적 결합(temporal coupling)을 만듭니다. 만약 B가 느려지거나 장애가 발생하면, A까지 연쇄적으로 장애가 전파됩니다.

비동기(Asynchronous) 통신은 이러한 결합을 끊어냅니다. A는 B에게 메시지 큐나 이벤트 브로커를 통해 메시지를 보내기만 하고, 자신의 일을 계속합니다. B는 나중에 메시지를 처리하고, 필요하다면 별도의 채널로 결과를 통지합니다.


##### **장점**

- **회복탄력성 (Resilience):** 수신자(consumer) 서비스의 장애가 송신자(producer) 서비스에 직접적인 영향을 주지 않습니다.
- **결합도 감소:** 서비스들이 서로의 존재나 위치를 직접 알 필요 없이, 메시지 브로커를 통해 상호작용하므로 결합도가 낮아집니다.
- **탄력적 확장성 (Elasticity):** 특정 서비스에 부하가 몰리면, 해당 서비스를 처리하는 컨슈머의 수만 늘려서 유연하게 대처할 수 있습니다.


##### **대표 기술**

- **메시지 큐:** RabbitMQ, Amazon SQS
- **이벤트 스트림 브로커:** Apache Kafka, Amazon Kinesis

---


#### **5.2.2. 멱등성 (Idempotency)**


##### **핵심 아이디어**

> "An operation is idempotent if it can be applied multiple times without changing the result beyond the initial application."
>
> "동일한 연산을 여러 번 수행하더라도, 첫 번째 수행 이후에는 결과가 달라지지 않는 성질."

분산 시스템에서는 네트워크 문제로 인해 동일한 요청이 여러 번 전달될 수 있습니다. 예를 들어, 클라이언트가 서버에 결제 요청을 보냈는데, 응답을 받기 전에 타임아웃이 발생했다고 가정해 봅시다. 클라이언트는 요청이 실패했다고 판단하고 재시도할 것입니다. 만약 서버의 결제 API가 멱등하지 않다면, 사용자는 두 번 결제하게 될 수 있습니다.

멱등성은 이러한 중복 요청으로부터 시스템을 안전하게 보호합니다.


##### **TypeScript 예시**

**[멱등하지 않은 API]**

```typescript
// Non-idempotent: Каждый запрос создает новый платеж
let balance = 1000;
function processPayment(amount: number) {
  balance -= amount;
  console.log(`Payment processed. New balance: ${balance}`);
}

processPayment(100); // balance: 900
processPayment(100); // balance: 800 (중복 결제 발생!)
```

**[멱등한 API]** 요청마다 고유한 `transactionId`를 사용합니다.

```typescript
// Idempotent: Subsequent requests with the same ID have no effect.
let balance = 1000;
const processedTransactions = new Set<string>();

function processPayment(transactionId: string, amount: number) {
  if (processedTransactions.has(transactionId)) {
    console.log(`Transaction ${transactionId} already processed. Ignoring.`);
    return;
  }
  
  balance -= amount;
  processedTransactions.add(transactionId);
  console.log(`Payment processed. New balance: ${balance}`);
}

processPayment("tx-123", 100); // balance: 900
processPayment("tx-123", 100); // "already processed" 메시지 출력, balance는 900으로 유지
```


### **5.3. 시스템 회복탄력성 (System Resilience)**

회복탄력성은 시스템의 일부에 장애가 발생하더라도, 전체 시스템이 중단되지 않고 계속해서 서비스를 제공할 수 있는 능력을 의미합니다.

---


#### **5.3.1. 서킷 브레이커 패턴 (Circuit Breaker Pattern)**


##### **핵심 아이디어**

"반복적으로 실패하는 원격 서비스 호출을 감지하고, 일정 시간 동안 해당 서비스로의 요청을 자동으로 차단하여 추가적인 장애 전파를 막는 패턴."

마치 가정의 전기 회로 차단기(두꺼비집)처럼 동작합니다.

1. **Closed:** 정상 상태. 요청이 원격 서비스로 전달됩니다. 실패 횟수가 임계치를 넘으면 `Open` 상태로 전환됩니다.
2. **Open:** 차단 상태. 원격 서비스로의 모든 요청을 즉시 실패 처리하고, 에러를 반환합니다. 일정 시간이 지나면 `Half-Open` 상태로 전환됩니다.
3. **Half-Open:** 테스트 상태. 소수의 테스트 요청을 원격 서비스로 보내봅니다. 이 요청이 성공하면 `Closed` 상태로 돌아가고, 실패하면 다시 `Open` 상태로 전환됩니다.


##### **장점**

- **장애 전파 방지 (Fail Fast):** 실패할 것이 뻔한 요청에 대해 오래 대기하지 않고 즉시 실패 처리하여 시스템 자원 낭비를 막고, 사용자 경험을 개선합니다.
- **서비스 복구 시간 제공:** 장애가 발생한 서비스에 부하를 주지 않아 스스로 복구할 시간을 벌어줍니다.

---


#### **5.3.2. 격벽 패턴 (Bulkhead Pattern)**


##### **핵심 아이디어**

"시스템의 자원(스레드 풀, 커넥션 풀 등)을 서비스별로 격리하여, 한 서비스의 장애가 다른 서비스의 자원을 고갈시키지 않도록 하는 패턴."

이름은 배의 '격벽(Bulkhead)'에서 유래했습니다. 배의 한 구역이 침수되더라도, 격벽이 물이 다른 구역으로 퍼지는 것을 막아 배 전체가 침몰하는 것을 방지합니다.

예를 들어, 서비스 A, B, C를 호출하는 세 종류의 요청이 있다고 할 때, 모든 요청이 하나의 공통 스레드 풀을 사용한다고 가정해 봅시다. 만약 서비스 A가 매우 느려져서 스레드 풀을 모두 점유해버리면, 정상적인 서비스 B와 C에 대한 요청도 처리할 스레드가 없어 함께 장애를 겪게 됩니다.

격벽 패턴은 각 서비스(A, B, C)에 별도의 스레드 풀을 할당하여 이러한 문제를 방지합니다. 서비스 A에 장애가 발생하더라도, 그 영향은 A를 위한 스레드 풀 안에 격리되고 B와 C는 정상적으로 동작할 수 있습니다.

---


#### **5.3.3. 장애 격리 (Fault Isolation)**

장애 격리는 서킷 브레이커나 격벽 패턴을 포함하는 더 넓은 개념으로, 시스템을 설계할 때부터 장애가 발생할 수 있는 단위를 정의하고, 그 영향 범위를 최소화하려는 모든 노력을 의미합니다.

- **방법:**
  - **지역별 배포:** Amazon Web Services(AWS)의 리전(Region)이나 가용 영역(Availability Zone, AZ)처럼 물리적으로 분리된 인프라에 서비스를 배포하여, 특정 데이터 센터의 장애가 전체 서비스에 영향을 주지 않도록 합니다.
  - **기능별 분리:** 마이크로서비스 아키텍처 자체가 장애 격리의 한 형태입니다. 결제 서비스에 장애가 발생하더라도, 상품 검색 서비스는 계속 동작할 수 있습니다.
  - **샤딩(Sharding):** 사용자를 여러 그룹(샤드)으로 나누어 별도의 인프라에서 서비스합니다. 한 샤드에 장애가 발생하더라도 다른 샤드의 사용자들은 영향을 받지 않습니다.

이러한 원칙들을 통해 우리는 예측 불가능한 분산 환경에서도 안정적이고 신뢰성 높은 시스템을 구축할 수 있습니다.

물론입니다. 목차의 여섯 번째 대단원, **"데이터 관리 설계 원칙"** 에 대한 전문적인 설명을 시작하겠습니다. 이 원칙들은 현대 애플리케이션에서 데이터를 어떻게 처리, 저장, 관리할 것인지에 대한 고급 전략들을 다룹니다.

---


### **6. 데이터 관리 설계 원칙 (Data Management Design Principles)**

애플리케이션 아키텍처는 데이터 아키텍처와 분리해서 생각할 수 없습니다. 데이터는 모든 비즈니스 로직의 근간이며, 데이터를 어떻게 다루느냐에 따라 시스템의 성능, 확장성, 유연성이 결정됩니다. 전통적인 CRUD(Create, Read, Update, Delete) 모델만으로는 복잡한 현대 애플리케이션의 요구사항을 충족하기 어려운 경우가 많습니다.

이 장에서는 CQRS, 이벤트 소싱과 같은 고급 데이터 관리 패턴과 시스템 전체의 데이터 일관성을 보장하기 위한 원칙들을 탐구합니다.


### **6.1. 데이터 처리 모델 (Data Processing Models)**

전통적인 단일 모델 접근 방식에서 벗어나, 데이터의 읽기(Read)와 쓰기(Write) 경로를 분리하거나, 데이터의 변경 자체를 상태가 아닌 '이벤트'로 저장하는 혁신적인 모델들을 살펴봅니다.

---


#### **6.1.1. 명령 조회 책임 분리 (CQRS: Command Query Responsibility Segregation)**


##### **핵심 아이디어**

> "Segregate the model for updating data (Commands) from the model for reading data (Queries)."
>
> "데이터를 변경하는 모델(명령, Command)과 데이터를 조회하는 모델(조회, Query)을 분리하라."

전통적인 CRUD 모델에서는 하나의 객체 모델(예: ORM의 엔티티)이 데이터의 생성, 수정, 삭제(쓰기 작업)와 조회(읽기 작업)를 모두 담당합니다. 하지만 쓰기 작업과 읽기 작업은 본질적으로 요구사항이 다릅니다.

- **쓰기(Command) 모델:** 데이터의 일관성과 무결성을 보장해야 하므로, 복잡한 비즈니스 규칙과 유효성 검사를 포함하는 경우가 많습니다. 정규화된 데이터 구조가 유리합니다.
- **읽기(Query) 모델:** 빠른 응답 속도가 중요하며, 다양한 UI 화면에 맞춰 데이터를 미리 최적화(비정규화) 해두는 것이 유리합니다.

CQRS는 이 두 가지 책임을 완전히 다른 모델, 심지어는 다른 데이터베이스로 분리하는 패턴입니다.


##### **출처 및 신뢰성**

- **창시자:** 그렉 영 (Greg Young)
- **영감을 준 개념:** 버트런드 마이어(Bertrand Meyer)의 명령-조회 분리(Command-Query Separation, CQS) 원칙에서 파생되었습니다. CQS는 "값을 반환하는 메서드는 부작용(Side Effect)이 없어야 한다"는 원칙이지만, CQRS는 이를 아키텍처 수준으로 확장한 것입니다.


##### **상세 설명**

CQRS 아키텍처는 다음과 같이 동작합니다.

1. **Command Side:** 사용자의 데이터 변경 요청(예: `CreateOrderCommand`)은 '커맨드 모델'로 전달됩니다. 이 모델은 도메인 주도 설계(DDD)의 애그리거트와 같은 풍부한 도메인 모델일 수 있습니다. 비즈니스 규칙을 검증한 후, 주 데이터 저장소(Write-DB, 보통 RDBMS)의 상태를 변경합니다.
2. **데이터 동기화:** 쓰기 데이터베이스의 변경 사항은 비동기적으로(예: 이벤트를 통해) 읽기 데이터베이스로 전파됩니다.
3. **Query Side:** 사용자의 데이터 조회 요청은 '조회 모델'로 전달됩니다. 이 모델은 특정 화면에 최적화된 단순한 데이터 전송 객체(DTO)일 수 있습니다. 이 모델은 미리 가공된 데이터가 저장된 '읽기 데이터 저장소(Read-DB, 보통 NoSQL이나 검색 엔진)'에서 데이터를 매우 빠르게 조회하여 반환합니다.


##### **TypeScript (Conceptual) 예시**

```typescript
// --- Command Side ---
interface CreateProductCommand {
  productId: string;
  name: string;
  initialPrice: number;
}

// Command Handler는 비즈니스 로직을 수행하고 Write-DB에 저장
class ProductCommandHandler {
  private productRepository: ProductRepository; // DDD Repository

  async handle(command: CreateProductCommand) {
    const product = Product.create(command.productId, command.name, command.initialPrice);
    await this.productRepository.save(product);
    // 변경사항을 알리는 이벤트 발행 (데이터 동기화를 위해)
    eventBus.publish(new ProductCreatedEvent(product.id, product.name));
  }
}

// --- Query Side ---

// 특정 UI 화면에 최적화된 읽기 모델 (Read Model / DTO)
interface ProductSummaryView {
  id: string;
  productName: string;
  isPopular: boolean;
}

// Query Handler는 Read-DB에서 직접 조회
class ProductQueryHandler {
  private readDbConnection: ReadDb; // 예: MongoDB 또는 Elasticsearch 연결

  async handle(query: GetProductSummariesQuery): Promise<ProductSummaryView[]> {
    return this.readDbConnection.collection('product_summaries').find({ ... });
  }
}

// --- Data Synchronization ---
// ProductCreatedEvent를 구독하여 Read-DB를 업데이트
class ProductDenormalizer {
  onProductCreated(event: ProductCreatedEvent) {
    const view: ProductSummaryView = { id: event.id, productName: event.name, isPopular: false };
    readDb.collection('product_summaries').insertOne(view);
  }
}
```


##### **장점**

- **성능 및 확장성:** 읽기/쓰기 부하에 따라 각각 독립적으로 데이터베이스와 서버를 확장할 수 있습니다.
- **유연성:** 각기 다른 요구사항에 맞는 최적의 데이터 저장 기술을 선택할 수 있습니다 (예: 쓰기용 RDBMS, 읽기용 Elasticsearch).
- **단순화:** 각 모델이 하나의 책임에만 집중하므로 코드가 단순해지고 명확해집니다.

---


#### **6.1.2. 이벤트 소싱 (Event Sourcing)**


##### **핵심 아이디어**

> "Capture all changes to an application state as a sequence of events."
>
> "애플리케이션 상태의 모든 변경을 '이벤트의 순차 목록'으로 저장하라."

이벤트 소싱은 시스템의 현재 상태(Current State)를 직접 저장하고 수정하는 대신, 그 상태에 도달하기까지 발생했던 모든 **'사건(Event)'** 들을 시간 순서대로 저장하는 방식입니다. 데이터베이스에는 `UPDATE`나 `DELETE`가 존재하지 않으며, 오직 새로운 이벤트를 추가(`INSERT`)하는 것만 가능합니다.

애플리케이션의 현재 상태를 알고 싶으면, 처음부터 모든 이벤트를 순서대로 재연(replay)하면 됩니다.


##### **상세 설명**

예를 들어, 은행 계좌의 현재 잔액(`balance: 900`)을 저장하는 대신, 다음과 같은 이벤트들을 저장합니다.

1. `AccountCreated(initialBalance: 1000)`
2. `MoneyWithdrawn(amount: 200)`
3. `MoneyDeposited(amount: 100)`

이 이벤트들을 재연하면 현재 잔액이 900원임을 계산할 수 있습니다. 이벤트 소싱은 그 자체로 완벽한 감사 추적(Audit Trail) 기능을 제공하며, '과거 특정 시점'의 시스템 상태를 정확하게 복원할 수 있습니다.

이벤트 소싱은 CQRS와 함께 사용되는 경우가 매우 많습니다.

- **Command Side (쓰기):** 애그리거트는 이벤트를 생성하여 '이벤트 스토어(Event Store)'에 저장합니다. 이것이 유일한 진실의 원천(Source of Truth)이 됩니다.
- **Query Side (읽기):** 별도의 프로세서(프로젝터)가 이벤트 스토어의 이벤트를 구독하여, 읽기 좋은 형태의 '뷰 모델(View Model)'을 만들어 읽기 전용 데이터베이스에 저장(Project)합니다.


##### **장점**

- **완벽한 감사 로그:** 시스템에서 일어난 모든 일을 추적할 수 있습니다.
- **시간 여행 (Temporal Query):** "어제 오후 3시 시점의 고객 주소는 무엇이었나?"와 같은 시간 기반 조회가 가능합니다.
- **디버깅 용이성:** 버그가 발생했을 때, 어떤 이벤트 순서에서 문제가 생겼는지 재연하여 쉽게 원인을 파악할 수 있습니다.
- **유연한 데이터 분석:** 저장된 이벤트를 바탕으로, 과거에는 생각지 못했던 새로운 통계나 뷰를 언제든지 다시 만들어낼 수 있습니다.

---


#### **6.1.3. 최종 일관성 (Eventual Consistency)**


##### **핵심 아이디어**

> "If no new updates are made to a given data item, eventually all accesses to that item will return the last updated value."
>
> "특정 데이터 항목에 더 이상 새로운 변경이 없다면, 결국(eventually) 모든 접근은 마지막으로 변경된 값을 반환하게 될 것이다."

최종 일관성은 강한 일관성(Strong Consistency)의 반대 개념으로, 분산 시스템에서 데이터 변경이 모든 노드에 즉시 반영되지 않고, 약간의 지연 시간을 두고 점진적으로 전파되는 것을 허용하는 모델입니다. 데이터가 일시적으로 불일치할 수 있지만, '언젠가는' 일관된 상태에 도달할 것을 보장합니다.


##### **상세 설명**

CQRS나 이벤트 소싱과 같이 쓰기 모델과 읽기 모델이 분리된 비동기 시스템은 필연적으로 최종 일관성 모델을 따르게 됩니다. 쓰기 데이터베이스에 변경이 발생하고, 그 변경 사항이 이벤트 큐를 거쳐 읽기 데이터베이스에 반영되기까지는 수 밀리초에서 수 초의 시간이 걸릴 수 있습니다. 이 시간 동안 사용자는 방금 자신이 변경한 내용이 즉시 반영되지 않은 것처럼 보일 수 있습니다.

최종 일관성은 가용성(Availability)과 성능(Performance)을 얻기 위해 강한 일관성을 희생하는 트레이드오프입니다. 소셜 미디어 피드, 상품 추천 목록, 조회수 카운트 등 즉각적인 일관성이 치명적이지 않은 대부분의 웹 애플리케이션 시나리오에서 널리 사용됩니다.


### **6.2. 데이터 관리 (Data Governance)**

시스템 전반에 걸쳐 데이터의 품질, 정확성, 신뢰성을 보장하기 위한 원칙입니다.

---


#### **6.2.1. 단일 진실 공급원 (SSOT: Single Source of Truth)**


##### **핵심 아이디어**

> "Ensure that every data element is stored in exactly one place, and any derivative data is derived from this source."
>
> "모든 데이터 요소가 정확히 한 곳에만 저장되도록 보장하라. 그리고 모든 파생 데이터는 이 원천으로부터 생성되어야 한다."

SSOT는 조직 내에서 특정 정보에 대해 가장 권위 있고 신뢰할 수 있는 유일한 데이터 소스를 지정하는 관행입니다. 시스템에 동일한 정보(예: 고객 주소)가 여러 데이터베이스에 중복으로 저장되고, 각기 다른 방식으로 수정된다면, 어떤 데이터가 진짜인지 알 수 없게 되어 데이터의 신뢰도가 무너집니다.


##### **상세 설명**

- **이벤트 소싱에서:** 이벤트 스토어가 바로 단일 진실 공급원입니다. 모든 상태와 뷰는 이벤트 스토어로부터 파생됩니다.
- **CQRS에서:** 쓰기 데이터베이스(Write-DB)가 단일 진실 공급원의 역할을 합니다. 읽기 데이터베이스의 데이터는 언제든지 쓰기 데이터베이스로부터 재생성될 수 있는 '캐시'나 '파생물'로 취급됩니다.
- **일반적인 시스템에서:** 특정 데이터(예: 제품 카탈로그)를 책임지는 마스터 데이터베이스나 마이크로서비스를 명확히 지정하고, 다른 모든 시스템은 API를 통해 해당 소스에서만 정보를 가져오도록 강제합니다.

SSOT를 확립하면 데이터의 중복을 줄이고, 일관성을 유지하며, 데이터에 기반한 의사결정의 신뢰도를 높일 수 있습니다.

물론입니다. 마지막 대단원인 **"유지보수성 및 간결성 원칙"** 에 대한 전문적인 설명을 시작하겠습니다. 이 원칙들은 소프트웨어의 생명주기 전반에 걸쳐 비용을 줄이고, 변화에 쉽게 적응할 수 있도록 코드를 간결하고 명확하게 유지하는 방법에 대한 지혜를 담고 있습니다.

---


### **7. 유지보수성 및 간결성 원칙 (Maintainability & Simplicity Principles)**

소프트웨어 개발 비용의 대부분은 최초 개발이 아닌, 장기간에 걸친 유지보수 과정에서 발생합니다. 복잡하고, 읽기 어렵고, 서로 얽혀있는 코드는 작은 변경에도 많은 시간과 노력을 요구하며, 새로운 버그를 만들어낼 위험이 높습니다.

이 장의 원칙들은 "화려한 기교보다는 단순함이 낫다"는 철학을 공유합니다. 코드는 컴퓨터뿐만 아니라, 미래의 나 자신을 포함한 다른 개발자들이 쉽게 이해하고 수정할 수 있도록 작성되어야 합니다.


### **7.1. 코드 간결성 (Code Simplicity)**

복잡성은 소프트웨어의 적입니다. 간결성은 버그를 줄이고, 가독성을 높이며, 협업을 원활하게 만드는 최고의 미덕입니다.

---


#### **7.1.1. KISS 원칙 (Keep It Simple, Stupid)**


##### **핵심 아이디어**

> "Most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided."
>
> "대부분의 시스템은 복잡하게 만드는 것보다 단순하게 유지할 때 가장 잘 작동한다. 따라서 단순함은 설계의 핵심 목표여야 하며, 불필요한 복잡성은 피해야 한다."

KISS 원칙은 소프트웨어 설계의 모든 측면에 적용되는 가장 근본적인 원칙 중 하나입니다. 어떤 문제를 해결할 때, 여러 가지 방법이 있다면 가장 단순하고 명료한 방법을 선택하라는 것입니다. 복잡한 설계 패턴, 과도한 추상화, 필요 이상의 기능 추가는 당장은 멋져 보일 수 있지만, 결국 시스템을 이해하고 수정하기 어렵게 만드는 기술적 부채(Technical Debt)가 됩니다.


##### **출처 및 신뢰성**

- **창시자:** 이 원칙은 미 해군에서 항공기 엔지니어였던 켈리 존슨(Kelly Johnson)이 1960년대에 처음 사용한 것으로 알려져 있습니다. 그는 자신이 설계한 제트기가 평균 수준의 정비공이 간단한 도구만으로도 현장에서 수리할 수 있을 만큼 단순해야 한다는 설계 철학을 가지고 있었습니다.


##### **TypeScript 예시**

**[위반 사례]** 단순히 배열의 짝수를 필터링하는 데 불필요하게 복잡한 클래스와 메서드를 사용합니다.

```typescript
// Bad: Over-engineered and violates KISS
class ArrayProcessor {
  private numbers: number[];
  
  constructor(numbers: number[]) {
    this.numbers = numbers;
  }
  
  private isEven(n: number): boolean {
    return n % 2 === 0;
  }
  
  public getEvenNumbers(): number[] {
    const result: number[] = [];
    for (const num of this.numbers) {
      if (this.isEven(num)) {
        result.push(num);
      }
    }
    return result;
  }
}

const processor = new ArrayProcessor([1, 2, 3, 4, 5]);
const evens = processor.getEvenNumbers(); // [2, 4]
```

**[준수 사례]** 언어가 제공하는 단순하고 직관적인 기능을 사용합니다.

```typescript
// Good: Simple and adheres to KISS
const numbers = [1, 2, 3, 4, 5];

// 가장 단순하고 명료한 방법
const evens = numbers.filter(n => n % 2 === 0); // [2, 4]
```

---


#### **7.1.2. DRY 원칙 (Don't Repeat Yourself)**


##### **핵심 아이디어**

> "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system."
>
> "시스템 내의 모든 지식 조각은 단일하고, 모호하지 않으며, 신뢰할 수 있는 단 하나의 표현을 가져야 한다."

DRY 원칙은 단순히 '코드를 복사-붙여넣기 하지 말라'는 것 이상의 의미를 가집니다. 이는 코드뿐만 아니라 데이터베이스 스키마, 테스트 계획, 문서 등 시스템을 구성하는 모든 곳에서 '지식의 중복'을 피하라는 원칙입니다.

동일한 로직이나 정보가 여러 곳에 중복되어 존재하면, 수정이 필요할 때 모든 곳을 찾아 빠짐없이 고쳐야 합니다. 만약 한 곳이라도 놓치게 되면 시스템은 비일관적인 상태가 되고, 찾기 어려운 버그의 원인이 됩니다.


##### **출처 및 신뢰성**

- **창시자:** 앤디 헌트(Andy Hunt)와 데이브 토머스(Dave Thomas)
- **핵심 저서:** *The Pragmatic Programmer* (실용주의 프로그래머)에서 처음 소개되었습니다.


##### **TypeScript 예시**

**[위반 사례]** 사용자 유효성 검사 로직이 여러 곳에 중복되어 있습니다.

```typescript
// Bad: Violates DRY
function createUser(email: string, name: string) {
  // 중복된 지식 1
  if (!email.includes('@') || name.length === 0) {
    throw new Error('Invalid user data');
  }
  // ... 유저 생성 로직
}

function updateUser(userId: string, email: string, name: string) {
  // 중복된 지식 2
  if (!email.includes('@') || name.length === 0) {
    throw new Error('Invalid user data');
  }
  // ... 유저 수정 로직
}
```

**[준수 사례]** 중복된 로직을 별도의 함수나 모듈로 추출하여 한 곳에서 관리합니다.

```typescript
// Good: Adheres to DRY

// 지식을 한 곳으로 모음
function validateUserData(email: string, name: string) {
  if (!email.includes('@') || name.length === 0) {
    throw new Error('Invalid user data');
  }
}

function createUser(email: string, name: string) {
  validateUserData(email, name);
  // ... 유저 생성 로직
}

function updateUser(userId: string, email: string, name: string) {
  validateUserData(email, name);
  // ... 유저 수정 로직
}
```

---


#### **7.1.3. YAGNI 원칙 (You Ain't Gonna Need It)**


##### **핵심 아이디어**

> "Always implement things when you actually need them, never when you just foresee that you need them."
>
> "기능은 실제로 필요할 때 구현하라. 단지 필요할 것이라고 예측될 때는 절대 구현하지 말라."

YAGNI는 미래를 예측하여 지금 당장 필요하지 않은 기능을 미리 구현하는 것을 경계하는 원칙입니다. 개발자들은 종종 "나중에 필요할지도 몰라"라는 생각으로 과도한 일반화나 유연성을 코드에 추가하려는 경향이 있습니다. 하지만 예측은 대부분 틀리며, 미리 만들어 둔 코드는 사용되지 않거나 요구사항이 바뀌어 결국 버려지는 경우가 많습니다.

이러한 코드는 시스템의 복잡성만 높이고, 개발 및 테스트 시간을 낭비하며, 진짜 필요한 기능 개발에 집중하는 것을 방해합니다.


##### **출처 및 신뢰성**

- **창시자:** 익스트림 프로그래밍(XP: Extreme Programming)의 실천 방법 중 하나로, 켄트 벡(Kent Beck)에 의해 널리 알려졌습니다.


##### **상세 설명**

YAGNI는 "가장 단순한 해결책(Simple Design)"과 "점진적 개발(Incremental Development)" 철학과 맞닿아 있습니다. 현재의 요구사항을 충족하는 가장 간단한 코드를 작성하고, 새로운 요구사항이 생기면 그때 가서 리팩터링을 통해 코드를 확장하라는 것입니다. 이는 불필요한 작업을 줄이고, 변화에 민첩하게 대응할 수 있게 해줍니다.


### **7.2. 관계 최소화 (Minimizing Relationships)**

객체와 모듈 간의 관계(결합)가 많아질수록 시스템은 복잡해집니다. 이 관계를 최소화하여 각 부분을 독립적으로 만드는 것이 중요합니다.

---


#### **7.2.1. 데메테르 법칙 (Law of Demeter) / 최소 지식 원칙 (Principle of Least Knowledge)**


##### **핵심 아이디어**

> "Each unit should have only limited knowledge about other units: only units 'closely' related to the current unit."
>
> "각 모듈은 다른 모듈에 대해 제한된 지식만을 가져야 한다. 즉, 현재 모듈과 '가장 가까운' 모듈만 알아야 한다."

더 구체적으로, 한 객체의 메서드는 다음과 같은 대상의 메서드만 호출해야 합니다.

1. 객체 자신의 메서드
2. 메서드의 인자로 전달된 객체의 메서드
3. 메서드 내부에서 생성한 객체의 메서드
4. 객체가 속성으로 가지고 있는 객체의 메서드

`customer.getWallet().getMoney().getAmount()` 와 같이 여러 개의 점(.)을 연결하여 멀리 있는 객체의 내부를 캐내려 하는 '기차 충돌(Train Wreck)' 코드를 작성하지 말라는 것입니다.


##### **상세 설명**

데메테르 법칙을 위반하면, 한 객체가 다른 객체들의 내부 구조에 깊이 의존하게 됩니다. 중간에 있는 객체 중 하나의 구조만 변경되어도, 호출하는 코드 전체를 수정해야 합니다. 이는 높은 결합도를 만들어 시스템을 취약하게 만듭니다.


##### **TypeScript 예시**

**[위반 사례]** `Paperboy`가 `Customer`의 `Wallet` 내부까지 알아야 합니다.

```typescript
// Bad: Violates Law of Demeter
class Money {
  constructor(public amount: number) {}
}
class Wallet {
  constructor(public money: Money) {}
}
class Customer {
  constructor(public wallet: Wallet) {}
}

class Paperboy {
  charge(customer: Customer, payment: number) {
    // customer -> wallet -> money -> amount 로 깊숙이 들어감
    const customerMoney = customer.wallet.money.amount;
    if (customerMoney >= payment) {
      // ...
    }
  }
}
```

**[준수 사례]** `Customer`에게 직접 지불을 요청합니다. `Customer`가 내부적으로 어떻게 처리하는지는 `Paperboy`가 알 필요가 없습니다.

```typescript
// Good: Adheres to Law of Demeter
class Wallet {
  private money: number;
  // ...
  public withdraw(amount: number): boolean { /* ... */ }
}
class Customer {
  private wallet: Wallet;
  // ...
  // 고객이 직접 지불하는 책임을 가짐
  public makePayment(amount: number): boolean {
    return this.wallet.withdraw(amount);
  }
}

class Paperboy {
  charge(customer: Customer, payment: number) {
    // "묻지 말고, 시켜라 (Tell, Don't Ask)"
    const success = customer.makePayment(payment);
    if (success) {
      // ...
    }
  }
}
```

---


#### **7.2.2. 할리우드 원칙 (Hollywood Principle)**


##### **핵심 아이디어**

> "Don't call us, we'll call you."
>
> "우리를 호출하지 마세요, 우리가 당신을 호출할 겁니다."

이 원칙은 컴포넌트 간의 제어 흐름(Flow of Control)을 역전시키는 것을 말합니다. 하위 수준의 컴포넌트가 상위 수준의 컴포넌트를 직접 호출하는 대신, 상위 수준의 컴포넌트(주로 프레임워크)가 정해진 시점에 하위 수준 컴포넌트의 특정 메서드를 호출하는 구조를 의미합니다.

이는 **제어의 역전(Inversion of Control, IoC)** 의 한 형태이며, 플러그인 아키텍처나 프레임워크 설계의 핵심 원리입니다.


##### **상세 설명**

예를 들어, 우리가 웹 프레임워크(상위 수준)를 사용할 때, 우리는 프레임워크의 코드를 직접 호출하지 않습니다. 대신, 프레임워크가 정의한 규칙에 따라 컨트롤러 클래스와 메서드를 작성해두면, 프레임워크가 HTTP 요청이 들어올 때 우리의 메서드를 '호출'해 줍니다. 우리의 코드는 프레임워크라는 큰 제어 흐름에 참여하는 수동적인 존재가 됩니다.

이를 통해 하위 수준 컴포넌트는 상위 수준 컴포넌트의 복잡한 정책이나 제어 흐름에 대해 알 필요가 없게 되어 결합도가 크게 낮아집니다.


### **7.3. 조직 및 아키텍처 연관성 (Organization & Architecture Correlation)**

---


#### **7.3.1. 컨웨이의 법칙 (Conway's Law)**


##### **핵심 아이디어**

> "Any organization that designs a system (in the broad sense) will produce a design whose structure is a copy of the organization's communication structure."
>
> "시스템을 설계하는 조직은 그 조직의 의사소통 구조를 그대로 복제한 듯한 설계를 만들어내게 된다."

이 법칙은 소프트웨어 아키텍처가 기술적인 결정뿐만 아니라, 그것을 만드는 조직의 구조에 의해 크게 영향을 받는다는 통찰을 제공합니다.


##### **상세 설명**

예를 들어, 프론트엔드팀, 백엔드팀, 데이터베이스팀으로 나뉜 조직은 자연스럽게 3-Tier 아키텍처(프레젠테이션, 비즈니스, 데이터 계층)를 만들 가능성이 높습니다. 팀 간의 경계가 곧 아키텍처의 경계가 되기 때문입니다.

만약 우리가 마이크로서비스 아키텍처를 도입하고 싶다면, 단순히 기술만 도입해서는 안 되고, 각 마이크로서비스를 책임지는 작고 독립적인 '목적 조직(Purpose-driven team)'으로 조직 구조를 먼저 개편해야 성공할 가능성이 높습니다. 이를 '역 컨웨이 법칙(Inverse Conway Maneuver)'이라고도 부릅니다. 즉, 우리가 원하는 아키텍처를 얻기 위해 조직 구조를 먼저 그에 맞게 바꾸는 전략입니다. 이 법칙은 아키텍처 결정이 단순히 기술적인 문제가 아니라 조직적, 사회적인 문제임을 일깨워줍니다.
