# CPU / Memory

### CPU

컴퓨터에서 처리를 담당하는 “중앙 처리 장치”. 계산을 잘하지만 다른 지능적인 행위를 하지 못한다.

![](<../../.gitbook/assets/image (1) (1) (1).png>)

### Arithmetic Logic Unit(ALU)

산술 논리 장치로 산술이나 논리같은 수학적 연산을 담당

AU (산술 장치) + LU (논리 장치)를 합친 디지털 회로

**정수 산술 연산:** 더하기, 빼기, 부호 뒤집기, 증가, 감소 등

**비트 논리 연산:** OR AND NOT 등



### Control Unit(CU)

제어 장치로 프로세서의 작업을 제어(=지시를 받아서 명령어로 디코딩)하는 회로

**제어부**:  주기억 장치에 저장되어 있는 **명령어를 순서대로 호출하여 해독**하고, 제어 신호를 발생시켜 컴퓨터의 각 장치의 동작을 제어 (스케쥴링)

**내부버스**: 기억, 연산, 제어 기능을 실현하기 위한 CPU와 주기억 장치, 입출력 장치, 외부 기억 장치, 주변 장치, 통신 처리 장치 등의 제어부 사이를 연결하는 버스



### Memory Unit(MU)

* 레지스터:  처리할 명령어를 저장
* 캐시 메모리(L1):  처리 속도를 높여주는 역할



### Register

작업을 빠르게 처리하기 위한 CPU의 **고속 메모리**

**처리 속도**: 레지스터(CPU) >캐시(주) > RAM(주) > 하드디스크(보조)

**범용 레지스터**: 연산에 필요한 데이터나 연산 결과를 임시로 저장

**특수목적 레지스터**: 특수 목적을 가진 레지스터

* 메모리 주소 레지스터: (MAR) : 읽고 쓰기 위한 주기억장치의 주소를 저장
* 프로그램 카운터 (PC) : 다음에 수행할 명령어의 주소를 저장
* 명령어 레지스터 (IR) : 현재 실행 중인 명령어를 저장
* 메모리 버퍼 레지스터 (MBR) : 주기억장치에서 읽어온 데이터나 저장할 데이터를 임시로 저장
* 누산기 (AC, ACCUMULATOR) : 연산 결과를 임시로 저장



### Cache Memory

`L2, L3 캐시 메모리:` CPU와 별도의 공간에 존재하고 RAM과 CPU 사이에서 버퍼 역할

`CPU 레지스터`: CPU안에서 연산을 처리하고 데이터를 저장하는 공간

메인 메모리에서 데이터 접근하는 시간을 줄이기 위한 메모리

CPU에서 자주 사용하는 데이터나 명령을 저장하여 CPU 성능 향상

CPU 메모리보다 싸고 메인 메모리보다 비싸다

L1은 L2보다 비싸지만 빠르고 용량이 크다.

L2도 L3에 비해 비싸지만 용량이 크다





### BUS

컴퓨터에서, 컴퓨터 간에 데이터를 전송하는 통로

물리적(하드웨어), 추상적(소프트웨어)인 요소를 모두 포함

**내부 버스**: 메인보드에 연결된 메모리 입출력 장치, CPU 간에 데이터 통신과 같이 컴퓨터 내부 요소 간 통신

**외부 버스**: usb로 연결되는 장치, 프린터와 같이 외부 장치를 컴퓨터에 연결하는 통로



### 주기억장치

RAM은 휘발성 메모리로 전원이 공급되지 않으면 데이터가 사라진다.

**정적 메모리(SRAM, Static RAM)**: 기억 장치에 전원이 공급되는 한 그 내용이 계속 보존. CPU 레지스터, 캐시 메모리에 사용

**동적 메모리(DRAM; Dynamic RAM)**: 일반적으로 RAM이라  부르는 것. 계속 공급되어도 재충전을 주기적으로 해야만 내용을 유지할 수 있는 메모리이다.



### 보조기억장치

주 기억장치보다 속도가 느리지만 전원이 공급이 중단되어도 데이터가 유지되는 비휘발성 메모리로 데이터를 오래 저장할 수 있다

**하드디스크(HDD):** 돌아가는 플래터 위에 전자적인 힘을 가해 데이터를 기록

**솔리드스테이드드라이브(SSD**): 순수 전자식으로 동작하고 HDD보다 속도가 빠르다

기타: 플로피 디스크, CD ROM, DVD, Blu-ray, 플래시 메모리



### CPU 동작



```mermaid
graph LR
  인출 --> 해독 --> 실행 --> 반영
```

### 1. 인출(fetch)

프로그램 메모리에서 명령을 검색하고 다음 명령의 주소를 식별

### 2. 해독(decode)

메모리에서 받아온 명령을 제어 신호로 변환(명령코드)

“**명령 코드(opcode;operation code)**”: 명령어를 부호로 나타낸 기계어

### 3. 실행(execute)

제어 신호에 의해 CPU의 다양한 부분이 활성화, 비활성화 되면서 작업을 처리하고

일반적으로 클럭 펄스에 대한 응답 으로 작업이 완료되고,

다음 명령어에서 빠른 접근을 위해 CPU 레지스터에 결과가 기록된다

### 4. 반영(write back)

결과를 메모리에 쓰기



### CPU의 성능

`CPU 클럭`: 초당 명령어를 처리할 수 있는 횟수

`CPU 코어`: 물리적인 CPU의 코어 개수





## 스케쥴링



### 프로세스

프로그램을 실행해주는 주체



### 쓰레드

작업을 처리해주는 주체



### 스케쥴링 단위

**CPU Burst**: 프로세스의 사용중에 연속적으로 CPU를 사용하는 구간. 실제 CPU 를 사용하는 스케쥴링의 단위

**I/O Burst**: I/O작업이 끝날때까지 Block되는 구간

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 스케쥴링 평가 기준

* **CPU 이용률** :  CPU가 작업을 처리하는 시간 / 전체 시스템 시간
* **처리량** : CPU가 처리하는 프로세스의 개수 / 단위 시간
* **총 처리 시간** : 프로세스가 시작해서 끝날때 까지 걸린 시간
* **대기시간** : 프로세스가 준비완료 큐에서 대기하는 시간의 총 합
* **응답시간** : 대화식 시스템에서 요청 후 첫 응답이 오기까지 걸린 시간



### Preemptive Scheduling

{% hint style="info" %}
OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
{% endhint %}

선점 스케쥴링:  OS가 CPU이 사용권을 선점하고, 특정 요건에 따라 각 프로세스의 요청이 있을 때 프로세스에게 분배하는 방식

따라서 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하고긴급한 프로세스를 제어 가능



#### Priority Scheduling(우선순위 스케쥴링)

정적/동적으로 우선순위를 부여하고 우선순위 순서대로 처리 (최소 버스트 시간 기준)

Starvation(기아  현상): 우선순위가 낮은 프로세스는 무한정 기다릴 수도 있다

\-> Aging(노화) 기법으로 해결. 시간에 따라 우선순위를 증가



#### Round Robin(라운드로빈)

{% hint style="info" %}
FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU 할당
{% endhint %}

정해진 시간 할당량 동안 프로세스를 할당하고, 준비완료의큐 마지막으로 이동

시간 할당량이 너무 작을 경우: 빈번한 문맥 전환

시간 할당량이 너무 클 경우: FCFS와 비슷해짐



#### MultiLevel-Queue(다단계 큐)

준비완료 큐를 여러 개의 큐로 분할하여, 각각  큐의  우선순위를  정한다

프로세스를 우선순위에 따라 해당하는 큐에 배치.

우선순위가 높은 큐부터 순서대로 처리



### Non-Preemptive Scheduling

{% hint style="info" %}
프로세스 종료 or I/O 등 이벤트가 있을 때까지 실행 보장 (처리시간 예측 용이)
{% endhint %}

어떤 프로세스가 CPU를 할당받으면 그 프로세스가 종료되거나, 입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되도록 보장

* 순서대로 처리되는 공정성이 있고, 다음에 처리해야할 프로세스와 상관없이 응답시간을 예상 가능
* 선점방식보다 스케쥴러 호출 빈도가 낮고, 문맥교환에 의한 오버헤드가 적다.
* 일괄처리 시스템에 적합하며 자칫 CPU사용시간이 긴 프로세스가 다른 프로세스들을 대기시킬 수 있으므로 처리율이 떨어질 수 있다는 단점이 있습니다.



#### FCFS(First Come, First Serve)

{% hint style="info" %}
큐에 도착한 순서대로 CPU 할당

실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
{% endhint %}

**먼저 도착한 프로세스를 먼저 처리**하는 기본적인 스케쥴링 알고리즘

FIFO큐(먼저 입력된것 먼저 출력)를 이용하여 간단하게 구현

**Convoy Effect(호위 효과)**: 처리시간이 긴 프로세스가 선점되면, 나머지 프로세스의 대기 시간이 매우 길어짐



#### SJF(Shorted Job First)

{% hint style="info" %}
수행시간이 가장 짧다고 판단되는 작업 먼저 수행

FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리
{% endhint %}

CPU 버스트 타임이 가장 짦은, **최단작업을 우선** 스케쥴링

* 가장 적은 평균 대기 시간을 가짐
* 만약 CPU버스트 시간이 동일하다면 FCFS방식을 따름
* 다만 선점형인 경우에는 위와같이 진행이 되지만 비 선점형일 경우엔 최소잔여시간우선 법칙을 따름
* 현재 CPU에 할당된 프로세스의 남은 잔여시간과, 새로 들어온 프로세스의 CPU버스트 타임을 비교하여 더 적은 프로세스에게 할당

#### HRN( Highest Response-ratio Next)

{% hint style="info" %}
우선순위 = (대기시간 + 실행시간) / (실행시간)
{% endhint %}



### 스케쥴링 동작 시점

1. 수행 -> 대기 (Running->Waiting) : I/O요청이 발생하거나, 자식 프로세스가 종료 대기를 할 때
2. 수행 -> 종료 (Running -> Terminate) : 프로세스를 종료시켯을때
3. 수행 -> 준비 (Running-> Ready) : 인터럽트가 발생했을때
4. 대기 -> 준비 (Waiting -> Ready) : I/O가 완료되었을때

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>



#### 선점 스케쥴링 발생 시점

<figure><img src="../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>



#### 비선점 스케쥴링 발생 시점

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>



### Locality(지역성)

{% hint style="info" %}
자주 사용되는 데이터의 특성
{% endhint %}



#### 시간 지역성

* 최근 액세스 된 기억 장소가 가까운 미래에 다시 액세스 가능성 높음



#### 공간 지역성

* 액세스된 기억장소와 인접한 기억장소가 액세스될 가능성 높음



### Cache  Hit

CPU가 데이터를 요청하여 캐시 메모리에 접근했을 때 캐시 메모리에 해당 데이터가 있는 것

* 위치도 가깝고 CPU 내부버스를 기반으로 작동하여 빠르다
* 👉 캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져오게 된다.



### Cache Miss

해당 데이터가 캐시에 없어서 주 기억장치(RAM)로 가서 데이터를 찾아오는 것

* 👉 메모리를 가져올때 시스템 버스를 기반으로 작동하기 때문에 느리다



### Cache Mapping

캐시의 데이터를 메모리와 어떻게 대응시킬지를 결정하는 방법



#### Direct Mapping

직접 매핑 방식

캐시 슬롯과 메모리 주소를 일대일 대응

각 메모리 블록은 고정된 위치의 캐시 슬롯에 저장

처리가 빠르지만 충돌 발생 위험



#### Set Associative Mapping

집합 연관 매핑 방식

캐시를 여러 개의 집합으로 나누고 각 집합은 여러 개의 슬롯으로 구성

충돌을 줄이면서 성능을 향상



#### Fully Associative Mapping

완전 연관 매핑 방식

캐시 슬롯의 개수에 제한없이, 메모리 블록은 어떤 슬롯에든 저장될 수 있음

가장 유연하여 충돌 위험이 가장 적음

검색 시간이 오래 걸리고 하드웨어 복잡성이 증가



## 메모리 할당 방식

### 연속할당

메모리에 연속적으로 공간을 할당

#### 고정 분할 방식

메모리를 미리 특정 크기로 나누어 관리하는 방식

내부 단편화 발생 (메모리가 커서할당되고 남은 공간이낭비)

#### 가변 분할 방식

매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용하는 방식

1. 최초 적합: 처음 보이는 공간에 먼저 할당
2. 최적 적합: 가장 크기에 맞는 공간에 먼저 할당
3. 최악 적합: 가장 크기가 큰 공간에 먼저 할당

외부 단편화 발생 (메모리가 작아 할당되지 못해 공간이 낭비)



### 불연속 할당

여러 작업을 효율적으로 수행하기 위해 사용

{% hint style="warning" %}
메모리 공간 할당과 해제 시 오버헤드 발생

메모리 공간이 분상되어 프로세스가 불연속 공간에 할당 시 페이지 교체 같은 작업의 복잡성 증가
{% endhint %}

1. **Linked List**: 불연속 공간에 프로세스를 할당할 때, **할당된 공간의 주소를 연결리스트에 저장**하는 방식입니다. 이 방식은 메모리 할당과 해제가 빠르지만, 공간 낭비가 발생할 수 있음
2. **Bitmap**: **메모리 공간의 각 블록을 0 또는 1로 표시**하여 사용 가능한 블록과 사용 중인 블록을 구분하는 방식입니다. 이 방식은 링크드 리스트보다 효율적인 공간 관리를 제공하지만, 메모리 크기가 큰 경우 비트맵이 매우 커지는 단점이 있습니다.
3. **Page Table**: 가상 메모리 시스템에서 사용되는 방식으로, 물리적인 주소 공간을 페이지라는 작은 블록으로 나누어 사용합니다. 각 프로세스는 자신의 페이지 테이블을 가지며, 페이지 테이블은 물리적인 주소와 가상 주소를 매핑하는 역할을 합니다. 이 방식은 링크드 리스트와 비트맵보다 효율적이며, 가상 메모리를 구현하는 데 필요한 기술\


#### Paging

* **동일한 크기의 페이지 단위** 나누어 메모리의 서로 다른 위치에 프로세스를 할당
* 빈데이터(홀)의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡

#### Segmentation

* 코드,  데이터, 함수 등 의미 단위 세그먼트로 나눔
* 빈데이터(홀) 크기가 균일하지 않는 문제 발생

#### Paged _Segmentation_

* 공유나 보안은 세그먼트, 물리적 메모리는 페이지로 나누는 방식

### 페이지 교체 알고리즘

페이지 부재로 인해새로운 페이지를 적재할 때 메모리에 저장된 페이지 중 어떤 페이지를 교체할지 결정하는 알고리즘

#### 시간 기반 알고리즘

1. FIFO(First In First Out): 가장 먼저 들어온 페이지를 교체\
   오래된 데이터가 최근에 사용된 데이터와 비슷하면 성능 저하
2. LRU(Least Recently Used): 참조가 가장 오래된 페이지를 교체\
   페이지를 사용할 때마다 사용 시간을 갱신\
   추가적으로계수기, 스택이 필요
3. NUR(Not Used Recently): 참조 비트와 변경 비트를 사용하여 가장 낮은 우선순위의 페이지를 교체

#### 빈도 기반 알고리즘

1. LFU(Least Frequently Used): 가장 참조 횟수가 적은 페이지를 교체\
   일부 데이터가 빈번하게 사용되면 성능 저하





## 프로세스 생명주기

### 신규 상태(New)

* 프로세스를 메인 메모리에 가져온 상태
* 신규 상태 —> **수용(admit)** —> 준비상태

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>



### 준비 상태(Ready)

준비 작업을 마치고 실행할 수 있는 상태

준비 상태 —> **스케쥴러 발송(scheduler dispatch)** —> 수행 상태

* 준비 상태가 되는 경우
  * **신규** 프로세스에서 수용됨
  * **대기** 프로세스에서 입출력/이벤트가 완료됨
  * **수행** 프로세스가 중단됨

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>



### 수행 상태(Running)

CPU가 실제로 프로세스를 수행하고 있는 상태

* 선점 스케쥴링에 의한 중단 → **준비** 상태로
* 입출력/이벤트가 필요 시 → **대기** 상태로
* 수행 완료 시 → **종료** 상태

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

### 대기 상태(**Waiting)**

프로세스 도중에 I/O 작업이 필요하여 I/O 작업을 수행하는 상태

CPU는 I/O를 기다리고, 다른 프로세스 작업을 수행할 수 있다

* 대기 상태 종료 시 → 준비 상태로

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>



### 종료 상태(Terminated)

프로세스가 종료된 상태

사용하던 메모리 영역이 해제

수행 상태 —> **탈출(exit)** —> 종료 상태



<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>



## 대기 큐(Waiting Queue)

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

{% embed url="https://gusdnd852.tistory.com/82" %}

### 1. Job Queue

HDD에서 프로그램을 메모리에 올릴 때 메모리가 꽉차면 대기하는 공간

HDD -> \[Job Queue] -> Memory



### 2. Ready Queue

CPU가 이미 사용 중일 때 메모리에서 올라온 프로세스들이 실행을 위해 대기하는 공간

Memory -> \[Ready Queue] -> CPU



### 3. Device Queue

입출력 장치를 이용하기 위해 입출력 작업을 기다리는 공간

I/O 장치 큐들을 통틀어 부름



## 스케줄링

### Job Secheduler

* Job Queue의 프로그램들을 어떤 순서로 메모리에 올릴지 결정
* 프로그램이 새로 시작될 때, 메모리가 가득 찼을 때



### CPU Scheduler

* Ready Queue의 프로세스들을 어떤 순서로 서비스 할 것인지(CPU에 올릴 것인지) 결정



### Device Scheduler

* Device Queue의 프로세스들을 어떤 순서로 I/O 장치를 이용하게 할 것인지 결정
* I/O Bound Process → 대부분 시간을 I/O에 사용
* CPU Bound Process → 대부분 시간을 CPU 연산에 사용



## **Swapping**

오랫동안 동작이 없는 프로세스는 잠시 HDD로 내려놓고, 다른 프로세스를 실행하거나 기존 프로세스에 메모리를 더 할당하는 등 메모리를 더 효율적으로 활용

* **Swap Out:** 메모리 -> HDD로 내리는 작업
* **Swap In:** HDD -> 메모리로 다시 올리는 작업



## 문맥 교환 (Context Switching)

### Context Switching

* CPU 시간공유 시스템의 경우 일정 시간이 지나면 기존 프로세스를 **준비** 상태로 만들고 다른 프로세스를 **수행** 상태로 만들어서 실행

### Scheduler

* Context Switching을 전문적으로 담당하는 스케줄러는 위에서 배운 CPU 스케줄러
* CPU 스케줄러는 Ready Queue에 대기 중인 프로세스를 어떤 순서로 실행시킬 것인지에 대한 스케줄러

### Dispatcher

* 스위치할 때 이 정보들을 보존해야 A의 차례가 돌아왔을 때 이전에 수행하던 작업이 끊기지 않고 수행될 수 있습니다.
* 다른 프로세스 작업 시 현재 작업의 정보를 임시 저장하고 다시 자신의 작업 차례가 왔을 때 꺼내 씀



## 프로세스 메모리

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

![https://zangzangs.tistory.com/107](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c7a88adb-1817-40e6-bcf8-c625a1ac0fa3/Untitled.png)

### Code 영역

* **실행할 프로그램의 코드**가 저장

### Data 영역

* **전역변수와 정적변수**가 저장
* 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸

### Stack 영역

* 호출된 함수의 수행을 마치고 **복귀할 주소** 및 **데이터**(지역변수, 매개변수, 리턴값 등)를 임시로 저장
* 함수 호출시 기록하고 함수의 수행이 완료되면 사라진다
* 컴파일 시 stack 영역의 크기가 결정되기 때문에 무한정 할당 할 수 없다

### Heap 영역

* **동적 데이터 영역**
* 메모리 주소 값에 의해서만 참조되고 사용되는 영역
* 런타임 시에 결정



## 커널

* 커널은 대부분의 운영 체제(OS)의 주요 구성 요소이며 **컴퓨터 하드웨어와 프로세스**를 잇는 핵심 **인터페이스**
* 메모리 관리, 프로세스 관리, 하드웨어와 프로세스 사이에서 명령을 즉시 실행할 수 있는(인터프리터) 역할을 수행하거나 시스템의 호출이나 보안등의 기능을 수행

### Code 영역

* 시스템 콜, 중단(인터럽트) 처리 코드
* CPU, 메모리 등 자원 관리를 위한 코드
* 편리한 인터페이스 제공을 위한 코드

### Data 영역

* CPU, Memory 등 하드웨어 자원을 관리하기 위한 자료구조가 저장
* **PCB(Process Controll Block)**
  * 현재 수행 중인 프로세스의 상태, CPU 사용 정보 등을 유지하기 위한 자료구조
  * 운영체제에서 프로세스에 대한 모든 정보를 저장하는 데이터 구조

### Stack 영역

* 각 Process의 커널 스택을 저장
* 프로세스는 함수 호출시 자신의 복귀 주소를 저장하지만, 커널은 커널 내의 주소가 된다.
* 각각의 프로세스마다 별도의 스택을 두어 관리





## 스레드

### 프로세스

* 자신만의 고유 공간 자원을 할당 받음
* 메모리에서의 실행중인 프로그램 단위
* 다른 프로세스의 변수나 자료에 접근할 수 없다
* 운영체제로부터 시스템 자원을 할당받는 자원의 단위
* 최소 1개 이상의 스레드를 가짐

### 스레드

* 다른 프로세스와 공간, 자원을 공유하면서 사용됨
* 프로세스에 작업을 처리하는 주체
* 스레드는 Stack 을 제외한 Code/Data/Heap 부분은 공유해 서로 읽고 쓸 수 있음



#### 스레드 장점

* 프로세스 보다 크기가 작은 실행 단위 구현
* 프로세스의 생성 및 소멸에 따른 오버헤드 감소
* 쓰레드간 자원을 공유 함으로써 빠른 컨텍스트 스위칭
* 프로세스 들의 통신 시간, 방법 어려움 해소

### 멀티 스레드

{% hint style="info" %}
💡 **멀티 프로세스 :** 하나의 운영체제 안에서 여러 프로세스가 실행되는 것

**멀티 쓰레드 :** 하나의 프로세스가 여러 작업을 여러 쓰레드를 사용해 동시에 처리하는 것
{% endhint %}

### 멀티 프로세스

* 하나의 프로그램을 여러 프로세스로 구성
* 여러 프로세스 중 하나에 문제가 발생하도 다른 프로세스에 영향을 주지 않음
* 문맥 전환 과정에서 오버헤드 발생
* 프로세스 간 통신을 위해 IPC 필요
* 프로세스 간 공유하는 메모리가 없음

### 멀티 스레드

* 하나의 프로그램을 여러 개의 스레드로 구성
* 시스템 자원 소모 감소
* 시스템 처리량 감소



🟢 **멀티 쓰레드의 장점**

1. Context-Switching 할 때 공유하고 있는 메모리만큼 **메모리 자원을 아낄 수 있다.**
2. 쓰레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 **통신 부담이 적어서 응답 시간이 빠르다.**



**🔴 멀티 쓰레드의 단점**

1. 쓰레드 하나가 프로세스 내 자원을 망쳐버린다면 **모든 프로세스가 종료될 수 있다.**
2. 자원을 공유하기 때문에 필연적으로 **동기화 문제**⚠️가 발생할 수 밖에 없다. 교착상태가 발생하지 않도록 주의해야 한다.
3. 디버깅이 까다롭다



### 스레드 풀

컴퓨터 프로그램에서 실행의 동시성을 달성하기 위한 소프트웨어 디자인 패턴

* 프로그램이 작업을 동시에 실행할 수 있도록 여러 스레드를 미리 생성해두고 유지 관리
* 작업 처리에 사용되는 쓰레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 쓰레드가 맡아 처리하는 것



#### 스레드 풀 사용 이유

1. **프로그램 성능 저하를 방지하기 위해**
   1. 쓰레드를 생성/수거하는 데 따른 부담은 프로그램 전체적인 퍼포먼스를 저하하기 때문
2. **다수의 사용자 요청을 처리하기 위해**
   1. 다수의 사용자의 요청을 수용하고, 빠르게 처리하고 대응

#### 스레드 풀 장점

* 쓰레드를 생성/수거하는데 비용이 들지 않는다
* 쓰레드가 생성될 때 OS가 메모리 공간을 확보해주고 메모리를 쓰레드에게 할당
* 쓰레드 풀을 미리 만들어 두기 때문에 처음에 생성하는 비용은 들지만 이전의 쓰레드를 재사용할 수 있으므로 시스템 자원을 줄일 수 있음.
* 작업을 요청 시 이미 쓰레드가 대기 중인 상태이기 때문에 작업을 실행하는 데 딜레이가 발생하지 않습니다.

#### 스레드 풀 단점

* 스레드 풀에 스레드를 너무 많이 생성해 두었다가 사용하지 않으면 메모리 낭비가 발생합니다.
* 스레드 풀의 단점 개선 : **Fork Join Thread Pool**



### 동시성 병렬성

#### 동시성

싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질

#### 병렬성

멀티 코어에서 멀티 스레드를 동작시키는 방식으로, 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질



