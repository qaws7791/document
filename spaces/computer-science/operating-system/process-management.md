# 프로세스 관리

운영체제(OS)는 컴퓨터 시스템의 핵심 구성 요소로서, 프로세스를 관리하는 중요한 역할을 합니다. 이 문서에서는 운영체제에서의 프로세스 관리에 대한 개념, 원리, 그리고 실질적인 구현 방법을 다룹니다. 운영체제는 현대 컴퓨터 시스템에서 필수적인 역할을 하며, 사용자와 하드웨어 간의 다리 역할을 수행합니다.

## 프로세스란 무엇인가?

프로세스(Process)는 실행 중인 프로그램을 의미합니다. 프로그램이 정적인 코드라면, 프로세스는 동적인 실행 단위입니다. 운영체제는 프로세스를 생성하고, 실행을 관리하며, 종료하는 책임을 집니다. 이 프로세스는 단순히 코드를 실행하는 것에 그치지 않고, 자원을 효율적으로 사용하며 다중 작업을 지원합니다.

* 자신만의 고유 공간 자원을 할당 받음
* 메모리에서의 실행중인 프로그램 단위
* 다른 프로세스의 변수나 자료에 접근할 수 없다
* 운영체제로부터 시스템 자원을 할당받는 자원의 단위
* 최소 1개 이상의 스레드를 가짐

### **프로세스 vs 프로그램**

* 프로세스는 운영체제가 프로그램에 CPU, 메모리, 파일, 입출력 장치와 같은 자원을 할당하여 실제로 실행되도록 만든 것입니다.
* 프로그램은 정적인 코드와 데이터로 구성되지만, 프로세스는 프로그램이 메모리에서 실행되는 **동적**인 개체입니다.

| **구분**     | **프로그램**            | **프로세스**                        |
| ---------- | ------------------- | ------------------------------- |
| **정적/동적**  | 정적(코드와 데이터의 집합)     | 동적(실행 중인 작업)                    |
| **메모리 위치** | 디스크에 저장             | 메모리에서 실행                        |
| **상태 변화**  | 상태 변화 없음            | Ready, Running, Waiting 등 상태 변화 |
| **자원 사용**  | CPU, 메모리 등 자원 필요 없음 | CPU, 메모리, 입출력 장치 필요             |

### 멀티 프로세스

* **멀티 프로세스**: 하나의 운영체제 안에서 여러 프로세스가 실행되는 것
* **멀티 스레드**: 하나의 프로세스가 여러 작업을 여러 스레드를 사용해 동시에 처리하는 것
* 하나의 프로그램을 여러 프로세스로 구성
* 여러 프로세스 중 하나에 문제가 발생하도 다른 프로세스에 영향을 주지 않음
* 문맥 전환 과정에서 오버헤드 발생
* 프로세스 간 통신을 위해 IPC 필요
* 프로세스 간 공유하는 메모리가 없음

## 스레드(Thread)

스레드(Thread)는 프로세스 내에서 실행되는 작업의 최소 단위로, 같은 메모리 공간을 공유합니다. 스레드는 프로세스 내에서 여러 개가 동시에 실행될 수 있으며, 프로세스의 자원을 공유하면서 작업을 처리합니다.

* 다른 프로세스와 공간, 자원을 공유하면서 사용됨
* 프로세스에 작업을 처리하는 주체
* 스레드는 Stack 을 제외한 Code/Data/Heap 부분은 공유해 서로 읽고 쓸 수 있음
* **스레드의 장점**
  * 프로세스 보다 크기가 작은 실행 단위 구현
  * 프로세스의 생성 및 소멸에 따른 오버헤드 감소
  * 스레드간 자원을 공유 함으로써 빠른 컨텍스트 스위칭
  * 프로세스 들의 통신 시간, 방법 어려움 해소

### 멀티 스레드

스레드를 활용하면 멀티스레드 프로그래밍이 가능하며, 프로그램의 병렬 처리를 더욱 효율적으로 수행할 수 있습니다

* 하나의 프로그램을 여러 개의 스레드로 구성
* 시스템 자원 소모 감소
* 시스템 처리량 감소

#### 멀티 스레드의 장점

1. Context-Switching 할 때 공유하고 있는 메모리만큼 **메모리 자원을 아낄 수 있다.**
2. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 **통신 부담이 적어서 응답 시간이 빠르다.**

#### 멀티 스레드의 단점

1. 스레드 하나가 프로세스 내 자원을 망쳐버린다면 **모든 프로세스가 종료될 수 있다.**
2. 자원을 공유하기 때문에 필연적으로 **동기화 문제**⚠️가 발생할 수 밖에 없다. 교착상태가 발생하지 않도록 주의해야 한다.
3. 디버깅이 까다롭다

### 스레드 풀

컴퓨터 프로그램에서 실행의 동시성을 달성하기 위한 소프트웨어 디자인 패턴

* 프로그램이 작업을 동시에 실행할 수 있도록 여러 스레드를 미리 생성해두고 유지 관리
* 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것
* 스레드 풀의 크기는 작업 실행을 위해 예비로 생성해 둘 스레드의 최대 개수를 의미

#### 스레드 풀 사용 이유

1. **프로그램 성능 저하를 방지하기 위해**
   1. 스레드를 생성/수거하는 데 따른 부담은 프로그램 전체적인 퍼포먼스를 저하하기 때문
2. **다수의 사용자 요청을 처리하기 위해**
   1. 다수의 사용자의 요청을 수용하고, 빠르게 처리하고 대응

#### 스레드 풀 장점

* 스레드를 생성/수거하는데 비용이 적게 든다.
* 스레드가 생성될 때 OS가 메모리 공간을 확보해주고 메모리를 스레드에게 할당.
* 스레드 풀을 미리 만들어 두기 때문에 처음에 생성하는 비용은 들지만 이전의 스레드를 재사용할 수 있으므로 시스템 자원을 줄일 수 있음.
* 작업을 요청 시 이미 스레드가 대기 중인 상태이기 때문에 작업을 실행하는 데 딜레이가 발생하지 않습니다.

#### 스레드 풀 단점

* 스레드 풀에 스레드를 너무 많이 생성해 두었다가 사용하지 않으면 메모리 낭비가 발생합니다.
* 스레드 풀의 단점 개선 : **Fork Join Thread Pool**

### 프로세스의 상태

## 프로세스 생명주기

**주요 상태**

1. **New**: 프로세스 생성 중.
2. **Ready**: 실행 대기 상태(스케줄링을 기다림).
3. **Running**: CPU에서 실행 중.
4. **Waiting**: 입출력 등 외부 이벤트를 기다리는 상태.
5. **Terminated**: 실행 종료.

**생명주기가 변경되는 시점**

1. 수행 -> 대기 (Running->Waiting) : I/O요청이 발생하거나, 자식 프로세스가 종료 대기를 할 때
2. 수행 -> 종료 (Running -> Terminate) : 프로세스를 종료시켰을때
3. 수행 -> 준비 (Running-> Ready) : 인터럽트가 발생했을때
4. 대기 -> 준비 (Waiting -> Ready) : I/O가 완료되었을때

!\[프로세스 생명주기]\(assets/image (2) (1).png)

**선점 스케줄링 발생 시점**

!\[image (../computer-system/assets/image (4) (1).png) (1)]\(assets/image (4) (1).png)

**비전섬 스케줄링 발생 시점**

!\[image (../computer-system/assets/image (3) (1).png) (1)]\(assets/image (3) (1).png)

### 신규 상태(New)

* 프로세스를 메인 메모리에 가져온 상태
* 신규 상태 —> **수용(admit)** —> 준비상태

![image](assets/image.png)

### 준비 상태(Ready)

준비 작업을 마치고 실행할 수 있는 상태

준비 상태 —> **스케쥴러 발송(scheduler dispatch)** —> 수행 상태

* 준비 상태가 되는 경우
  * **신규** 프로세스에서 수용됨
  * **대기** 프로세스에서 입출력/이벤트가 완료됨
  * **수행** 프로세스가 중단됨

![image (1)](<assets/image (1).png>)

### 수행 상태(Running)

CPU가 실제로 프로세스를 수행하고 있는 상태

* 선점 스케쥴링에 의한 중단 → **준비** 상태로
* 입출력/이벤트가 필요 시 → **대기** 상태로
* 수행 완료 시 → **종료** 상태

![image (2)](<assets/image (2).png>)

### 대기 상태(**Waiting)**

프로세스 도중에 I/O 작업이 필요하여 I/O 작업을 수행하는 상태

CPU는 I/O를 기다리고, 다른 프로세스 작업을 수행할 수 있다

* 대기 상태 종료 시 → 준비 상태로

![image (3)](<assets/image (3).png>)

### 종료 상태(Terminated)

프로세스가 종료된 상태

사용하던 메모리 영역이 해제

수행 상태 —> **탈출(exit)** —> 종료 상태

![image (4)](<assets/image (4).png>)

## 프로세스 제어 블록 (PCB)

운영체제는 각 프로세스를 관리하기 위해 프로세스 제어 블록(PCB, Process Control Block)을 사용합니다. PCB는 다음과 같은 정보를 포함합니다:

* **프로세스 상태**: 실행 중, 대기 중, 준비 상태 등 프로세스의 현재 상태.
* **프로세스 권한**: 시스템 리소스에 대한 액세스를 위한 허용 권한.
* **프로세스 ID (PID)**: 각 프로세스를 고유하게 식별하기 위한 ID 값.
* **포인터**: 부모 프로세스를 가리키기 위한 포인터.
* **프로그램 카운터**: 다음에 실행될 명령어의 주소를 가리키는 포인터.
* **CPU 레지스터 값**: 프로세스가 실행 상태를 위해 저장되어야 하는 다양한 CPU 레지스터의 값.
* **프로세스 우선순위**: 프로세스 스케줄링 시 고려되는 우선순위.
* **메모리 관리 정보**: 코드, 데이터, 스택의 메모리 위치.
* **입출력 정보**: 열려 있는 파일, 입출력 장치 상태.

PCB는 운영체제가 프로세스를 효율적으로 스케줄링하고 관리할 수 있도록 돕습니다. 이 정보는 컨텍스트 스위칭 시 저장 및 복구되며, 시스템 성능에 직접적인 영향을 미칩니다.

## 프로세스 메모리

### Code 영역

* **실행할 프로그램의 코드**가 저장

### Data 영역

* **전역변수와 정적변수**가 저장
* 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸

### Stack 영역

* 호출된 함수의 수행을 마치고 **복귀할 주소** 및 **데이터**(지역변수, 매개변수, 리턴값 등)를 임시로 저장
* 함수 호출시 기록하고 함수의 수행이 완료되면 사라진다
* 컴파일 시 stack 영역의 크기가 결정되기 때문에 무한정 할당 할 수 없다

### Heap 영역

* **동적 데이터 영역**
* 메모리 주소 값에 의해서만 참조되고 사용되는 영역
* 런타임 시에 결정

!\[image (7)]\(assets/image (7).png)

## 프로세스 스케줄링

**프로세스 스케줄링**은 운영체제에서 **CPU 시간**을 여러 프로세스에게 효율적으로 할당하는 기법을 말합니다. 동시에 여러 프로세스가 실행될 때, CPU는 한 번에 하나의 프로세스만 처리할 수 있으므로 어떤 프로세스에게 언제 CPU를 할당할지 결정하는 것이 중요합니다

### 프로세스 스케줄링 목적

* **멀티태스킹 환경(Multi tasking)**: 현대의 운영체제는 여러 프로세스가 동시에 실행되는 멀티태스킹을 지원합니다.
* **공정성(Fairness):** 모든 프로세스가 자원을 공정하게 사용할 수 있도록 보장.
* **자원 활용률(Resource Utilization):** CPU, 메모리, I/O 장치 등 자원의 사용률을 최대화.
* **대기 시간 최소화(Turnaround Time):** 프로세스가 제출된 후 종료될 때까지의 시간을 최소화.
* **응답 시간 최소화(Response Time):** 대화형 시스템에서 사용자가 요청한 작업에 대한 초기 응답 시간을 최소화.
* **스루풋(Throughput):** 단위 시간당 완료된 작업 수를 최대화.

### 스케줄링 단위

\- **CPU Burst**: 프로세스의 사용중에 연속적으로 CPU를 사용하는 구간. 실제 CPU 를 사용하는 스케쥴링의 단위

\- **I/O Burst**: I/O작업이 끝날때까지 Block되는 구간

!\[image (1) (1) (1) (1)]\(assets/image (1) (1) (1) (1)-1735889577230-9.png)

### 스케줄링 수준

1. **장기 스케줄러(Long-Term Scheduler):**
   * **목적:** 시스템에 들어오는 프로세스를 관리하고, 어떤 프로세스를 준비 큐에 추가할지 결정.
   * **특징:** 프로세스의 생성 빈도가 낮음. (예: 사용자 프로그램이 실행 요청을 할 때)
   * **역할:** CPU와 메모리 사용률을 균형 있게 유지.
2. **중기 스케줄러(Mid-Term Scheduler):**
   * **목적:** 실행 중인 프로세스를 메모리에서 제거하거나 다시 메모리에 올리는 작업(스왑)을 수행.
   * **특징:** 시스템의 메모리 사용을 최적화하고, 오버로드를 방지.
   * **역할:** 프로세스가 너무 많아 메모리가 부족할 때 일부 프로세스를 스왑 아웃(swap-out)하여 효율성 유지.
3. **단기 스케줄러(Short-Term Scheduler):**
   * **목적:** 준비 상태에 있는 프로세스 중에서 실행할 프로세스를 선택.
   * **특징:** 자주 실행되며, 선택 속도가 매우 중요.
   * **역할:** **CPU 스케줄러**라고도 하며, 실행 가능한 프로세스를 선택해 CPU를 할당.

### 스케줄링 기준

프로세스를 스케줄링할 때 고려되는 주요 성능 기준:

1. **CPU 이용률(CPU Utilization):**
   * CPU가 유휴 상태가 아닌, 작업 중인 시간을 최대화.
2. **처리량(Throughput):**
   * 단위 시간당 완료된 프로세스의 수.
3. **대기 시간(Waiting Time):**
   * 프로세스가 준비 큐에서 대기한 총 시간.
4. **응답 시간(Response Time):**
   * 프로세스가 요청을 제출한 후, 첫 응답이 도달할 때까지의 시간.
5. **공정성(Fairness):**
   * 모든 프로세스가 CPU를 사용할 기회를 공정하게 보장.

### 스케줄링 대기열

OS는 프로세스 스케줄링 큐에 있는 모든 프로세스 제어 블록(PCB)을 유지합니다. OS는 각 프로세스 상태에 대해 별도의 큐를 유지 관리하고 동일한 실행 상태에 있는 모든 프로세스의 PCB는 동일한 큐에 배치됩니다. 프로세스의 상태가 변경되면 해당 PCB는 현재 큐에서 연결 해제되고 새 상태 큐로 이동합니다.

* **작업 대기열(Ready Queue)** − 이 대기열은 시스템의 모든 프로세스를 보관합니다.
* **준비 큐(Job Queue)** − 이 큐는 메인 메모리에 상주하는 모든 프로세스 집합을 준비하고 실행을 기다립니다. 새 프로세스는 항상 이 큐에 배치됩니다.
* **장치 대기열(Device Queue)** − I/O 장치를 사용할 수 없어 차단된 프로세스가 이 대기열을 구성합니다.

![queuing\_diagram (https://www.tutorialspoint.com)](assets/queuing_diagram.jpg)

### 문맥 교환 (Context Switching)

문맥 교환은 프로세스 제어 블록에서 CPU의 상태와 컨텍스트를 저장하고 복원하는 기능을 통해 프로세스 실행을 나중에 같은 지점에서 재개할 수 있도록 한다. 이를 통해 단일 CPU가 여러 프로세스를 작업할 수 있게 해준다.

#### Scheduler

* Context Switching을 전문적으로 담당하는 스케줄러는 위에서 배운 CPU 스케줄러
* CPU 스케줄러는 Ready Queue에 대기 중인 프로세스를 어떤 순서로 실행시킬 것인지에 대한 스케줄러

#### Dispatcher

* 스위치할 때 이 정보들을 보존해야 A의 차례가 돌아왔을 때 이전에 수행하던 작업이 끊기지 않고 수행될 수 있습니다.
* 다른 프로세스 작업 시 현재 작업의 정보를 임시 저장하고 다시 자신의 작업 차례가 왔을 때 꺼내 씀

### 스케줄링 알고리즘

스케줄링 알고리즘은 시스템의 성능과 사용자 경험에 큰 영향을 미칩니다. 운영 체제에서 사용되는 스케줄링 알고리즘은 크게 \*\*비선점(Non-Preemptive)\*\*과 \*\*선점(Preemptive)\*\*으로 나뉩니다.

#### 1. **비선점 스케줄링**

* 어떤 프로세스가 CPU를 할당받으면 그 프로세스가 종료되거나, 입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되도록 보장
* **FCFS(First-Come, First-Served)**:
  * 가장 먼저 도착한 프로세스를 먼저 실행하는 기본적인 스케줄링 알고리즘.
  * 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐.
  * **호위 효과(Convoy Effect)**: 처리시간이 긴 프로세스가 선점되면, 나머지 프로세스의 대기 시간이 매우 길어짐.
* **SJF(Shortest Job First)**:
  * 실행 시간이 가장 짧은 프로세스를 먼저 실행.
  * 만약 CPU 버스트 시간이 동일하면 FCFS 방식을 따름.
  * 현재 CPU에 할당된 프로세스의 남은 잔여시간과 새로 들어온 프로세스의 CPU버스트 타임을 비교하여 더 적은 프로세스에게 할당
  * FCFS에 비해 평균 대기 시간 최소화에 유리하지만, 실행 시간이 긴 프로세스는 계속 뒤로 밀리는 기아 상태에 빠질 수 있음.
* #### HRN(Highest Response-ratio Next)
  * 공식에 따라 우선순위를 계산하여 순서를 할당하는 스케줄링.
  * SJF 스케줄링의 문제점을 보완한 방식.
  * 우선순위 = (대기시간 + 실행시간) / (실행시간).

#### 2. **선점 스케줄링**

* OS가 CPU이 사용권을 선점하고, 특정 요건에 따라 각 프로세스의 요청이 있을 때 프로세스에게 분배하는 방식
* 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하고 긴급한 프로세스를 제어 가능
* **Round Robin (RR)**:
  * 각 프로세스에 고정된 시간(Time Quantum)을 할당. 시간 초과 시 준비 큐의 끝으로 이동.
  * 시간 제한을 통해 공정성이 보장되며 대화형 시스템에 적합.
* **SRTF(Shortest Remaining Time First)**:
  * 남은 실행 시간이 가장 짧은 프로세스를 우선 실행.
  * SJF의 선점형 버전.
* **Priority Scheduling**:
  * 각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스를 먼저 실행.
  * 우선순위가 낮은 프로세스는 \*\*기아 현상(Starvation)\*\*에 빠질 가능성 있음.
  * 시간에 따라 우선순위를 증가시키는 Aging(노화) 기법으로 기아 현상을 해결.
* **다단계 큐(Multi-Level Queue)**:
  * 준비완료 큐를 여러 개의 큐로 분할하여, 각각 큐의 우선순위를 정함.
  * 프로세스를 우선순위에 따라 큐에 배치.
  * 각 큐는 고유한 스케줄링 알고리즘을 가짐.
* **다단계 피드백 큐(Multi-Level Feedback Queue)**:
  * 프로세스가 시간 초과 시 낮은 우선순위 큐로 이동. 동적으로 우선순위를 조정.
* **FCFS (First-Come, First-Served):** 도착 순서대로 처리. 간단하지만 기아 문제 발생 가능.
* **SJF (Shortest Job First):** 실행 시간이 짧은 작업을 우선 처리. 평균 대기 시간을 최소화하지만, 긴 작업은 배제될 수 있음
* **Round Robin (RR):** 각 프로세스에 CPU 시간을 고르게 분배. 시간 제한을 둬 공정성을 보장.
  * 시간 할당량이 너무 작은 경우: 빈번한 문맥 교환으로 성능 저하.
  * 시간 할당량이 너무 클 경우: FCFS와 비슷해짐.
* **Priority Scheduling:** 우선순위가 높은 프로세스부터 처리. 우선순위에 따라 낮은 프로세스가 기아 상태에 빠질 위험 있음.
* **멀티레벨 큐 스케줄링:** 다양한 우선순위 그룹으로 프로세스를 나누고 별도의 큐에서 스케줄링을 수행.

## 프로세스 간 통신 (IPC)

운영체제에서 여러 프로세스가 협력하여 작업을 수행할 때, 프로세스 간 통신(IPC, Inter-Process Communication)이 필요합니다. IPC는 프로세스가 데이터를 교환하고 협력하도록 돕는 핵심 메커니즘입니다.

### 리소스 공유 관점의 프로세스 구분

* **독립 프로세스**: 독립 프로세스는 다른 프로세스의 실행에 영향을 받지 않습니다. 독립 프로세스는 다른 프로세스와 데이터나 리소스를 공유하지 않는 프로세스입니다.
* **협력 프로세스**: 협력 프로세스는 다른 프로세스와 데이터를 공유하거나 서로 통신하여 작업을 수행하는 프로세스입니다.협력 프로세스는 다른 실행 프로세스의 영향을 받을 수 있습니다. 프로세스 간 통신(IPC)은 프로세스가 서로 통신하고 동작을 동기화할 수 있도록 하는 메커니즘입니다.

### IPC의 주요 기법

1. **공유 메모리:** 프로세스들이 메모리 영역을 공유하여 데이터를 교환. 빠르지만 동기화 문제가 발생할 수 있음
2. **메시지 전달:** 프로세스들이 메시지를 통해 데이터를 교환. 간단하고 안정적이지만 속도는 느릴 수 있음
3. **파이프:** 프로세스 간의 단방향 또는 양방향 데이터 흐름을 지원. 고전적인 IPC 방식 중 하나
4. **소켓:** 네트워크를 통해 통신하는 프로세스에 사용

### IPC의 장점

* 프로세스간 통신과 리소스 공유를 통한 효율적인 협력
* 여러 프로세스 간의 조정을 용이하게 하여 시스템 성능을 향상
* 여러 컴퓨터와 네트워크를 통해 프로세스 간 통신이 가능하여 분산 처리를 지원
* 다양한 동기화 및 통신 기법을 제공하여 복잡한 작업을 수행할 수 있음

### IPC의 단점

* 시스템 복잡성 증가
* 프로세스 간 보안 문제 발생 가능
* IPC 작업으로 인한 오버헤드 발생
* 여러 프로세스가 동시에 데이터를 수정할 때 데이터 무결성 문제 발생 가능

## 프로세스 동기화

* 프로세스 동기화는 다중 프로세스가 동시에 실행될 때 **공유 자원**이나 **데이터에 대한 일관성**을 유지하기 위해 프로세스 간의 실행 순서를 제어하는 기법입니다.
* 주로 **운영 체제**, **멀티스레드 애플리케이션**, 또는 **분산 시스템**에서 중요한 역할을 합니다. 프로세스 동기화는 특히 \*\*경쟁 상태(Race Condition)\*\*를 방지하는 데 사용됩니다.

### 프로세스 동기화의 필요성

1. **공유 자원 접근**
   * 여러 프로세스가 동시에 \*\*공유 데이터나 자원(예: 파일, 메모리, 프린터)\*\*에 접근할 경우 데이터의 **무결성**이 훼손될 위험이 있습니다.
   * 예: 한 프로세스가 파일을 작성하는 동안 다른 프로세스가 동일한 파일을 읽거나 수정하면 데이터가 손상될 수 있습니다.
2. **경쟁 상태 방지**
   * 두 개 이상의 프로세스가 **공유 데이터**를 수정하려 할 때, 결과가 프로세스 실행 순서에 따라 달라질 수 있는 문제를 말합니다.
   * 예: 두 프로세스가 동일한 계좌에 입금 작업을 수행할 때 결과가 비일관적으로 계산될 수 있습니다.
3. **데드락(교착 상태) 예방**
   * 두 프로세스가 서로의 자원을 대기하면서 무한 대기 상태에 빠질 수 있습니다. 동기화는 이를 방지할 수 있는 규칙을 제공합니다.

### 프로세스 동기화의 주요 문제

1. **임계 구역 문제(Critical Section Problem)**
   * **임계 구역**이란 공유 자원에 접근하는 코드 영역입니다.
   * 여러 프로세스가 동시에 임계 구역에 진입하면 데이터 무결성이 훼손될 수 있습니다.
   * 이를 해결하려면 아래 조건을 만족해야 합니다:
     * **상호 배제(Mutual Exclusion):** 한 번에 하나의 프로세스만 임계 구역에 들어갈 수 있어야 합니다.
     * **진행(Progress):** 임계 구역에 들어가야 할 프로세스가 없는 경우, 다른 프로세스가 무한히 대기하지 않아야 합니다.
     * **한정 대기(Bounded Waiting):** 한 프로세스가 임계 구역에 진입하기 전에 다른 프로세스가 무한히 대기하지 않도록 보장해야 합니다.
2. **교착 상태(Deadlock)**
   * 동기화가 잘못 설계되면 프로세스들이 서로 자원을 대기하며 영원히 진행되지 못하는 상태가 발생할 수 있습니다.
3. **기아 상태(Starvation)**
   * 한 프로세스가 우선순위가 낮거나 자원을 할당받지 못해 무한히 대기하는 상황입니다.

### **프로세스 동기화를 구현하는 방법**

#### 소프트웨어 기반 동기화 기법

* **데커의 알고리즘(Dekker's Algorithm)** 최초의 동기화 알고리즘 중 하나로, 두 프로세스가 공유 자원에 안전하게 접근할 수 있도록 상호 배제를 보장합니다.
* **피터슨 알고리즘(Peterson's Algorithm)** 임계 구역 문제를 해결하기 위해 두 프로세스가 플래그와 턴 변수를 사용하는 알고리즘입니다. 간단하면서도 효과적입니다.

#### 하드웨어 기반 동기화 기법

* Test-and-Set
  * CPU의 하드웨어 명령어를 사용해 \*\*원자적(Atomic)\*\*으로 값을 확인하고 설정합니다.
  * 임계 구역의 동시 접근을 방지합니다.
* Swap
  * 두 변수를 교환하는 작업을 원자적으로 수행하며 동기화를 구현합니다.

#### OS에서 제공하는 동기화 메커니즘

* **세마포어(Semaphore)**
  * 프로세스 간 동기화를 위해 사용되는 정수 값입니다.
  * 두 가지 형태로 사용됩니다:
    * **이진 세마포어(Binary Semaphore):** 값이 0 또는 1만 가질 수 있어 \*\*뮤텍스(Mutex)\*\*와 유사하게 동작합니다.
    * **계수 세마포어(Counting Semaphore):** 특정 자원의 사용 가능한 개수를 추적합니다.
* **뮤텍스(Mutex)**
  * 한 번에 하나의 프로세스만 자원에 접근할 수 있도록 보장하는 \*\*락(lock)\*\*입니다.
  * 세마포어와 달리, 소유권을 가진 프로세스만 락을 해제할 수 있습니다.
* **모니터(Monitor)**
  * 고수준 동기화 도구로, 프로그래밍 언어에서 제공되며 공유 자원에 대한 동기화 메커니즘을 포함합니다.
  * 임계 구역과 락을 자동으로 관리합니다.
* **조건 변수(Condition Variable)**
  * 프로세스가 특정 조건이 충족되기를 기다리며 대기할 수 있는 동기화 도구입니다.

#### 분산 시스템에서의 동기화

* 클락 동기화(Logical Clocks)
  * Lamport의 논리적 시계 같은 알고리즘을 사용해 이벤트 간의 순서를 정의합니다.
* 분산 락(Distributed Locks)
  * 네트워크 환경에서 공유 자원을 안전하게 접근하도록 락을 분산 환경에서 구현합니다.
  * 예: **ZooKeeper**, **Redis의 Redlock 알고리즘**

## 프로세스 교착 상태(Deadlock)

프로세스 교착 상태(Deadlock)는 두 개 이상의 프로세스가 서로 상대방의 작업이 끝나기만을 기다리며 무한 대기 상태에 빠지는 현상을 의미합니다. 교착 상태는 다음 네 가지 조건이 동시에 성립하며 이를 코프만 조건(Coffman Conditions)이라고 합니다:

1. **상호 배제(Mutual Exclusion)**
   * 최소 한 개의 자원이 비공유 모드로 사용되어야 합니다. 즉, 한 번에 하나의 프로세스만 해당 자원을 사용할 수 있습니다.
2. **점유 및 대기(Hold and Wait)**
   * 프로세스가 자신이 이미 점유한 자원을 놓지 않은 상태에서, 다른 자원을 추가로 요청하며 대기하는 상황입니다.
3. **비선점(No Preemption)**
   * 프로세스가 점유한 자원은 해당 프로세스가 자발적으로 방출하기 전까지 다른 프로세스가 강제로 빼앗을 수 없습니다.
4. **순환 대기(Circular Wait)**
   * 자원 간의 대기 관계가 원형으로 연결되어 각 프로세스가 다음 프로세스가 점유한 자원을 기다리는 상태입니다.

### 교착 상태의 예방과 해결 방법

**예방(Prevention)** Coffman 조건 중 하나 이상을 만족하지 않도록 시스템 설계를 변경합니다.

* **상호 배제 방지:** 일부 자원을 공유 가능하게 설계합니다.
* **점유 및 대기 방지:** 프로세스가 자원을 요청할 때, 필요한 모든 자원을 한꺼번에 요청하도록 강제합니다.
* **비선점 방지:** 선점 가능한 자원(예: CPU)을 도입합니다.
* **순환 대기 방지:** 자원에 우선순위를 지정하고, 항상 우선순위가 낮은 자원만 요청하도록 합니다.

**회피(Avoidance)** 교착 상태가 발생하지 않도록 자원의 상태를 지속적으로 감시하며, \*\*은행가 알고리즘(Banker's Algorithm)\*\*과 같은 기법을 사용해 안정적인 자원 할당을 유지합니다.

**탐지(Detection)** 교착 상태를 주기적으로 검사하여 발생 시 이를 탐지합니다. 탐지 후에는 교착 상태를 해결하기 위해 프로세스를 종료하거나 자원을 강제로 회수합니다.

**복구(Recovery)** 교착 상태를 탐지한 후 이를 복구하기 위한 방법입니다:

* 교착 상태에 있는 프로세스를 하나씩 종료합니다.
* 자원을 강제로 선점하여 다른 프로세스에게 할당합니다.

## 프로세스 관리의 실제 사례

현대 운영체제에서의 프로세스 관리는 다양하게 구현됩니다. 예를 들어:

* **Linux:** CFS(Completely Fair Scheduler)를 사용하여 프로세스를 스케줄링하며, 선점형 스케줄링을 기반으로 공정성을 보장
* **Windows:** 우선순위 기반의 선점형 스케줄링과 다양한 프로세스 관리 도구 제공
* **macOS:** Mach 커널 기반의 태스크 및 스레드 관리, 효율적인 자원 사용을 지원

이 외에도, 실시간 운영체제(RTOS)는 실시간 응답성을 보장하기 위해 특화된 스케줄링 알고리즘을 사용합니다.
