# 프로세스 스케줄링



## 스케줄링

**CPU 스케줄링**은 운영체제에서 **CPU 시간**을 여러 프로세스에게 효율적으로 할당하는 기법을 말합니다. 동시에 여러 프로세스가 실행될 때, CPU는 한 번에 하나의 프로세스만 처리할 수 있으므로 어떤 프로세스에게 언제 CPU를 할당할지 결정하는 것이 중요합니다

오늘날 CPU 스케줄링이 필요한 이유는 다음과 같습니다

- **멀티태스킹 환경**: 현대의 운영체제는 여러 프로세스가 동시에 실행되는 멀티태스킹을 지원합니다.
- **자원 활용의 최적화**: CPU 사용률을 최대화하고 자원을 효율적으로 관리하여 시스템 성능을 향상시킵니다.
- **공정성 보장**: 모든 프로세스가 공평하게 CPU를 사용할 수 있도록 합니다.
- **사용자 만족도 향상**: 응답 시간을 최소화하여 사용자 경험을 개선합니다.



### 스케줄링 단위

- **CPU Burst**: 프로세스의 사용중에 연속적으로 CPU를 사용하는 구간. 실제 CPU 를 사용하는 스케쥴링의 단위

- **I/O Burst**: I/O작업이 끝날때까지 Block되는 구간

![image (1) (1) (1) (1)](assets/image (1) (1) (1) (1)-1735889577230-9.png)

### 스케줄링 평가 기준

* **CPU 이용률** :  CPU가 작업을 처리하는 시간 / 전체 시스템 시간
* **처리량** : CPU가 처리하는 프로세스의 개수 / 단위 시간
* **총 처리 시간** : 프로세스가 시작해서 끝날때 까지 걸린 시간
* **대기시간** : 프로세스가 준비완료 큐에서 대기하는 시간의 총 합
* **응답시간** : 대화식 시스템에서 요청 후 첫 응답이 오기까지 걸린 시간



## 스케쥴링의 종류

### 선점 스케줄링(Preemptive Scheduling)

OS가 CPU이 사용권을 선점하고, 특정 요건에 따라 각 프로세스의 요청이 있을 때 프로세스에게 분배하는 방식

따라서 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하고긴급한 프로세스를 제어 가능

### 비선점 스케줄링(Non-Preemptive Scheduling)

어떤 프로세스가 CPU를 할당받으면 그 프로세스가 종료되거나, 입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되도록 보장

* 순서대로 처리되는 공정성이 있고, 다음에 처리해야할 프로세스와 상관없이 응답시간을 예상 가능
* 선점방식보다 스케쥴러 호출 빈도가 낮고, 문맥교환에 의한 오버헤드가 적다.
* 일괄처리 시스템에 적합하며 자칫 CPU사용시간이 긴 프로세스가 다른 프로세스들을 대기시킬 수 있으므로 처리율이 떨어질 수 있다는 단점이 있습니다.





## 스케줄링 대기열

OS는 프로세스 스케줄링 큐에 있는 모든 프로세스 제어 블록(PCB)을 유지합니다. OS는 각 프로세스 상태에 대해 별도의 큐를 유지 관리하고 동일한 실행 상태에 있는 모든 프로세스의 PCB는 동일한 큐에 배치됩니다. 프로세스의 상태가 변경되면 해당 PCB는 현재 큐에서 연결 해제되고 새 상태 큐로 이동합니다.

- **작업 대기열** − 이 대기열은 시스템의 모든 프로세스를 보관합니다.
- **준비 큐** − 이 큐는 메인 메모리에 상주하는 모든 프로세스 집합을 준비하고 실행을 기다립니다. 새 프로세스는 항상 이 큐에 배치됩니다.
- **장치 대기열** − I/O 장치를 사용할 수 없어 차단된 프로세스가 이 대기열을 구성합니다.

![queuing_diagram](assets/queuing_diagram.jpg)

https://www.tutorialspoint.com/



## 스케줄러

프로세스 스케줄링을 처리하는 특수 시스템 소프트웨어. 

시스템에 제출할 작업을 선택하고 실행할 프로세스를 결정한다.

- **단기 스케줄러(Short-Term Scheduler) - CPU 스케줄러**: 프로세스의 실행 준비 상태를 실행 상태로 전환한다. 단기 스케줄러는 장기 스케줄러보다 빠르다.
- **중기 스케줄러(Mid-Term Scheduler) - 프로세스 교체 스케줄러**: 메모리에서 프로세스를 일시 중단(Swapping)하고 스와핑된 프로세스를 처리한다.
- **장기 스케줄러(Long-Term Scheduler) - 작업 스케줄러**: 어떤 프로그램이 처리를 위해 시스템에 받아들여지는지 결정한다.



## 문맥 교환 (Context Switching)

문맥 교환은 프로세스 제어 블록에서 CPU의 상태와 컨텍스트를 저장하고 복원하는 기능을 통해 프로세스 실행을 나중에 같은 지점에서 재개할 수 있도록 한다. 이를 통해 단일 CPU가 여러 프로세스를 작업할 수 있게 해준다.

### Context Switching

* CPU 시간공유 시스템의 경우 일정 시간이 지나면 기존 프로세스를 **준비** 상태로 만들고 다른 프로세스를 **수행** 상태로 만들어서 실행

### Scheduler

* Context Switching을 전문적으로 담당하는 스케줄러는 위에서 배운 CPU 스케줄러
* CPU 스케줄러는 Ready Queue에 대기 중인 프로세스를 어떤 순서로 실행시킬 것인지에 대한 스케줄러

### Dispatcher

* 스위치할 때 이 정보들을 보존해야 A의 차례가 돌아왔을 때 이전에 수행하던 작업이 끊기지 않고 수행될 수 있습니다.
* 다른 프로세스 작업 시 현재 작업의 정보를 임시 저장하고 다시 자신의 작업 차례가 왔을 때 꺼내 씀





### Priority Scheduling(우선순위 스케쥴링)

정적/동적으로 우선순위를 부여하고 우선순위 순서대로 처리 (최소 버스트 시간 기준)

Starvation(기아  현상): 우선순위가 낮은 프로세스는 무한정 기다릴 수도 있다

\-> Aging(노화) 기법으로 해결. 시간에 따라 우선순위를 증가



### Round Robin(라운드로빈)

{% hint style="info" %}
FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU 할당
{% endhint %}

정해진 시간 할당량 동안 프로세스를 할당하고, 준비완료의큐 마지막으로 이동

시간 할당량이 너무 작을 경우: 빈번한 문맥 전환

시간 할당량이 너무 클 경우: FCFS와 비슷해짐



### MultiLevel-Queue(다단계 큐)

준비완료 큐를 여러 개의 큐로 분할하여, 각각  큐의  우선순위를  정한다

프로세스를 우선순위에 따라 해당하는 큐에 배치.

우선순위가 높은 큐부터 순서대로 처리



비선점





### FCFS(First Come, First Serve)

큐에 도착한 순서대로 CPU 할당 -> 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐

**먼저 도착한 프로세스를 먼저 처리**하는 기본적인 스케쥴링 알고리즘

FIFO큐(먼저 입력된것 먼저 출력)를 이용하여 간단하게 구현

**Convoy Effect(호위 효과)**: 처리시간이 긴 프로세스가 선점되면, 나머지 프로세스의 대기 시간이 매우 길어짐

### SJF(Shorted Job First)


수행시간이 가장 짧다고 판단되는 작업 먼저 수행 -> FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리

CPU 버스트 타임이 가장 짦은, **최단작업을 우선** 스케쥴링

* 가장 적은 평균 대기 시간을 가짐
* 만약 CPU버스트 시간이 동일하다면 FCFS방식을 따름
* 다만 선점형인 경우에는 위와같이 진행이 되지만 비 선점형일 경우엔 최소잔여시간우선 법칙을 따름
* 현재 CPU에 할당된 프로세스의 남은 잔여시간과, 새로 들어온 프로세스의 CPU버스트 타임을 비교하여 더 적은 프로세스에게 할당

### HRN( Highest Response-ratio Next)

공식에 따라 우선순위를 계산하여 순서를 할당하는 스케줄링 

우선순위 = (대기시간 + 실행시간) / (실행시간)



## 대기 큐(Waiting Queue)

## ![image (5)](assets/image (5).png)

### 1. Job Queue

HDD에서 프로그램을 메모리에 올릴 때 메모리가 꽉차면 대기하는 공간

HDD -> \[Job Queue] -> Memory



### 2. Ready Queue

CPU가 이미 사용 중일 때 메모리에서 올라온 프로세스들이 실행을 위해 대기하는 공간

Memory -> \[Ready Queue] -> CPU



### 3. Device Queue

입출력 장치를 이용하기 위해 입출력 작업을 기다리는 공간

I/O 장치 큐들을 통틀어 부름



## 스케줄링

### Job Secheduler

* Job Queue의 프로그램들을 어떤 순서로 메모리에 올릴지 결정
* 프로그램이 새로 시작될 때, 메모리가 가득 찼을 때



### CPU Scheduler

* Ready Queue의 프로세스들을 어떤 순서로 서비스 할 것인지(CPU에 올릴 것인지) 결정



### Device Scheduler

* Device Queue의 프로세스들을 어떤 순서로 I/O 장치를 이용하게 할 것인지 결정
* I/O Bound Process → 대부분 시간을 I/O에 사용
* CPU Bound Process → 대부분 시간을 CPU 연산에 사용



## **Swapping**

오랫동안 동작이 없는 프로세스는 잠시 HDD로 내려놓고, 다른 프로세스를 실행하거나 기존 프로세스에 메모리를 더 할당하는 등 메모리를 더 효율적으로 활용

* **Swap Out:** 메모리 -> HDD로 내리는 작업
* **Swap In:** HDD -> 메모리로 다시 올리는 작업