# Virtual DOM

- DOM = 브라우저에서 런타임 문서 모델
  - `Node`로 구성
- Virtual DOM = 복제된 자바스크립트 객체
  - `자바스크립트 객체`로 구성



React에서 UI 변경 -> 가상DOM 업데이트 -> 실제 DOM 업데이트

✅실제 DOM을 업데이트하는 것은 비용이 많이 들고 느린 작업이기 때문

`diffing 알고리즘`: React에서 가상 DOM 업데이트 시에 이전버전과 새로운 버전을 비교하여 차이점을 식별하고 실제 DOM 업데이트를 위한 최소한의 변경 사항을 결정





### 성능

DOM의 변경 사항이 있을 때마다 리플로우, 리페인팅와 같은 과정을 거치게 된다. 이는 비용이 많이 드는 작업이며, 많은 리소스를 필요로 한다. 이러한 작업은 스마트폰과 같은 소형의 저전력 기기에서 더욱 중요하다

✅가상 DOM을 사용하면 실제 DOM의 복잡성을 추상화하여 숨기고, UI를 표현하기 위한 더 간단한 방법을 제공할 수 있다

✅성능을 최적화하여 다양한 장치에서 원활하게 사용할 수 있다



### 브라우저 간 호환성

브라우저마다 문서를 모델링하는 방법이 다르다. 어떤 요소 또는 속성이 특정 브라우저에서는 지원하지 않을 수 있다. 모든 플랫폼에서 원활하게 동작하기 위한 방법이 필요하다

✅React에서는 모든 브라우저에서 이벤트를 동일하게 처리하기 위해서 이벤트 래퍼 `SyntheticEvent` 객체를 전달합니다.

✅이벤트와 상호작용하는 방법을 통일하여 개발자가 브라우저별로 코드를 작성할 필요가 없다

✅이벤트 리스너 대신 요소에 이벤트를 직접 연결하여 일부 이전 브라우저의 특정 요소가 일부 이벤트를 사용할 수 없는 문제를 피할 수 있다

✅React는 브라우저마다 다른 이벤트 처리 방식을 통일하고, 고유 이벤트에 대한 접근이 필요한 경우를 대비해 `event.nativeEvent`를 제공



### 문서 조각(DocumentFragment)

노드로 구성된 문서 구조의 세그먼트를 저장하는 경량 버전. 문서의 여러 변경 사항을 일괄 처리하여 DOM을 효율적으로 조작하고 리소스를 아낄 수 있다

문서 조각을 DOM에 추가하여 단일 리플로우 리페인트를 처리

✅문서 조각의 업데이트 사항들에 대해 일괄 처리할 수 있다

✅노드가 문서 조각에 추가될 때 DOM상의 자신의 부모로부터 제거되어 메모리 효율적이다

✅문서 조각이 실제 DOM에 추가되기 전까지 적용되지 않으므로 중복 렌더리을 방지할 수 있다

```javascript
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement("li");
  li.textContent = `Item ${i + 1}`;
  fragment.appendChild(li);
}
document.getElementById("itemList").appendChild(fragment);
```

**문서 조각과 가상DOM**: 문서 조각은 DOM을 업데이트 하기 전 변경사항을 집합을 만들고 이를 일괄 처리하여 효율적으로 업데이트한다. React의 가상DOM은 React 애플리케이션 전체에서 UI 업데이트를 지능적으로 비교하고 효율적으로 렌더링하도록 한다. 이러한 세부 구현은 추상화되어 개발자가 신경쓰지 않아도 되기 때문에 UI 작성에만 집중할 수 있도록 한다



## React 엘리먼트

createElement 함수를 사용하여 요소를 생성하고 이를의 중첩을 통해 사용자 인터페이스를 표현한다

```jsx
import { createElement } from 'react';

function Greeting({ name }) {
  return createElement(
    'h1',
    { className: 'greeting' },
    'Hello'
  );
}
```

```json
// console.log(element)
{
  $$typeof: Symbol(react.element)
  "type": "h1",
  "key": null,
  "ref": null,
  "props": {
    "className": "greeting",
    "children": "Hello "
  },
  "_owner": {
    "@r": 9
  },
  "_store": {}
}
```

- `$$typeof`: React에서 해당 객체가 유효한 React 요소인지 확인하기 위해 사용
- `type`: 요소의 유형. 사용자 정의 구성요소의 경우 해당 구성요소 또는 HTML 기본 엘리먼트 태그 이름
- `ref`: DOM의 노드를 직접 조작하기 위한 참조
- `props`: 구성 요소에 속성 및 소품을 전달하기 위한 개체
- `_owner`: React에서 이 요소를 생성한 구성 요소를 추적하기 위해 내부적으로 사용되며, 프로덕션 빌드가 아닐 때만 접근할 수 있다
- `_store`: 요소에 대한 추가 데이터를 저장하기 위해 내부적으로만 사용되는 객체



## React 업데이트

React의 diffing 알고리즘에 의해 최적화된 업데이트. 실제DOM과 가상DOM 간의 비교

### 루트 수준 노드

두 트리의 루트 수준의 노드가 다른 경우 전체 트리를 업데이트

노드의 자식이 다른 경우, 변경된 자식 노드만 업데이트

### 다른 유형의 요소

span -> p 태그로 변경과 같이 노드의 유형(type)이 변경된 경우 이전 노드 삭제 후 새로운 노드 추가

### 동일한 유형의 요소

두 요소의 속성을 비교하여 변경된 속성만 업데이트

### 요소 제거

트리에서 노드 제거 시, 실제 DOM에서 해당 노드 제거

### 자식 노드의 반복

노드의 자식이 같지만 순서가 변경된 경우 노드를 다시 생성하지 않고 실제DOM에서 노드의 순서만 변경하기 위해 key값을 사용할 수 있다. 노드의 key prop이 있는 경우 이를 통해 노드를 변경해야 할지 판단. 상태를 재설정할 수 있음.



### 상태 변경

React에서는 구성 요소의 상태 변경 시 해당 구성 요소와 구성 요소의 하위 항목을 모두 다시 렌더링한다

어떤 구성 요소가 상태 변화의 영향을 받는지 모르기 때문이다. 이러한 리렌더링은 일반적으로 문제가 되지 않지만 일부 상황에서는 성능 저하로 이어질 수 있다. 이러한 리렌더링을 최적화하기 위해 `useMemo`, `memo`와 같은 기능을 사용할 수 있다

